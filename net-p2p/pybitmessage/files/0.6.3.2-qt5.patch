diff --git a/setup.py b/setup.py
index ba34f6d..5578895 100644
--- a/setup.py
+++ b/setup.py
@@ -1,13 +1,13 @@
 #!/usr/bin/env python2.7
 
 import os
-import sys
 import shutil
 from setuptools import setup, Extension
 from setuptools.command.install import install
 
 from src.version import softwareVersion
 
+
 class InstallCmd(install):
     def run(self):
         # prepare icons directories
@@ -38,7 +38,7 @@ if __name__ == "__main__":
         libraries=['pthread', 'crypto'],
     )
 
-    installRequires = []
+    installRequires = []  # QtPy
     packages = [
         'pybitmessage',
         'pybitmessage.bitmessageqt',
@@ -62,7 +62,8 @@ if __name__ == "__main__":
             import umsgpack
             installRequires.append("umsgpack")
         except ImportError:
-            packages += ['pybitmessage.fallback', 'pybitmessage.fallback.umsgpack']
+            packages += [
+                'pybitmessage.fallback', 'pybitmessage.fallback.umsgpack']
 
     dist = setup(
         name='pybitmessage',
diff --git a/src/bitmessagemain.py b/src/bitmessagemain.py
index accd574..6300fb7 100755
--- a/src/bitmessagemain.py
+++ b/src/bitmessagemain.py
@@ -19,7 +19,8 @@ sys.path.insert(0, app_dir)
 import depends
 depends.check_dependencies()
 
-import signal  # Used to capture a Ctrl-C keypress so that Bitmessage can shutdown gracefully.
+# Used to capture a Ctrl-C keypress so that Bitmessage can shutdown gracefully.
+import signal
 # The next 3 are used for the API
 from singleinstance import singleinstance
 import errno
@@ -73,17 +74,19 @@ def connectToStream(streamNumber):
     selfInitiatedConnections[streamNumber] = {}
 
     if isOurOperatingSystemLimitedToHavingVeryFewHalfOpenConnections():
-        # Some XP and Vista systems can only have 10 outgoing connections at a time.
+        # Some XP and Vista systems can only have 10 outgoing connections
+        # at a time.
         state.maximumNumberOfHalfOpenConnections = 9
     else:
         state.maximumNumberOfHalfOpenConnections = 64
     try:
         # don't overload Tor
-        if BMConfigParser().get('bitmessagesettings', 'socksproxytype') != 'none':
+        if BMConfigParser().get(
+                'bitmessagesettings', 'socksproxytype') != 'none':
             state.maximumNumberOfHalfOpenConnections = 4
     except:
         pass
-    
+
     with knownnodes.knownNodesLock:
         if streamNumber not in knownnodes.knownNodes:
             knownnodes.knownNodes[streamNumber] = {}
@@ -94,6 +97,7 @@ def connectToStream(streamNumber):
 
     BMConnectionPool().connectToStream(streamNumber)
 
+
 def _fixSocket():
     if sys.platform.startswith('linux'):
         socket.SO_BINDTODEVICE = 25
@@ -105,6 +109,7 @@ def _fixSocket():
     # socket.inet_ntop but we can make one ourselves using ctypes
     if not hasattr(socket, 'inet_ntop'):
         addressToString = ctypes.windll.ws2_32.WSAAddressToStringA
+
         def inet_ntop(family, host):
             if family == socket.AF_INET:
                 if len(host) != 4:
@@ -125,6 +130,7 @@ def _fixSocket():
     # Same for inet_pton
     if not hasattr(socket, 'inet_pton'):
         stringToAddress = ctypes.windll.ws2_32.WSAStringToAddressA
+
         def inet_pton(family, host):
             buf = "\0" * 28
             lengthBuf = pack("I", len(buf))
@@ -148,18 +154,21 @@ def _fixSocket():
     if not hasattr(socket, 'IPV6_V6ONLY'):
         socket.IPV6_V6ONLY = 27
 
+
 # This thread, of which there is only one, runs the API.
 class singleAPI(threading.Thread, helper_threading.StoppableThread):
     def __init__(self):
         threading.Thread.__init__(self, name="singleAPI")
         self.initStop()
-        
+
     def stopThread(self):
         super(singleAPI, self).stopThread()
         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         try:
-            s.connect((BMConfigParser().get('bitmessagesettings', 'apiinterface'), BMConfigParser().getint(
-                'bitmessagesettings', 'apiport')))
+            s.connect((
+                BMConfigParser().get('bitmessagesettings', 'apiinterface'),
+                BMConfigParser().getint('bitmessagesettings', 'apiport')
+            ))
             s.shutdown(socket.SHUT_RDWR)
             s.close()
         except:
@@ -175,19 +184,23 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
             try:
                 if attempt > 0:
                     port = randint(32767, 65535)
-                se = StoppableXMLRPCServer((BMConfigParser().get('bitmessagesettings', 'apiinterface'), port),
+                se = StoppableXMLRPCServer((
+                    BMConfigParser().get('bitmessagesettings', 'apiinterface'),
+                    port),
                     MySimpleXMLRPCRequestHandler, True, True)
             except socket.error as e:
                 if e.errno in (errno.EADDRINUSE, errno.WSAEADDRINUSE):
                     continue
             else:
                 if attempt > 0:
-                    BMConfigParser().set("bitmessagesettings", "apiport", str(port))
+                    BMConfigParser().set(
+                        "bitmessagesettings", "apiport", str(port))
                     BMConfigParser().save()
                 break
         se.register_introspection_functions()
         se.serve_forever()
 
+
 # This is a list of current connections (the thread pointers at least)
 selfInitiatedConnections = {}
 
@@ -197,15 +210,17 @@ if shared.useVeryEasyProofOfWorkForTesting:
     defaults.networkDefaultPayloadLengthExtraBytes = int(
         defaults.networkDefaultPayloadLengthExtraBytes / 100)
 
+
 class Main:
     def start(self):
         _fixSocket()
 
-        daemon = BMConfigParser().safeGetBoolean('bitmessagesettings', 'daemon')
+        daemon = BMConfigParser().safeGetBoolean(
+            'bitmessagesettings', 'daemon')
 
         try:
-            opts, args = getopt.getopt(sys.argv[1:], "hcd",
-                ["help", "curses", "daemon"])
+            opts, args = getopt.getopt(
+                sys.argv[1:], "hcd", ["help", "curses", "daemon"])
 
         except getopt.GetoptError:
             self.usage()
@@ -233,65 +248,76 @@ class Main:
         helper_threading.set_thread_name("PyBitmessage")
 
         state.dandelion = BMConfigParser().safeGetInt('network', 'dandelion')
-        # dandelion requires outbound connections, without them, stem objects will get stuck forever
-        if state.dandelion and not BMConfigParser().safeGetBoolean('bitmessagesettings', 'sendoutgoingconnections'):
+        # dandelion requires outbound connections, without them,
+        # stem objects will get stuck forever
+        if state.dandelion and not BMConfigParser().safeGetBoolean(
+                'bitmessagesettings', 'sendoutgoingconnections'):
             state.dandelion = 0
 
         helper_bootstrap.knownNodes()
         # Start the address generation thread
         addressGeneratorThread = addressGenerator()
-        addressGeneratorThread.daemon = True  # close the main program even if there are threads left
+        # close the main program even if there are threads left
+        addressGeneratorThread.daemon = True
         addressGeneratorThread.start()
 
         # Start the thread that calculates POWs
         singleWorkerThread = singleWorker()
-        singleWorkerThread.daemon = True  # close the main program even if there are threads left
+        # close the main program even if there are threads left
+        singleWorkerThread.daemon = True
         singleWorkerThread.start()
 
         # Start the SQL thread
         sqlLookup = sqlThread()
-        sqlLookup.daemon = False  # DON'T close the main program even if there are threads left. The closeEvent should command this thread to exit gracefully.
+        # DON'T close the main program even if there are threads left.
+        # The closeEvent should command this thread to exit gracefully.
+        sqlLookup.daemon = False
         sqlLookup.start()
 
-        Inventory() # init
-        Dandelion() # init, needs to be early because other thread may access it early
+        Inventory()  # init
+        # init, needs to be early because other thread may access it early
+        Dandelion()
 
         # SMTP delivery thread
-        if daemon and BMConfigParser().safeGet("bitmessagesettings", "smtpdeliver", '') != '':
+        if daemon and BMConfigParser().safeGet(
+                "bitmessagesettings", "smtpdeliver", '') != '':
             smtpDeliveryThread = smtpDeliver()
             smtpDeliveryThread.start()
 
         # SMTP daemon thread
-        if daemon and BMConfigParser().safeGetBoolean("bitmessagesettings", "smtpd"):
+        if daemon and BMConfigParser().safeGetBoolean(
+                "bitmessagesettings", "smtpd"):
             smtpServerThread = smtpServer()
             smtpServerThread.start()
 
         # Start the thread that calculates POWs
         objectProcessorThread = objectProcessor()
-        objectProcessorThread.daemon = False  # DON'T close the main program even the thread remains. This thread checks the shutdown variable after processing each object.
+        # DON'T close the main program even the thread remains. This
+        # thread checks the shutdown variable after processing each object.
+        objectProcessorThread.daemon = False
         objectProcessorThread.start()
 
         # Start the cleanerThread
         singleCleanerThread = singleCleaner()
-        singleCleanerThread.daemon = True  # close the main program even if there are threads left
+        # close the main program even if there are threads left
+        singleCleanerThread.daemon = True
         singleCleanerThread.start()
 
         shared.reloadMyAddressHashes()
         shared.reloadBroadcastSendersForWhichImWatching()
 
         if BMConfigParser().safeGetBoolean('bitmessagesettings', 'apienabled'):
-            try:
-                apiNotifyPath = BMConfigParser().get(
-                    'bitmessagesettings', 'apinotifypath')
-            except:
-                apiNotifyPath = ''
-            if apiNotifyPath != '':
+            apiNotifyPath = BMConfigParser().safeGet(
+                'bitmessagesettings', 'apinotifypath', ''
+            )
+            if apiNotifyPath:
                 with shared.printLock:
                     print('Trying to call', apiNotifyPath)
 
                 call([apiNotifyPath, "startingUp"])
             singleAPIThread = singleAPI()
-            singleAPIThread.daemon = True  # close the main program even if there are threads left
+            # close the main program even if there are threads left
+            singleAPIThread.daemon = True
             singleAPIThread.start()
 
         BMConnectionPool()
@@ -317,13 +343,14 @@ class Main:
 
         connectToStream(1)
 
-        if BMConfigParser().safeGetBoolean('bitmessagesettings','upnp'):
+        if BMConfigParser().safeGetBoolean('bitmessagesettings', 'upnp'):
             import upnp
             upnpThread = upnp.uPnPThread()
             upnpThread.start()
 
-        if daemon == False and BMConfigParser().safeGetBoolean('bitmessagesettings', 'daemon') == False:
-            if state.curses == False:
+        if daemon is False and BMConfigParser().safeGetBoolean(
+                'bitmessagesettings', 'daemon') is False:
+            if state.curses is False:
                 if not depends.check_pyqt():
                     print('PyBitmessage requires PyQt unless you want to run it as a daemon and interact with it using the API. You can download PyQt from http://www.riverbankcomputing.com/software/pyqt/download   or by searching Google for \'PyQt Download\'. If you want to run in daemon mode, see https://bitmessage.org/wiki/Daemon')
                     print('You can also run PyBitmessage with the new curses interface by providing \'-c\' as a commandline argument.')
@@ -333,7 +360,7 @@ class Main:
                 bitmessageqt.run()
             else:
                 if True:
-#                if depends.check_curses():
+                    # if depends.check_curses():
                     print('Running with curses')
                     import bitmessagecurses
                     bitmessagecurses.runwrapper()
@@ -360,7 +387,7 @@ class Main:
             pass
         else:
             parentPid = os.getpid()
-            shared.thisapp.lock() # relock
+            shared.thisapp.lock()  # relock
         os.umask(0)
         try:
             os.setsid()
@@ -379,8 +406,8 @@ class Main:
             # fork not implemented
             pass
         else:
-            shared.thisapp.lock() # relock
-        shared.thisapp.lockPid = None # indicate we're the final child
+            shared.thisapp.lock()  # relock
+        shared.thisapp.lockPid = None  # indicate we're the final child
         sys.stdout.flush()
         sys.stderr.flush()
         if not sys.platform.startswith('win'):
@@ -416,20 +443,21 @@ All parameters are optional.
             print('Stopping Bitmessage Deamon.')
         shutdown.doCleanShutdown()
 
-
-    #TODO: nice function but no one is using this 
+    # TODO: nice function but no one is using this
     def getApiAddress(self):
-        if not BMConfigParser().safeGetBoolean('bitmessagesettings', 'apienabled'):
-            return None
+        if not BMConfigParser().safeGetBoolean(
+                'bitmessagesettings', 'apienabled'):
+            return
         address = BMConfigParser().get('bitmessagesettings', 'apiinterface')
         port = BMConfigParser().getint('bitmessagesettings', 'apiport')
-        return {'address':address,'port':port}
+        return {'address': address, 'port': port}
 
 
 def main():
     mainprogram = Main()
     mainprogram.start()
 
+
 if __name__ == "__main__":
     main()
 
diff --git a/src/bitmessageqt/__init__.py b/src/bitmessageqt/__init__.py
index 7bbd7dd..8c2f06d 100644
--- a/src/bitmessageqt/__init__.py
+++ b/src/bitmessageqt/__init__.py
@@ -1,13 +1,7 @@
 from debug import logger
 import sys
 
-try:
-    from PyQt4 import QtCore, QtGui
-    from PyQt4.QtNetwork import QLocalSocket, QLocalServer
-except Exception as err:
-    logmsg = 'PyBitmessage requires PyQt unless you want to run it as a daemon and interact with it using the API. You can download it from http://www.riverbankcomputing.com/software/pyqt/download or by searching Google for \'PyQt Download\' (without quotes).'
-    logger.critical(logmsg, exc_info=True)
-    sys.exit()
+from qtpy import QtCore, QtGui, QtWidgets, QtNetwork
 
 from tr import _translate
 from addresses import decodeAddress, addBMIfNotPresent
@@ -72,27 +66,33 @@ def change_translation(newlocale):
     global qmytranslator, qsystranslator
     try:
         if not qmytranslator.isEmpty():
-            QtGui.QApplication.removeTranslator(qmytranslator)
+            QtWidgets.QApplication.removeTranslator(qmytranslator)
     except:
         pass
     try:
         if not qsystranslator.isEmpty():
-            QtGui.QApplication.removeTranslator(qsystranslator)
+            QtWidgets.QApplication.removeTranslator(qsystranslator)
     except:
         pass
 
     qmytranslator = QtCore.QTranslator()
-    translationpath = os.path.join (paths.codePath(), 'translations', 'bitmessage_' + newlocale)
+    translationpath = os.path.join(
+        paths.codePath(), 'translations', 'bitmessage_' + newlocale)
     qmytranslator.load(translationpath)
-    QtGui.QApplication.installTranslator(qmytranslator)
+    QtWidgets.QApplication.installTranslator(qmytranslator)
 
     qsystranslator = QtCore.QTranslator()
     if paths.frozen:
-        translationpath = os.path.join (paths.codePath(), 'translations', 'qt_' + newlocale)
+        translationpath = os.path.join(
+            paths.codePath(), 'translations', 'qt_' + newlocale)
     else:
-        translationpath = os.path.join (str(QtCore.QLibraryInfo.location(QtCore.QLibraryInfo.TranslationsPath)), 'qt_' + newlocale)
+        translationpath = os.path.join(
+            str(QtCore.QLibraryInfo.location(
+                QtCore.QLibraryInfo.TranslationsPath
+            )), 'qt_' + newlocale
+        )
     qsystranslator.load(translationpath)
-    QtGui.QApplication.installTranslator(qsystranslator)
+    QtWidgets.QApplication.installTranslator(qsystranslator)
 
     lang = locale.normalize(l10n.getTranslationLanguage())
     langs = [lang.split(".")[0] + "." + l10n.encoding, lang.split(".")[0] + "." + 'UTF-8', lang]
@@ -123,49 +123,35 @@ class MyForm(settingsmixin.SMainWindow):
     REPLY_TYPE_CHAN = 1
 
     def init_file_menu(self):
-        QtCore.QObject.connect(self.ui.actionExit, QtCore.SIGNAL(
-            "triggered()"), self.quit)
-        QtCore.QObject.connect(self.ui.actionNetworkSwitch, QtCore.SIGNAL(
-            "triggered()"), self.network_switch)
-        QtCore.QObject.connect(self.ui.actionManageKeys, QtCore.SIGNAL(
-            "triggered()"), self.click_actionManageKeys)
-        QtCore.QObject.connect(self.ui.actionDeleteAllTrashedMessages,
-                               QtCore.SIGNAL(
-                                   "triggered()"),
-                               self.click_actionDeleteAllTrashedMessages)
-        QtCore.QObject.connect(self.ui.actionRegenerateDeterministicAddresses,
-                               QtCore.SIGNAL(
-                                   "triggered()"),
-                               self.click_actionRegenerateDeterministicAddresses)
-        QtCore.QObject.connect(self.ui.pushButtonAddChan, QtCore.SIGNAL(
-            "clicked()"),
-                               self.click_actionJoinChan) # also used for creating chans.
-        QtCore.QObject.connect(self.ui.pushButtonNewAddress, QtCore.SIGNAL(
-            "clicked()"), self.click_NewAddressDialog)
-        QtCore.QObject.connect(self.ui.pushButtonAddAddressBook, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonAddAddressBook)
-        QtCore.QObject.connect(self.ui.pushButtonAddSubscription, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonAddSubscription)
-        QtCore.QObject.connect(self.ui.pushButtonTTL, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonTTL)
-        QtCore.QObject.connect(self.ui.pushButtonClear, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonClear)
-        QtCore.QObject.connect(self.ui.pushButtonSend, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonSend)
-        QtCore.QObject.connect(self.ui.pushButtonFetchNamecoinID, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonFetchNamecoinID)
-        QtCore.QObject.connect(self.ui.actionSettings, QtCore.SIGNAL(
-            "triggered()"), self.click_actionSettings)
-        QtCore.QObject.connect(self.ui.actionAbout, QtCore.SIGNAL(
-            "triggered()"), self.click_actionAbout)
-        QtCore.QObject.connect(self.ui.actionSupport, QtCore.SIGNAL(
-            "triggered()"), self.click_actionSupport)
-        QtCore.QObject.connect(self.ui.actionHelp, QtCore.SIGNAL(
-            "triggered()"), self.click_actionHelp)
+        self.ui.actionExit.triggered.connect(self.quit)
+        self.ui.actionNetworkSwitch.triggered.connect(self.network_switch)
+        self.ui.actionManageKeys.triggered.connect(self.click_actionManageKeys)
+        self.ui.actionDeleteAllTrashedMessages.triggered.connect(
+            self.click_actionDeleteAllTrashedMessages)
+        self.ui.actionRegenerateDeterministicAddresses.triggered.connect(
+            self.click_actionRegenerateDeterministicAddresses)
+        self.ui.actionSettings.triggered.connect(self.click_actionSettings)
+        self.ui.actionAbout.triggered.connect(self.click_actionAbout)
+        self.ui.actionSupport.triggered.connect(self.click_actionSupport)
+        self.ui.actionHelp.triggered.connect(self.click_actionHelp)
+
+        # also used for creating chans.
+        self.ui.pushButtonAddChan.clicked.connect(self.click_actionJoinChan)
+        self.ui.pushButtonNewAddress.clicked.connect(
+            self.click_NewAddressDialog)
+        self.ui.pushButtonAddAddressBook.clicked.connect(
+            self.click_pushButtonAddAddressBook)
+        self.ui.pushButtonAddSubscription.clicked.connect(
+            self.click_pushButtonAddAddressBook)
+        self.ui.pushButtonTTL.clicked.connect(self.click_pushButtonTTL)
+        self.ui.pushButtonClear.clicked.connect(self.click_pushButtonClear)
+        self.ui.pushButtonSend.clicked.connect(self.click_pushButtonSend)
+        self.ui.pushButtonFetchNamecoinID.clicked.connect(
+            self.click_pushButtonFetchNamecoinID)
 
     def init_inbox_popup_menu(self, connectSignal=True):
         # Popup menu for the Inbox tab
-        self.ui.inboxContextMenuToolbar = QtGui.QToolBar()
+        self.ui.inboxContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionReply = self.ui.inboxContextMenuToolbar.addAction(_translate(
             "MainWindow", "Reply to sender"), self.on_action_InboxReply)
@@ -201,25 +187,22 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.tableWidgetInbox.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.tableWidgetInbox, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuInbox)
+            self.ui.tableWidgetInbox.customContextMenuRequested.connect(
+                self.on_context_menuInbox)
         self.ui.tableWidgetInboxSubscriptions.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.tableWidgetInboxSubscriptions, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuInbox)
+            self.ui.tableWidgetInboxSubscriptions.customContextMenuRequested.connect(
+                self.on_context_menuInbox)
         self.ui.tableWidgetInboxChans.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.tableWidgetInboxChans, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuInbox)
+            self.ui.tableWidgetInboxChans.customContextMenuRequested.connect(
+                self.on_context_menuInbox)
 
     def init_identities_popup_menu(self, connectSignal=True):
         # Popup menu for the Your Identities tab
-        self.ui.addressContextMenuToolbarYourIdentities = QtGui.QToolBar()
+        self.ui.addressContextMenuToolbarYourIdentities = QtWidgets.QToolBar()
         # Actions
         self.actionNewYourIdentities = self.ui.addressContextMenuToolbarYourIdentities.addAction(_translate(
             "MainWindow", "New"), self.on_action_YourIdentitiesNew)
@@ -253,13 +236,12 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.treeWidgetYourIdentities.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.treeWidgetYourIdentities, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuYourIdentities)
+            self.ui.treeWidgetYourIdentities.customContextMenuRequested.connect(
+                self.on_context_menuYourIdentities)
 
     def init_chan_popup_menu(self, connectSignal=True):
         # Popup menu for the Channels tab
-        self.ui.addressContextMenuToolbar = QtGui.QToolBar()
+        self.ui.addressContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionNew = self.ui.addressContextMenuToolbar.addAction(_translate(
             "MainWindow", "New"), self.on_action_YourIdentitiesNew)
@@ -288,13 +270,12 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.treeWidgetChans.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.treeWidgetChans, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuChan)
+            self.ui.treeWidgetChans.customContextMenuRequested.connect(
+                self.on_context_menuChan)
 
     def init_addressbook_popup_menu(self, connectSignal=True):
         # Popup menu for the Address Book page
-        self.ui.addressBookContextMenuToolbar = QtGui.QToolBar()
+        self.ui.addressBookContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionAddressBookSend = self.ui.addressBookContextMenuToolbar.addAction(
             _translate(
@@ -325,13 +306,12 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.tableWidgetAddressBook.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.tableWidgetAddressBook, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuAddressBook)
+            self.ui.tableWidgetAddressBook.customContextMenuRequested.connect(
+                self.on_context_menuAddressBook)
 
     def init_subscriptions_popup_menu(self, connectSignal=True):
         # Popup menu for the Subscriptions page
-        self.ui.subscriptionsContextMenuToolbar = QtGui.QToolBar()
+        self.ui.subscriptionsContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionsubscriptionsNew = self.ui.subscriptionsContextMenuToolbar.addAction(
             _translate("MainWindow", "New"), self.on_action_SubscriptionsNew)
@@ -353,13 +333,12 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.treeWidgetSubscriptions.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.ui.treeWidgetSubscriptions, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuSubscriptions)
+            self.ui.treeWidgetSubscriptions.customContextMenuRequested.connect(
+                self.on_context_menuSubscriptions)
 
     def init_sent_popup_menu(self, connectSignal=True):
         # Popup menu for the Sent page
-        self.ui.sentContextMenuToolbar = QtGui.QToolBar()
+        self.ui.sentContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionTrashSentMessage = self.ui.sentContextMenuToolbar.addAction(
             _translate(
@@ -371,7 +350,7 @@ class MyForm(settingsmixin.SMainWindow):
         self.actionForceSend = self.ui.sentContextMenuToolbar.addAction(
             _translate(
                 "MainWindow", "Force send"), self.on_action_ForceSend)
-        # self.popMenuSent = QtGui.QMenu( self )
+        # self.popMenuSent = QtWidgets.QMenu( self )
         # self.popMenuSent.addAction( self.actionSentClipboard )
         # self.popMenuSent.addAction( self.actionTrashSentMessage )
 
@@ -385,17 +364,16 @@ class MyForm(settingsmixin.SMainWindow):
             treeWidget.header().setSortIndicator(
                 0, QtCore.Qt.AscendingOrder)
         # init dictionary
-        
+
         db = getSortedSubscriptions(True)
         for address in db:
             for folder in folders:
-                if not folder in db[address]:
+                if folder not in db[address]:
                     db[address][folder] = {}
-            
+
         if treeWidget.isSortingEnabled():
             treeWidget.setSortingEnabled(False)
 
-        widgets = {}
         i = 0
         while i < treeWidget.topLevelItemCount():
             widget = treeWidget.topLevelItem(i)
@@ -403,8 +381,8 @@ class MyForm(settingsmixin.SMainWindow):
                 toAddress = widget.address
             else:
                 toAddress = None
-            
-            if not toAddress in db:
+
+            if toAddress not in db:
                 treeWidget.takeTopLevelItem(i)
                 # no increment
                 continue
@@ -413,7 +391,8 @@ class MyForm(settingsmixin.SMainWindow):
             while j < widget.childCount():
                 subwidget = widget.child(j)
                 try:
-                    subwidget.setUnreadCount(db[toAddress][subwidget.folderName]['count'])
+                    subwidget.setUnreadCount(
+                        db[toAddress][subwidget.folderName]['count'])
                     unread += db[toAddress][subwidget.folderName]['count']
                     db[toAddress].pop(subwidget.folderName, None)
                 except:
@@ -427,45 +406,51 @@ class MyForm(settingsmixin.SMainWindow):
                 j = 0
                 for f, c in db[toAddress].iteritems():
                     try:
-                        subwidget = Ui_FolderWidget(widget, j, toAddress, f, c['count'])
+                        subwidget = Ui_FolderWidget(
+                            widget, j, toAddress, f, c['count'])
                     except KeyError:
                         subwidget = Ui_FolderWidget(widget, j, toAddress, f, 0)
                     j += 1
             widget.setUnreadCount(unread)
             db.pop(toAddress, None)
             i += 1
-        
+
         i = 0
         for toAddress in db:
-            widget = Ui_SubscriptionWidget(treeWidget, i, toAddress, db[toAddress]["inbox"]['count'], db[toAddress]["inbox"]['label'], db[toAddress]["inbox"]['enabled'])
+            widget = Ui_SubscriptionWidget(
+                treeWidget, i, toAddress, db[toAddress]["inbox"]['count'],
+                db[toAddress]["inbox"]['label'],
+                db[toAddress]["inbox"]['enabled'])
             j = 0
             unread = 0
             for folder in folders:
                 try:
-                    subwidget = Ui_FolderWidget(widget, j, toAddress, folder, db[toAddress][folder]['count'])
+                    subwidget = Ui_FolderWidget(
+                        widget, j, toAddress, folder,
+                        db[toAddress][folder]['count'])
                     unread += db[toAddress][folder]['count']
                 except KeyError:
-                    subwidget = Ui_FolderWidget(widget, j, toAddress, folder, 0)
+                    subwidget = Ui_FolderWidget(
+                        widget, j, toAddress, folder, 0)
                 j += 1
             widget.setUnreadCount(unread)
             i += 1
-        
-        treeWidget.setSortingEnabled(True)
 
+        treeWidget.setSortingEnabled(True)
 
     def rerenderTabTreeMessages(self):
         self.rerenderTabTree('messages')
 
     def rerenderTabTreeChans(self):
         self.rerenderTabTree('chan')
-        
+
     def rerenderTabTree(self, tab):
         if tab == 'messages':
             treeWidget = self.ui.treeWidgetYourIdentities
         elif tab == 'chan':
             treeWidget = self.ui.treeWidgetChans
         folders = Ui_FolderWidget.folderWeight.keys()
-        
+
         # sort ascending when creating
         if treeWidget.topLevelItemCount() == 0:
             treeWidget.header().setSortIndicator(
@@ -473,14 +458,14 @@ class MyForm(settingsmixin.SMainWindow):
         # init dictionary
         db = {}
         enabled = {}
-        
+
         for toAddress in getSortedAccounts():
             isEnabled = BMConfigParser().getboolean(
                 toAddress, 'enabled')
             isChan = BMConfigParser().safeGetBoolean(
                 toAddress, 'chan')
-            isMaillinglist = BMConfigParser().safeGetBoolean(
-                toAddress, 'mailinglist')
+            # isMaillinglist = BMConfigParser().safeGetBoolean(
+            #     toAddress, 'mailinglist')
 
             if treeWidget == self.ui.treeWidgetYourIdentities:
                 if isChan:
@@ -492,7 +477,7 @@ class MyForm(settingsmixin.SMainWindow):
             db[toAddress] = {}
             for folder in folders:
                 db[toAddress][folder] = 0
-                
+
             enabled[toAddress] = isEnabled
 
         # get number of (unread) messages
@@ -510,11 +495,10 @@ class MyForm(settingsmixin.SMainWindow):
             db[None]["sent"] = 0
             db[None]["trash"] = 0
             enabled[None] = True
-        
+
         if treeWidget.isSortingEnabled():
             treeWidget.setSortingEnabled(False)
-        
-        widgets = {}
+
         i = 0
         while i < treeWidget.topLevelItemCount():
             widget = treeWidget.topLevelItem(i)
@@ -522,8 +506,8 @@ class MyForm(settingsmixin.SMainWindow):
                 toAddress = widget.address
             else:
                 toAddress = None
-            
-            if not toAddress in db:
+
+            if toAddress not in db:
                 treeWidget.takeTopLevelItem(i)
                 # no increment
                 continue
@@ -532,8 +516,9 @@ class MyForm(settingsmixin.SMainWindow):
             while j < widget.childCount():
                 subwidget = widget.child(j)
                 try:
-                    subwidget.setUnreadCount(db[toAddress][subwidget.folderName])
-                    if subwidget.folderName not in ["new", "trash", "sent"]:
+                    subwidget.setUnreadCount(
+                        db[toAddress][subwidget.folderName])
+                    if subwidget.folderName not in ("new", "trash", "sent"):
                         unread += db[toAddress][subwidget.folderName]
                     db[toAddress].pop(subwidget.folderName, None)
                 except:
@@ -549,13 +534,13 @@ class MyForm(settingsmixin.SMainWindow):
                     if toAddress is not None and tab == 'messages' and folder == "new":
                         continue
                     subwidget = Ui_FolderWidget(widget, j, toAddress, f, c)
-                    if subwidget.folderName not in ["new", "trash", "sent"]:
+                    if subwidget.folderName not in ("new", "trash", "sent"):
                         unread += c
                     j += 1
             widget.setUnreadCount(unread)
             db.pop(toAddress, None)
             i += 1
-        
+
         i = 0
         for toAddress in db:
             widget = Ui_AddressWidget(treeWidget, i, toAddress, db[toAddress]["inbox"], enabled[toAddress])
@@ -565,16 +550,16 @@ class MyForm(settingsmixin.SMainWindow):
                 if toAddress is not None and tab == 'messages' and folder == "new":
                     continue
                 subwidget = Ui_FolderWidget(widget, j, toAddress, folder, db[toAddress][folder])
-                if subwidget.folderName not in ["new", "trash", "sent"]:
+                if subwidget.folderName not in ("new", "trash", "sent"):
                     unread += db[toAddress][folder]
                 j += 1
             widget.setUnreadCount(unread)
             i += 1
-        
+
         treeWidget.setSortingEnabled(True)
 
     def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
+        super(MyForm, self).__init__(parent)
         self.ui = Ui_MainWindow()
         self.ui.setupUi(self)
 
@@ -585,11 +570,13 @@ class MyForm(settingsmixin.SMainWindow):
                 addressInKeysFile)
             if addressVersionNumber == 1:
                 displayMsg = _translate(
-                    "MainWindow", "One of your addresses, %1, is an old version 1 address. Version 1 addresses are no longer supported. "
-                    + "May we delete it now?").arg(addressInKeysFile)
-                reply = QtGui.QMessageBox.question(
-                    self, 'Message', displayMsg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
-                if reply == QtGui.QMessageBox.Yes:
+                    "MainWindow",
+                    "One of your addresses, {0}, is an old version 1"
+                    " address. Version 1 addresses are no longer supported."
+                    " May we delete it now?").format(addressInKeysFile)
+                reply = QtWidgets.QMessageBox.question(
+                    self, 'Message', displayMsg, QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)
+                if reply == QtWidgets.QMessageBox.Yes:
                     BMConfigParser().remove_section(addressInKeysFile)
                     BMConfigParser().save()
 
@@ -612,13 +599,13 @@ class MyForm(settingsmixin.SMainWindow):
 
         # e.g. for editing labels
         self.recurDepth = 0
-        
+
         # switch back to this when replying
         self.replyFromTab = None
 
         # so that quit won't loop
         self.quitAccepted = False
-        
+
         self.init_file_menu()
         self.init_inbox_popup_menu()
         self.init_identities_popup_menu()
@@ -648,65 +635,58 @@ class MyForm(settingsmixin.SMainWindow):
         self.rerenderSubscriptions()
 
         # Initialize the inbox search
-        QtCore.QObject.connect(self.ui.inboxSearchLineEdit, QtCore.SIGNAL(
-            "returnPressed()"), self.inboxSearchLineEditReturnPressed)
-        QtCore.QObject.connect(self.ui.inboxSearchLineEditSubscriptions, QtCore.SIGNAL(
-            "returnPressed()"), self.inboxSearchLineEditReturnPressed)
-        QtCore.QObject.connect(self.ui.inboxSearchLineEditChans, QtCore.SIGNAL(
-            "returnPressed()"), self.inboxSearchLineEditReturnPressed)
-        QtCore.QObject.connect(self.ui.inboxSearchLineEdit, QtCore.SIGNAL(
-            "textChanged(QString)"), self.inboxSearchLineEditUpdated)
-        QtCore.QObject.connect(self.ui.inboxSearchLineEditSubscriptions, QtCore.SIGNAL(
-            "textChanged(QString)"), self.inboxSearchLineEditUpdated)
-        QtCore.QObject.connect(self.ui.inboxSearchLineEditChans, QtCore.SIGNAL(
-            "textChanged(QString)"), self.inboxSearchLineEditUpdated)
+        for line_edit in (
+            self.ui.inboxSearchLineEdit,
+            self.ui.inboxSearchLineEditSubscriptions,
+            self.ui.inboxSearchLineEditChans,
+        ):
+            line_edit.returnPressed.connect(
+                self.inboxSearchLineEditReturnPressed)
+            line_edit.textChanged.connect(
+                self.inboxSearchLineEditUpdated)
 
         # Initialize addressbook
-        QtCore.QObject.connect(self.ui.tableWidgetAddressBook, QtCore.SIGNAL(
-            "itemChanged(QTableWidgetItem *)"), self.tableWidgetAddressBookItemChanged)
+        self.ui.tableWidgetAddressBook.itemChanged.connect(
+            self.tableWidgetAddressBookItemChanged)
+
         # This is necessary for the completer to work if multiple recipients
-        QtCore.QObject.connect(self.ui.lineEditTo, QtCore.SIGNAL(
-            "cursorPositionChanged(int, int)"), self.ui.lineEditTo.completer().onCursorPositionChanged)
+        self.ui.lineEditTo.cursorPositionChanged.connect(
+            self.ui.lineEditTo.completer().onCursorPositionChanged)
 
         # show messages from message list
-        QtCore.QObject.connect(self.ui.tableWidgetInbox, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.tableWidgetInboxItemClicked)
-        QtCore.QObject.connect(self.ui.tableWidgetInboxSubscriptions, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.tableWidgetInboxItemClicked)
-        QtCore.QObject.connect(self.ui.tableWidgetInboxChans, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.tableWidgetInboxItemClicked)
+        for table_widget in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxSubscriptions,
+            self.ui.tableWidgetInboxChans
+        ):
+            table_widget.itemSelectionChanged.connect(
+                self.tableWidgetInboxItemClicked)
 
         # tree address lists
-        QtCore.QObject.connect(self.ui.treeWidgetYourIdentities, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.treeWidgetItemClicked)
-        QtCore.QObject.connect(self.ui.treeWidgetYourIdentities, QtCore.SIGNAL(
-            "itemChanged (QTreeWidgetItem *, int)"), self.treeWidgetItemChanged)
-        QtCore.QObject.connect(self.ui.treeWidgetSubscriptions, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.treeWidgetItemClicked)
-        QtCore.QObject.connect(self.ui.treeWidgetSubscriptions, QtCore.SIGNAL(
-            "itemChanged (QTreeWidgetItem *, int)"), self.treeWidgetItemChanged)
-        QtCore.QObject.connect(self.ui.treeWidgetChans, QtCore.SIGNAL(
-            "itemSelectionChanged ()"), self.treeWidgetItemClicked)
-        QtCore.QObject.connect(self.ui.treeWidgetChans, QtCore.SIGNAL(
-            "itemChanged (QTreeWidgetItem *, int)"), self.treeWidgetItemChanged)
-        QtCore.QObject.connect(
-            self.ui.tabWidget, QtCore.SIGNAL("currentChanged(int)"),
-            self.tabWidgetCurrentChanged
-        )
+        for tree_widget in (
+            self.ui.treeWidgetYourIdentities,
+            self.ui.treeWidgetSubscriptions,
+            self.ui.treeWidgetChans
+        ):
+            tree_widget.itemSelectionChanged.connect(
+                self.treeWidgetItemClicked)
+            tree_widget.itemChanged.connect(self.treeWidgetItemChanged)
+
+        self.ui.tabWidget.currentChanged.connect(self.tabWidgetCurrentChanged)
 
         # Put the colored icon on the status bar
         # self.pushButtonStatusIcon.setIcon(QIcon(":/newPrefix/images/yellowicon.png"))
         self.setStatusBar(BMStatusBar())
         self.statusbar = self.statusBar()
 
-        self.pushButtonStatusIcon = QtGui.QPushButton(self)
+        self.pushButtonStatusIcon = QtWidgets.QPushButton(self)
         self.pushButtonStatusIcon.setText('')
         self.pushButtonStatusIcon.setIcon(
             QtGui.QIcon(':/newPrefix/images/redicon.png'))
         self.pushButtonStatusIcon.setFlat(True)
         self.statusbar.insertPermanentWidget(0, self.pushButtonStatusIcon)
-        QtCore.QObject.connect(self.pushButtonStatusIcon, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonStatusIcon)
+        self.pushButtonStatusIcon.clicked.connect(
+            self.click_pushButtonStatusIcon)
 
         self.numberOfMessagesProcessed = 0
         self.numberOfBroadcastsProcessed = 0
@@ -715,43 +695,40 @@ class MyForm(settingsmixin.SMainWindow):
 
         # Set the icon sizes for the identicons
         identicon_size = 3*7
-        self.ui.tableWidgetInbox.setIconSize(QtCore.QSize(identicon_size, identicon_size))
-        self.ui.treeWidgetChans.setIconSize(QtCore.QSize(identicon_size, identicon_size))
-        self.ui.treeWidgetYourIdentities.setIconSize(QtCore.QSize(identicon_size, identicon_size))
-        self.ui.treeWidgetSubscriptions.setIconSize(QtCore.QSize(identicon_size, identicon_size))
-        self.ui.tableWidgetAddressBook.setIconSize(QtCore.QSize(identicon_size, identicon_size))
-        
+        for widget in (
+            self.ui.tableWidgetInbox, self.ui.treeWidgetChans,
+            self.ui.treeWidgetYourIdentities, self.ui.treeWidgetSubscriptions,
+            self.ui.tableWidgetAddressBook
+        ):
+            widget.setIconSize(QtCore.QSize(identicon_size, identicon_size))
+
         self.UISignalThread = UISignaler.get()
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "writeNewAddressToTable(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), self.writeNewAddressToTable)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateStatusBar(PyQt_PyObject)"), self.updateStatusBar)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateSentItemStatusByToAddress(PyQt_PyObject,PyQt_PyObject)"), self.updateSentItemStatusByToAddress)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateSentItemStatusByAckdata(PyQt_PyObject,PyQt_PyObject)"), self.updateSentItemStatusByAckdata)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "displayNewInboxMessage(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), self.displayNewInboxMessage)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "displayNewSentMessage(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), self.displayNewSentMessage)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "setStatusIcon(PyQt_PyObject)"), self.setStatusIcon)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "changedInboxUnread(PyQt_PyObject)"), self.changedInboxUnread)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "rerenderMessagelistFromLabels()"), self.rerenderMessagelistFromLabels)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "rerenderMessgelistToLabels()"), self.rerenderMessagelistToLabels)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "rerenderAddressBook()"), self.rerenderAddressBook)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "rerenderSubscriptions()"), self.rerenderSubscriptions)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "removeInboxRowByMsgid(PyQt_PyObject)"), self.removeInboxRowByMsgid)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "newVersionAvailable(PyQt_PyObject)"), self.newVersionAvailable)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "displayAlert(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), self.displayAlert)
+        self.UISignalThread.writeNewAddressToTable.connect(
+            self.writeNewAddressToTable)
+        self.UISignalThread.updateStatusBar.connect(self.updateStatusBar)
+        self.UISignalThread.updateSentItemStatusByToAddress.connect(
+            self.updateSentItemStatusByToAddress)
+        self.UISignalThread.updateSentItemStatusByAckdata.connect(
+            self.updateSentItemStatusByAckdata)
+        self.UISignalThread.displayNewInboxMessage.connect(
+            self.displayNewInboxMessage)
+        self.UISignalThread.displayNewSentMessage.connect(
+            self.displayNewSentMessage)
+        self.UISignalThread.setStatusIcon.connect(self.setStatusIcon)
+        self.UISignalThread.changedInboxUnread.connect(self.changedInboxUnread)
+        self.UISignalThread.rerenderMessagelistFromLabels.connect(
+            self.rerenderMessagelistFromLabels)
+        self.UISignalThread.rerenderMessagelistToLabels.connect(
+            self.rerenderMessagelistToLabels)
+        self.UISignalThread.rerenderAddressBook.connect(
+            self.rerenderAddressBook)
+        self.UISignalThread.rerenderSubscriptions.connect(
+            self.rerenderSubscriptions)
+        self.UISignalThread.removeInboxRowByMsgid.connect(
+            self.removeInboxRowByMsgid)
+        self.UISignalThread.newVersionAvailable.connect(
+            self.newVersionAvailable)
+        self.UISignalThread.displayAlert.connect(self.displayAlert)
         self.UISignalThread.start()
 
         # Key press in tree view
@@ -774,7 +751,7 @@ class MyForm(settingsmixin.SMainWindow):
 
         self.rerenderComboBoxSendFrom()
         self.rerenderComboBoxSendFromBroadcast()
-        
+
         # Put the TTL slider in the correct spot
         TTL = BMConfigParser().getint('bitmessagesettings', 'ttl')
         if TTL < 3600: # an hour
@@ -783,12 +760,10 @@ class MyForm(settingsmixin.SMainWindow):
             TTL = 28*24*60*60
         self.ui.horizontalSliderTTL.setSliderPosition((TTL - 3600) ** (1/3.199))
         self.updateHumanFriendlyTTLDescription(TTL)
-        
-        QtCore.QObject.connect(self.ui.horizontalSliderTTL, QtCore.SIGNAL(
-            "valueChanged(int)"), self.updateTTL)
 
+        self.ui.horizontalSliderTTL.valueChanged.connect(self.updateTTL)
         self.initSettings()
-            
+
         # Check to see whether we can connect to namecoin. Hide the 'Fetch Namecoin ID' button if we can't.
         try:
             options = {}
@@ -801,15 +776,17 @@ class MyForm(settingsmixin.SMainWindow):
             if nc.test()[0] == 'failed':
                 self.ui.pushButtonFetchNamecoinID.hide()
         except:
-            logger.error('There was a problem testing for a Namecoin daemon. Hiding the Fetch Namecoin ID button')
+            logger.error(
+                'There was a problem testing for a Namecoin daemon.'
+                ' Hiding the Fetch Namecoin ID button')
             self.ui.pushButtonFetchNamecoinID.hide()
-            
+
     def updateTTL(self, sliderPosition):
         TTL = int(sliderPosition ** 3.199 + 3600)
         self.updateHumanFriendlyTTLDescription(TTL)
         BMConfigParser().set('bitmessagesettings', 'ttl', str(TTL))
         BMConfigParser().save()
-        
+
     def updateHumanFriendlyTTLDescription(self, TTL):
         numberOfHours = int(round(TTL / (60*60)))
         font = QtGui.QFont()
@@ -817,15 +794,19 @@ class MyForm(settingsmixin.SMainWindow):
 
         if numberOfHours < 48:
             self.ui.labelHumanFriendlyTTLDescription.setText(
-                _translate("MainWindow", "%n hour(s)", None, QtCore.QCoreApplication.CodecForTr, numberOfHours) +
-                ", " +
-                _translate("MainWindow", "not recommended for chans", None, QtCore.QCoreApplication.CodecForTr)
-                )
+                _translate(
+                    "MainWindow", "%n hour(s)", None, numberOfHours)
+                + ", " +
+                _translate("MainWindow", "not recommended for chans")
+            )
             stylesheet = "QLabel { color : red; }"
             font.setBold(True)
         else:
             numberOfDays = int(round(TTL / (24*60*60)))
-            self.ui.labelHumanFriendlyTTLDescription.setText(_translate("MainWindow", "%n day(s)", None, QtCore.QCoreApplication.CodecForTr, numberOfDays))
+            self.ui.labelHumanFriendlyTTLDescription.setText(
+                _translate(
+                    "MainWindow", "%n day(s)", None, numberOfDays)
+            )
             font.setBold(False)
         self.ui.labelHumanFriendlyTTLDescription.setStyleSheet(stylesheet)
         self.ui.labelHumanFriendlyTTLDescription.setFont(font)
@@ -932,8 +913,7 @@ class MyForm(settingsmixin.SMainWindow):
             # related = related.findItems(msgid, QtCore.Qt.MatchExactly),
             # returns an empty list
             for rrow in xrange(related.rowCount()):
-                if msgid == str(related.item(rrow, 3).data(
-                        QtCore.Qt.UserRole).toPyObject()):
+                if msgid == related.item(rrow, 3).data(QtCore.Qt.UserRole):
                     break
             else:
                 rrow = None
@@ -961,7 +941,7 @@ class MyForm(settingsmixin.SMainWindow):
         normalUnread = {}
         for row in queryReturn:
             normalUnread[row[0]] = {}
-            if row[1] in ["trash"]:
+            if row[1] in ("trash"):
                 continue
             normalUnread[row[0]][row[1]] = row[2]
             if row[1] in totalUnread:
@@ -1017,16 +997,19 @@ class MyForm(settingsmixin.SMainWindow):
         if sortingEnabled:
             tableWidget.setSortingEnabled(True)
 
-    def addMessageListItemSent(self, tableWidget, toAddress, fromAddress, subject, status, ackdata, lastactiontime):
+    def addMessageListItemSent(
+        self, tableWidget, toAddress, fromAddress, subject, status,
+        ackdata, lastactiontime
+    ):
         acct = accountClass(fromAddress)
         if acct is None:
             acct = BMAccount(fromAddress)
         acct.parseMessage(toAddress, fromAddress, subject, "")
 
         items = []
-        MessageList_AddressWidget(items, str(toAddress), unicode(acct.toLabel, 'utf-8'))
-        MessageList_AddressWidget(items, str(fromAddress), unicode(acct.fromLabel, 'utf-8'))
-        MessageList_SubjectWidget(items, str(subject), unicode(acct.subject, 'utf-8', 'replace'))
+        MessageList_AddressWidget(items, toAddress, acct.toLabel)
+        MessageList_AddressWidget(items, fromAddress, acct.fromLabel)
+        MessageList_SubjectWidget(items, subject, acct.subject)
 
         if status == 'awaitingpubkey':
             statusText = _translate(
@@ -1038,17 +1021,21 @@ class MyForm(settingsmixin.SMainWindow):
             statusText = _translate(
                 "MainWindow", "Queued.")
         elif status == 'msgsent':
-            statusText = _translate("MainWindow", "Message sent. Waiting for acknowledgement. Sent at %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow",
+                "Message sent. Waiting for acknowledgement. Sent at {0}"
+            ).format(l10n.formatTimestamp(lastactiontime))
         elif status == 'msgsentnoackexpected':
-            statusText = _translate("MainWindow", "Message sent. Sent at %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow", "Message sent. Sent at {0}"
+            ).format(l10n.formatTimestamp(lastactiontime))
         elif status == 'doingmsgpow':
             statusText = _translate(
                 "MainWindow", "Doing work necessary to send message.")
         elif status == 'ackreceived':
-            statusText = _translate("MainWindow", "Acknowledgement of the message received %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow", "Acknowledgement of the message received {0}"
+            ).format(l10n.formatTimestamp(lastactiontime))
         elif status == 'broadcastqueued':
             statusText = _translate(
                 "MainWindow", "Broadcast queued.")
@@ -1056,23 +1043,31 @@ class MyForm(settingsmixin.SMainWindow):
             statusText = _translate(
                 "MainWindow", "Doing work necessary to send broadcast.")
         elif status == 'broadcastsent':
-            statusText = _translate("MainWindow", "Broadcast on %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate("MainWindow", "Broadcast on {0}").format(
+                l10n.formatTimestamp(lastactiontime)
+            )
         elif status == 'toodifficult':
-            statusText = _translate("MainWindow", "Problem: The work demanded by the recipient is more difficult than you are willing to do. %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow",
+                "Problem: The work demanded by the recipient is more"
+                " difficult than you are willing to do. {0}"
+            ).format(l10n.formatTimestamp(lastactiontime))
         elif status == 'badkey':
-            statusText = _translate("MainWindow", "Problem: The recipient\'s encryption key is no good. Could not encrypt message. %1").arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow",
+                "Problem: The recipient\'s encryption key is no good."
+                " Could not encrypt message. {0}"
+            ).format(l10n.formatTimestamp(lastactiontime))
         elif status == 'forcepow':
             statusText = _translate(
                 "MainWindow", "Forced difficulty override. Send should start soon.")
         else:
-            statusText = _translate("MainWindow", "Unknown status: %1 %2").arg(status).arg(
-                l10n.formatTimestamp(lastactiontime))
+            statusText = _translate(
+                "MainWindow", "Unknown status: {0} {1}"
+            ).format(status, l10n.formatTimestamp(lastactiontime))
         newItem = myTableWidgetItem(statusText)
         newItem.setToolTip(statusText)
-        newItem.setData(QtCore.Qt.UserRole, QtCore.QByteArray(ackdata))
+        newItem.setData(QtCore.Qt.UserRole, ackdata)
         newItem.setData(33, int(lastactiontime))
         newItem.setFlags(
             QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
@@ -1080,9 +1075,10 @@ class MyForm(settingsmixin.SMainWindow):
         self.addMessageListItem(tableWidget, items)
         return acct
 
-    def addMessageListItemInbox(self, tableWidget, msgfolder, msgid, toAddress, fromAddress, subject, received, read):
-        font = QtGui.QFont()
-        font.setBold(True)
+    def addMessageListItemInbox(
+            self, tableWidget, msgfolder, msgid, toAddress, fromAddress,
+            subject, received, read
+    ):
         if toAddress == str_broadcast_subscribers:
             acct = accountClass(fromAddress)
         else:
@@ -1092,22 +1088,24 @@ class MyForm(settingsmixin.SMainWindow):
         if acct is None:
             acct = BMAccount(fromAddress)
         acct.parseMessage(toAddress, fromAddress, subject, "")
-            
+
         items = []
-        #to
-        MessageList_AddressWidget(items, toAddress, unicode(acct.toLabel, 'utf-8'), not read)
+        # to
+        MessageList_AddressWidget(items, toAddress, acct.toLabel, not read)
         # from
-        MessageList_AddressWidget(items, fromAddress, unicode(acct.fromLabel, 'utf-8'), not read)
+        MessageList_AddressWidget(items, fromAddress, acct.fromLabel, not read)
         # subject
-        MessageList_SubjectWidget(items, str(subject), unicode(acct.subject, 'utf-8', 'replace'), not read)
+        MessageList_SubjectWidget(items, subject, acct.subject, not read)
         # time received
         time_item = myTableWidgetItem(l10n.formatTimestamp(received))
         time_item.setToolTip(l10n.formatTimestamp(received))
-        time_item.setData(QtCore.Qt.UserRole, QtCore.QByteArray(msgid))
+        time_item.setData(QtCore.Qt.UserRole, msgid)
         time_item.setData(33, int(received))
         time_item.setFlags(
             QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
         if not read:
+            font = QtGui.QFont()
+            font.setBold(True)
             time_item.setFont(font)
         items.append(time_item)
         self.addMessageListItem(tableWidget, items)
@@ -1134,20 +1132,28 @@ class MyForm(settingsmixin.SMainWindow):
         tableWidget.setUpdatesEnabled(False)
         tableWidget.setSortingEnabled(False)
         tableWidget.setRowCount(0)
-        queryreturn = helper_search.search_sql(xAddress, account, "sent", where, what, False)
+        queryreturn = helper_search.search_sql(
+            xAddress, account, "sent", where, what, False)
 
         for row in queryreturn:
             toAddress, fromAddress, subject, status, ackdata, lastactiontime = row
-            self.addMessageListItemSent(tableWidget, toAddress, fromAddress, subject, status, ackdata, lastactiontime)
+            self.addMessageListItemSent(
+                tableWidget, toAddress, fromAddress,
+                unicode(subject, 'utf-8'), status,
+                ackdata, lastactiontime
+            )
 
         tableWidget.horizontalHeader().setSortIndicator(
             3, QtCore.Qt.DescendingOrder)
         tableWidget.setSortingEnabled(True)
-        tableWidget.horizontalHeaderItem(3).setText(_translate("MainWindow", "Sent", None))
+        tableWidget.horizontalHeaderItem(3).setText(
+            _translate("MainWindow", "Sent"))
         tableWidget.setUpdatesEnabled(True)
 
     # Load messages from database file
-    def loadMessagelist(self, tableWidget, account, folder="inbox", where="", what="", unreadOnly = False):
+    def loadMessagelist(
+            self, tableWidget, account,
+            folder="inbox", where="", what="", unreadOnly=False):
         if folder == 'sent':
             self.loadSent(tableWidget, account, where, what)
             return
@@ -1167,39 +1173,42 @@ class MyForm(settingsmixin.SMainWindow):
         tableWidget.setSortingEnabled(False)
         tableWidget.setRowCount(0)
 
-        queryreturn = helper_search.search_sql(xAddress, account, folder, where, what, unreadOnly)
-        
+        queryreturn = helper_search.search_sql(
+            xAddress, account, folder, where, what, unreadOnly)
+
         for row in queryreturn:
             msgfolder, msgid, toAddress, fromAddress, subject, received, read = row
-            self.addMessageListItemInbox(tableWidget, msgfolder, msgid, toAddress, fromAddress, subject, received, read)
+            self.addMessageListItemInbox(
+                tableWidget, msgfolder, msgid, toAddress, fromAddress,
+                unicode(subject, 'utf-8'), received, read
+            )
 
         tableWidget.horizontalHeader().setSortIndicator(
             3, QtCore.Qt.DescendingOrder)
         tableWidget.setSortingEnabled(True)
         tableWidget.selectRow(0)
-        tableWidget.horizontalHeaderItem(3).setText(_translate("MainWindow", "Received", None))
+        tableWidget.horizontalHeaderItem(3).setText(
+            _translate("MainWindow", "Received"))
         tableWidget.setUpdatesEnabled(True)
 
     # create application indicator
     def appIndicatorInit(self, app):
         self.initTrayIcon("can-icon-24px-red.png", app)
-        traySignal = "activated(QSystemTrayIcon::ActivationReason)"
-        QtCore.QObject.connect(self.tray, QtCore.SIGNAL(
-            traySignal), self.__icon_activated)
+        self.tray.activated.connect(self.__icon_activated)
 
-        m = QtGui.QMenu()
+        m = QtWidgets.QMenu()
 
-        self.actionStatus = QtGui.QAction(_translate(
+        self.actionStatus = QtWidgets.QAction(_translate(
             "MainWindow", "Not Connected"), m, checkable=False)
         m.addAction(self.actionStatus)
 
         # separator
-        actionSeparator = QtGui.QAction('', m, checkable=False)
+        actionSeparator = QtWidgets.QAction('', m, checkable=False)
         actionSeparator.setSeparator(True)
         m.addAction(actionSeparator)
 
         # show bitmessage
-        self.actionShow = QtGui.QAction(_translate(
+        self.actionShow = QtWidgets.QAction(_translate(
             "MainWindow", "Show Bitmessage"), m, checkable=True)
         self.actionShow.setChecked(not BMConfigParser().getboolean(
             'bitmessagesettings', 'startintray'))
@@ -1208,7 +1217,7 @@ class MyForm(settingsmixin.SMainWindow):
             m.addAction(self.actionShow)
 
         # quiet mode
-        self.actionQuiet = QtGui.QAction(_translate(
+        self.actionQuiet = QtWidgets.QAction(_translate(
             "MainWindow", "Quiet Mode"), m, checkable=True)
         self.actionQuiet.setChecked(not BMConfigParser().getboolean(
             'bitmessagesettings', 'showtraynotifications'))
@@ -1216,25 +1225,25 @@ class MyForm(settingsmixin.SMainWindow):
         m.addAction(self.actionQuiet)
 
         # Send
-        actionSend = QtGui.QAction(_translate(
+        actionSend = QtWidgets.QAction(_translate(
             "MainWindow", "Send"), m, checkable=False)
         actionSend.triggered.connect(self.appIndicatorSend)
         m.addAction(actionSend)
 
         # Subscribe
-        actionSubscribe = QtGui.QAction(_translate(
+        actionSubscribe = QtWidgets.QAction(_translate(
             "MainWindow", "Subscribe"), m, checkable=False)
         actionSubscribe.triggered.connect(self.appIndicatorSubscribe)
         m.addAction(actionSubscribe)
 
         # Channels
-        actionSubscribe = QtGui.QAction(_translate(
+        actionSubscribe = QtWidgets.QAction(_translate(
             "MainWindow", "Channel"), m, checkable=False)
         actionSubscribe.triggered.connect(self.appIndicatorChannel)
         m.addAction(actionSubscribe)
 
         # separator
-        actionSeparator = QtGui.QAction('', m, checkable=False)
+        actionSeparator = QtWidgets.QAction('', m, checkable=False)
         actionSeparator.setSeparator(True)
         m.addAction(actionSeparator)
 
@@ -1352,8 +1361,6 @@ class MyForm(settingsmixin.SMainWindow):
             self.tray.showMessage(title, subtitle, 1, 2000)
 
         self._notifier = _simple_notify
-        # does nothing if isAvailable returns false
-        self._player = QtGui.QSound.play
 
         if not get_plugins:
             return
@@ -1366,7 +1373,10 @@ class MyForm(settingsmixin.SMainWindow):
 
         self._theme_player = get_plugin('notification.sound', 'theme')
 
-        if not QtGui.QSound.isAvailable():
+        try:
+            from qtpy import QtMultimedia
+            self._player = QtMultimedia.QSound.play
+        except ImportError:
             _plugin = get_plugin(
                 'notification.sound', 'file', fallback='file.fallback')
             if _plugin:
@@ -1392,17 +1402,17 @@ class MyForm(settingsmixin.SMainWindow):
     def textEditKeyPressEvent(self, event):
         return self.handleKeyPress(event, self.getCurrentMessageTextedit())
 
-    def handleKeyPress(self, event, focus = None):
+    def handleKeyPress(self, event, focus=None):
         messagelist = self.getCurrentMessagelist()
         folder = self.getCurrentFolder()
         if event.key() == QtCore.Qt.Key_Delete:
-            if isinstance (focus, MessageView) or isinstance(focus, QtGui.QTableWidget):
+            if isinstance(focus, MessageView) or isinstance(focus, QtWidgets.QTableWidget):
                 if folder == "sent":
                     self.on_action_SentTrash()
                 else:
                     self.on_action_InboxTrash()
             event.ignore()
-        elif QtGui.QApplication.queryKeyboardModifiers() == QtCore.Qt.NoModifier:
+        elif QtWidgets.QApplication.queryKeyboardModifiers() == QtCore.Qt.NoModifier:
             if event.key() == QtCore.Qt.Key_N:
                 currentRow = messagelist.currentRow()
                 if currentRow < messagelist.rowCount() - 1:
@@ -1432,46 +1442,79 @@ class MyForm(settingsmixin.SMainWindow):
                 self.ui.lineEditTo.setFocus()
                 event.ignore()
             elif event.key() == QtCore.Qt.Key_F:
-                searchline = self.getCurrentSearchLine(retObj = True)
+                searchline = self.getCurrentSearchLine(retObj=True)
                 if searchline:
                     searchline.setFocus()
                 event.ignore()
         if not event.isAccepted():
             return
-        if isinstance (focus, MessageView):
+        if isinstance(focus, MessageView):
             return MessageView.keyPressEvent(focus, event)
-        elif isinstance (focus, QtGui.QTableWidget):
-            return QtGui.QTableWidget.keyPressEvent(focus, event)
-        elif isinstance (focus, QtGui.QTreeWidget):
-            return QtGui.QTreeWidget.keyPressEvent(focus, event)
+        elif isinstance(focus, QtWidgets.QTableWidget):
+            return QtWidgets.QTableWidget.keyPressEvent(focus, event)
+        elif isinstance(focus, QtWidgets.QTreeWidget):
+            return QtWidgets.QTreeWidget.keyPressEvent(focus, event)
 
     # menu button 'manage keys'
     def click_actionManageKeys(self):
         if 'darwin' in sys.platform or 'linux' in sys.platform:
             if state.appdata == '':
-                # reply = QtGui.QMessageBox.information(self, 'keys.dat?','You
+                # reply = QtWidgets.QMessageBox.information(self, 'keys.dat?','You
                 # may manage your keys by editing the keys.dat file stored in
                 # the same directory as this program. It is important that you
                 # back up this file.', QMessageBox.Ok)
-                reply = QtGui.QMessageBox.information(self, 'keys.dat?', _translate(
-                    "MainWindow", "You may manage your keys by editing the keys.dat file stored in the same directory as this program. It is important that you back up this file."), QtGui.QMessageBox.Ok)
+                reply = QtWidgets.QMessageBox.information(
+                    self, 'keys.dat?', _translate(
+                        "MainWindow",
+                        "You may manage your keys by editing the keys.dat"
+                        " file stored in the same directory as this"
+                        " program. It is important that you back up this"
+                        " file."), QtWidgets.QMessageBox.Ok)
 
             else:
-                QtGui.QMessageBox.information(self, 'keys.dat?', _translate(
-                    "MainWindow", "You may manage your keys by editing the keys.dat file stored in\n %1 \nIt is important that you back up this file.").arg(state.appdata), QtGui.QMessageBox.Ok)
+                QtWidgets.QMessageBox.information(
+                    self, 'keys.dat?',
+                    _translate(
+                        "MainWindow",
+                        "You may manage your keys by editing the keys.dat"
+                        " file stored in\n {0} \nIt is important that you"
+                        " back up this file."
+                    ).format(state.appdata),
+                    QtWidgets.QMessageBox.Ok
+                )
         elif sys.platform == 'win32' or sys.platform == 'win64':
             if state.appdata == '':
-                reply = QtGui.QMessageBox.question(self, _translate("MainWindow", "Open keys.dat?"), _translate(
-                    "MainWindow", "You may manage your keys by editing the keys.dat file stored in the same directory as this program. It is important that you back up this file. Would you like to open the file now? (Be sure to close Bitmessage before making any changes.)"), QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
+                reply = QtWidgets.QMessageBox.question(
+                    self, _translate("MainWindow", "Open keys.dat?"),
+                    _translate(
+                        "MainWindow",
+                        "You may manage your keys by editing the keys.dat"
+                        " file stored in the same directory as this"
+                        " program. It is important that you back up this"
+                        " file. Would you like to open the file now?"
+                        " (Be sure to close Bitmessage before making any"
+                        " changes.)"
+                    ), QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)
             else:
-                reply = QtGui.QMessageBox.question(self, _translate("MainWindow", "Open keys.dat?"), _translate(
-                    "MainWindow", "You may manage your keys by editing the keys.dat file stored in\n %1 \nIt is important that you back up this file. Would you like to open the file now? (Be sure to close Bitmessage before making any changes.)").arg(state.appdata), QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
-            if reply == QtGui.QMessageBox.Yes:
+                reply = QtWidgets.QMessageBox.question(
+                    self,
+                    _translate("MainWindow", "Open keys.dat?"),
+                    _translate(
+                        "MainWindow",
+                        "You may manage your keys by editing the keys.dat"
+                        " file stored in\n {0} \nIt is important that you"
+                        " back up this file. Would you like to open the"
+                        " file now? (Be sure to close Bitmessage before"
+                        " making any changes.)"
+                    ).format(state.appdata),
+                    QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No
+                )
+            if reply == QtWidgets.QMessageBox.Yes:
                 shared.openKeysFile()
 
     # menu button 'delete all treshed messages'
     def click_actionDeleteAllTrashedMessages(self):
-        if QtGui.QMessageBox.question(self, _translate("MainWindow", "Delete trash?"), _translate("MainWindow", "Are you sure you want to delete all trashed messages?"), QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) == QtGui.QMessageBox.No:
+        if QtWidgets.QMessageBox.question(self, _translate("MainWindow", "Delete trash?"), _translate("MainWindow", "Are you sure you want to delete all trashed messages?"), QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No) == QtWidgets.QMessageBox.No:
             return
         sqlStoredProcedure('deleteandvacuume')
         self.rerenderTabTreeMessages()
@@ -1489,7 +1532,7 @@ class MyForm(settingsmixin.SMainWindow):
         dialog = dialogs.RegenerateAddressesDialog(self)
         if dialog.exec_():
             if dialog.lineEditPassphrase.text() == "":
-                QtGui.QMessageBox.about(
+                QtWidgets.QMessageBox.about(
                     self, _translate("MainWindow", "bad passphrase"),
                     _translate(
                         "MainWindow",
@@ -1502,7 +1545,7 @@ class MyForm(settingsmixin.SMainWindow):
                 addressVersionNumber = int(
                     dialog.lineEditAddressVersionNumber.text())
             except:
-                QtGui.QMessageBox.about(
+                QtWidgets.QMessageBox.about(
                     self,
                     _translate("MainWindow", "Bad address version number"),
                     _translate(
@@ -1512,7 +1555,7 @@ class MyForm(settingsmixin.SMainWindow):
                     ))
                 return
             if addressVersionNumber < 3 or addressVersionNumber > 4:
-                QtGui.QMessageBox.about(
+                QtWidgets.QMessageBox.about(
                     self,
                     _translate("MainWindow", "Bad address version number"),
                     _translate(
@@ -1525,7 +1568,7 @@ class MyForm(settingsmixin.SMainWindow):
                 addressVersionNumber, streamNumberForAddress,
                 "regenerated deterministic address",
                 dialog.spinBoxNumberOfAddressesToMake.value(),
-                dialog.lineEditPassphrase.text().toUtf8(),
+                dialog.lineEditPassphrase.text(),
                 dialog.checkBoxEighteenByteRipe.isChecked()
             ))
             self.ui.tabWidget.setCurrentIndex(
@@ -1571,7 +1614,7 @@ class MyForm(settingsmixin.SMainWindow):
                 # The window state has just been changed to
                 # Normal/Maximised/FullScreen
                 pass
-        # QtGui.QWidget.changeEvent(self, event)
+        # QtWidgets.QWidget.changeEvent(self, event)
 
     def __icon_activated(self, reason):
         if reason == QtGui.QSystemTrayIcon.Trigger:
@@ -1647,7 +1690,7 @@ class MyForm(settingsmixin.SMainWindow):
 
     def initTrayIcon(self, iconFileName, app):
         self.currentTrayIconFileName = iconFileName
-        self.tray = QtGui.QSystemTrayIcon(
+        self.tray = QtWidgets.QSystemTrayIcon(
             self.calcTrayIcon(iconFileName, self.findInboxUnreadCount()), app)
 
     def setTrayIconFile(self, iconFileName):
@@ -1655,7 +1698,7 @@ class MyForm(settingsmixin.SMainWindow):
         self.drawTrayIcon(iconFileName, self.findInboxUnreadCount())
 
     def calcTrayIcon(self, iconFileName, inboxUnreadCount):
-        pixmap = QtGui.QPixmap(":/newPrefix/images/"+iconFileName)
+        pixmap = QtGui.QPixmap(":/newPrefix/images/" + iconFileName)
         if inboxUnreadCount > 0:
             # choose font and calculate font parameters
             fontName = "Lucida"
@@ -1667,7 +1710,8 @@ class MyForm(settingsmixin.SMainWindow):
             rect = fontMetrics.boundingRect(txt)
             # margins that we add in the top-right corner
             marginX = 2
-            marginY = 0 # it looks like -2 is also ok due to the error of metric
+            # it looks like -2 is also ok due to the error of metric
+            marginY = 0
             # if it renders too wide we need to change it to a plus symbol
             if rect.width() > 20:
                 txt = "+"
@@ -1678,8 +1722,7 @@ class MyForm(settingsmixin.SMainWindow):
             # draw text
             painter = QtGui.QPainter()
             painter.begin(pixmap)
-            painter.setPen(
-                QtGui.QPen(QtGui.QColor(255, 0, 0), QtCore.Qt.SolidPattern))
+            painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0)))
             painter.setFont(font)
             painter.drawText(24-rect.right()-marginX, -rect.top()+marginY, txt)
             painter.end()
@@ -1707,11 +1750,18 @@ class MyForm(settingsmixin.SMainWindow):
         return self.unreadCount
 
     def updateSentItemStatusByToAddress(self, toAddress, textToDisplay):
-        for sent in [self.ui.tableWidgetInbox, self.ui.tableWidgetInboxSubscriptions, self.ui.tableWidgetInboxChans]:
+        for sent in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxSubscriptions,
+            self.ui.tableWidgetInboxChans
+        ):
             treeWidget = self.widgetConvert(sent)
             if self.getCurrentFolder(treeWidget) != "sent":
                 continue
-            if treeWidget in [self.ui.treeWidgetSubscriptions, self.ui.treeWidgetChans] and self.getCurrentAccount(treeWidget) != toAddress:
+            if treeWidget in (
+                self.ui.treeWidgetSubscriptions,
+                self.ui.treeWidgetChans
+            ) and self.getCurrentAccount(treeWidget) != toAddress:
                 continue
 
             for i in range(sent.rowCount()):
@@ -1719,8 +1769,11 @@ class MyForm(settingsmixin.SMainWindow):
                 if toAddress == rowAddress:
                     sent.item(i, 3).setToolTip(textToDisplay)
                     try:
-                        newlinePosition = textToDisplay.indexOf('\n')
-                    except: # If someone misses adding a "_translate" to a string before passing it to this function, this function won't receive a qstring which will cause an exception.
+                        newlinePosition = textToDisplay.find('\n')
+                    # If someone misses adding a "_translate" to a string
+                    # before passing it to this function
+                    # ? why textToDisplay isn't unicode
+                    except AttributeError:
                         newlinePosition = 0
                     if newlinePosition > 1:
                         sent.item(i, 3).setText(
@@ -1729,7 +1782,11 @@ class MyForm(settingsmixin.SMainWindow):
                         sent.item(i, 3).setText(textToDisplay)
 
     def updateSentItemStatusByAckdata(self, ackdata, textToDisplay):
-        for sent in [self.ui.tableWidgetInbox, self.ui.tableWidgetInboxSubscriptions, self.ui.tableWidgetInboxChans]:
+        for sent in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxSubscriptions,
+            self.ui.tableWidgetInboxChans
+        ):
             treeWidget = self.widgetConvert(sent)
             if self.getCurrentFolder(treeWidget) != "sent":
                 continue
@@ -1737,14 +1794,18 @@ class MyForm(settingsmixin.SMainWindow):
                 toAddress = sent.item(
                     i, 0).data(QtCore.Qt.UserRole)
                 tableAckdata = sent.item(
-                    i, 3).data(QtCore.Qt.UserRole).toPyObject()
+                    i, 3).data(QtCore.Qt.UserRole)
                 status, addressVersionNumber, streamNumber, ripe = decodeAddress(
                     toAddress)
+
                 if ackdata == tableAckdata:
                     sent.item(i, 3).setToolTip(textToDisplay)
                     try:
-                        newlinePosition = textToDisplay.indexOf('\n')
-                    except: # If someone misses adding a "_translate" to a string before passing it to this function, this function won't receive a qstring which will cause an exception.
+                        newlinePosition = textToDisplay.find('\n')
+                    # If someone misses adding a "_translate" to a string
+                    # before passing it to this function
+                    # ? why textToDisplay isn't unicode
+                    except AttributeError:
                         newlinePosition = 0
                     if newlinePosition > 1:
                         sent.item(i, 3).setText(
@@ -1752,17 +1813,19 @@ class MyForm(settingsmixin.SMainWindow):
                     else:
                         sent.item(i, 3).setText(textToDisplay)
 
-    def removeInboxRowByMsgid(self, msgid):  # msgid and inventoryHash are the same thing
-        for inbox in ([
+    # msgid and inventoryHash are the same thing
+    def removeInboxRowByMsgid(self, msgid):
+        for inbox in (
             self.ui.tableWidgetInbox,
             self.ui.tableWidgetInboxSubscriptions,
-            self.ui.tableWidgetInboxChans]):
+            self.ui.tableWidgetInboxChans
+        ):
             for i in range(inbox.rowCount()):
-                if msgid == str(inbox.item(i, 3).data(QtCore.Qt.UserRole).toPyObject()):
+                if msgid == str(inbox.item(i, 3).data(QtCore.Qt.UserRole)):
                     self.updateStatusBar(
                         _translate("MainWindow", "Message trashed"))
-                    treeWidget = self.widgetConvert(inbox)
-                    self.propagateUnreadCount(inbox.item(i, 1 if inbox.item(i, 1).type == AccountMixin.SUBSCRIPTION else 0).data(QtCore.Qt.UserRole), self.getCurrentFolder(treeWidget), treeWidget, 0)
+                    # treeWidget = self.widgetConvert(inbox)
+                    self.propagateUnreadCount()
                     inbox.removeRow(i)
                     break
 
@@ -1770,33 +1833,42 @@ class MyForm(settingsmixin.SMainWindow):
         self.notifiedNewVersion = ".".join(str(n) for n in version)
         self.updateStatusBar(_translate(
             "MainWindow",
-            "New version of PyBitmessage is available: %1. Download it"
+            "New version of PyBitmessage is available: {0}. Download it"
             " from https://github.com/Bitmessage/PyBitmessage/releases/latest"
-            ).arg(self.notifiedNewVersion)
+            ).format(self.notifiedNewVersion)
         )
 
     def displayAlert(self, title, text, exitAfterUserClicksOk):
         self.updateStatusBar(text)
-        QtGui.QMessageBox.critical(self, title, text, QtGui.QMessageBox.Ok)
+        QtWidgets.QMessageBox.critical(
+            self, title, text, QtWidgets.QMessageBox.Ok)
         if exitAfterUserClicksOk:
             os._exit(0)
 
     def rerenderMessagelistFromLabels(self):
-        for messagelist in (self.ui.tableWidgetInbox, self.ui.tableWidgetInboxChans, self.ui.tableWidgetInboxSubscriptions):
+        for messagelist in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxChans,
+            self.ui.tableWidgetInboxSubscriptions
+        ):
             for i in range(messagelist.rowCount()):
                 messagelist.item(i, 1).setLabel()
 
     def rerenderMessagelistToLabels(self):
-        for messagelist in (self.ui.tableWidgetInbox, self.ui.tableWidgetInboxChans, self.ui.tableWidgetInboxSubscriptions):
+        for messagelist in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxChans,
+            self.ui.tableWidgetInboxSubscriptions
+        ):
             for i in range(messagelist.rowCount()):
                 messagelist.item(i, 0).setLabel()
 
     def rerenderAddressBook(self):
-        def addRow (address, label, type):
+        def addRow(address, label, type):
             self.ui.tableWidgetAddressBook.insertRow(0)
-            newItem = Ui_AddressBookWidgetItemLabel(address, unicode(label, 'utf-8'), type)
+            newItem = Ui_AddressBookWidgetItemLabel(address, label, type)
             self.ui.tableWidgetAddressBook.setItem(0, 0, newItem)
-            newItem = Ui_AddressBookWidgetItemAddress(address, unicode(label, 'utf-8'), type)
+            newItem = Ui_AddressBookWidgetItemAddress(address, label, type)
             self.ui.tableWidgetAddressBook.setItem(0, 1, newItem)
 
         oldRows = {}
@@ -1814,29 +1886,34 @@ class MyForm(settingsmixin.SMainWindow):
         queryreturn = sqlQuery('SELECT label, address FROM subscriptions WHERE enabled = 1')
         for row in queryreturn:
             label, address = row
-            newRows[address] = [label, AccountMixin.SUBSCRIPTION]
+            newRows[address] = [unicode(label, 'utf-8'), AccountMixin.SUBSCRIPTION]
         # chans
         addresses = getSortedAccounts()
         for address in addresses:
             account = accountClass(address)
-            if (account.type == AccountMixin.CHAN and BMConfigParser().safeGetBoolean(address, 'enabled')):
+            if (
+                account.type == AccountMixin.CHAN
+                and BMConfigParser().safeGetBoolean(address, 'enabled')
+            ):
                 newRows[address] = [account.getLabel(), AccountMixin.CHAN]
         # normal accounts
         queryreturn = sqlQuery('SELECT * FROM addressbook')
         for row in queryreturn:
             label, address = row
-            newRows[address] = [label, AccountMixin.NORMAL]
+            newRows[address] = [unicode(label, 'utf-8'), AccountMixin.NORMAL]
 
         completerList = []
-        for address in sorted(oldRows, key = lambda x: oldRows[x][2], reverse = True):
+        for address in sorted(
+            oldRows, key=lambda x: oldRows[x][2], reverse=True
+        ):
             if address in newRows:
-                completerList.append(unicode(newRows[address][0], encoding="UTF-8") + " <" + address + ">")
-                newRows.pop(address)
+                completerList.append(
+                    newRows.pop(address)[0] + " <" + address + ">")
             else:
                 self.ui.tableWidgetAddressBook.removeRow(oldRows[address][2])
         for address in newRows:
             addRow(address, newRows[address][0], newRows[address][1])
-            completerList.append(unicode(newRows[address][0], encoding="UTF-8") + " <" + address + ">")
+            completerList.append(newRows[address][0] + " <" + address + ">")
 
         # sort
         self.ui.tableWidgetAddressBook.sortByColumn(
@@ -1848,11 +1925,11 @@ class MyForm(settingsmixin.SMainWindow):
         self.rerenderTabTreeSubscriptions()
 
     def click_pushButtonTTL(self):
-        QtGui.QMessageBox.information(self, 'Time To Live', _translate(
+        QtWidgets.QMessageBox.information(self, 'Time To Live', _translate(
             "MainWindow", """The TTL, or Time-To-Live is the length of time that the network will hold the message.
  The recipient must get it during this time. If your Bitmessage client does not hear an acknowledgement, it
  will resend the message automatically. The longer the Time-To-Live, the
- more work your computer must do to send the message. A Time-To-Live of four or five days is often appropriate."""), QtGui.QMessageBox.Ok)
+ more work your computer must do to send the message. A Time-To-Live of four or five days is often appropriate."""), QtWidgets.QMessageBox.Ok)
 
     def click_pushButtonClear(self):
         self.ui.lineEditSubject.setText("")
@@ -1861,7 +1938,7 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.comboBoxSendFrom.setCurrentIndex(0)
 
     def click_pushButtonSend(self):
-        encoding = 3 if QtGui.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier else 2
+        encoding = 3 if QtWidgets.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier else 2
 
         self.statusbar.clearMessage()
 
@@ -1871,20 +1948,19 @@ class MyForm(settingsmixin.SMainWindow):
             sendMessageToPeople = True
             fromAddress = str(self.ui.comboBoxSendFrom.itemData(
                 self.ui.comboBoxSendFrom.currentIndex(),
-                QtCore.Qt.UserRole).toString())
-            toAddresses = str(self.ui.lineEditTo.text().toUtf8())
-            subject = str(self.ui.lineEditSubject.text().toUtf8())
-            message = str(
-                self.ui.textEditMessage.document().toPlainText().toUtf8())
+                QtCore.Qt.UserRole))
+            toAddresses = str(self.ui.lineEditTo.text())
+            subject = self.ui.lineEditSubject.text()
+            message = self.ui.textEditMessage.document().toPlainText()
         else:
             # broadcast message
             sendMessageToPeople = False
             fromAddress = str(self.ui.comboBoxSendFromBroadcast.itemData(
                 self.ui.comboBoxSendFromBroadcast.currentIndex(),
-                QtCore.Qt.UserRole).toString())
-            subject = str(self.ui.lineEditSubjectBroadcast.text().toUtf8())
-            message = str(
-                self.ui.textEditMessageBroadcast.document().toPlainText().toUtf8())
+                QtCore.Qt.UserRole))
+            subject = self.ui.lineEditSubjectBroadcast.text()
+            message = \
+                self.ui.textEditMessageBroadcast.document().toPlainText()
         """
         The whole network message must fit in 2^18 bytes.
         Let's assume 500 bytes of overhead. If someone wants to get that
@@ -1893,23 +1969,26 @@ class MyForm(settingsmixin.SMainWindow):
         users can send messages of any length.
         """
         if len(message) > (2 ** 18 - 500):
-            QtGui.QMessageBox.about(
+            QtWidgets.QMessageBox.about(
                 self, _translate("MainWindow", "Message too long"),
                 _translate(
                     "MainWindow",
                     "The message that you are trying to send is too long"
-                    " by %1 bytes. (The maximum is 261644 bytes). Please"
+                    " by {0} bytes. (The maximum is 261644 bytes). Please"
                     " cut it down before sending."
-                ).arg(len(message) - (2 ** 18 - 500)))
+                ).format(len(message) - (2 ** 18 - 500)))
             return
 
         acct = accountClass(fromAddress)
 
-        if sendMessageToPeople: # To send a message to specific people (rather than broadcast)
-            toAddressesList = [s.strip()
-                               for s in toAddresses.replace(',', ';').split(';')]
-            toAddressesList = list(set(
-                toAddressesList))  # remove duplicate addresses. If the user has one address with a BM- and the same address without the BM-, this will not catch it. They'll send the message to the person twice.
+        # To send a message to specific people (rather than broadcast)
+        if sendMessageToPeople:
+            toAddressesList = set([
+                s.strip() for s in toAddresses.replace(',', ';').split(';')
+            ])
+            # remove duplicate addresses. If the user has one address
+            # with a BM- and the same address without the BM-, this will
+            # not catch it. They'll send the message to the person twice.
             for toAddress in toAddressesList:
                 if toAddress != '':
                     # label plus address
@@ -1918,18 +1997,32 @@ class MyForm(settingsmixin.SMainWindow):
                     # email address
                     if toAddress.find("@") >= 0:
                         if isinstance(acct, GatewayAccount):
-                            acct.createMessage(toAddress, fromAddress, subject, message)
+                            acct.createMessage(
+                                toAddress, fromAddress, subject, message)
                             subject = acct.subject
                             toAddress = acct.toAddress
                         else:
-                            if QtGui.QMessageBox.question(self, "Sending an email?", _translate("MainWindow", 
-                                "You are trying to send an email instead of a bitmessage. This requires registering with a gateway. Attempt to register?"),
-                                QtGui.QMessageBox.Yes|QtGui.QMessageBox.No) != QtGui.QMessageBox.Yes:
+                            if QtWidgets.QMessageBox.question(
+                                    self, "Sending an email?",
+                                    _translate(
+                                        "MainWindow",
+                                        "You are trying to send an email"
+                                        " instead of a bitmessage. This"
+                                        " requires registering with a"
+                                        " gateway. Attempt to register?"
+                                    ), QtWidgets.QMessageBox.Yes
+                                    | QtWidgets.QMessageBox.No
+                            ) != QtWidgets.QMessageBox.Yes:
                                 continue
                             email = acct.getLabel()
-                            if email[-14:] != "@mailchuck.com": #attempt register
+                            # attempt register
+                            if email[-14:] != "@mailchuck.com":
                                 # 12 character random email address
-                                email = ''.join(random.SystemRandom().choice(string.ascii_lowercase) for _ in range(12)) + "@mailchuck.com"
+                                email = ''.join(
+                                    random.SystemRandom().choice(
+                                        string.ascii_lowercase
+                                    ) for _ in range(12)
+                                ) + "@mailchuck.com"
                             acct = MailchuckAccount(fromAddress)
                             acct.register(email)
                             BMConfigParser().set(fromAddress, 'label', email)
@@ -1939,76 +2032,80 @@ class MyForm(settingsmixin.SMainWindow):
                                 "MainWindow",
                                 "Error: Your account wasn't registered at"
                                 " an email gateway. Sending registration"
-                                " now as %1, please wait for the registration"
+                                " now as {0}, please wait for the registration"
                                 " to be processed before retrying sending."
-                                ).arg(email)
+                                ).format(email)
                             )
                             return
-                    status, addressVersionNumber, streamNumber, ripe = decodeAddress(
-                        toAddress)
+                    status, addressVersionNumber, streamNumber, ripe = \
+                        decodeAddress(toAddress)
                     if status != 'success':
                         try:
                             toAddress = unicode(toAddress, 'utf-8', 'ignore')
                         except:
-                            pass
-                        logger.error('Error: Could not decode recipient address ' + toAddress + ':' + status)
+                            logger.warning(
+                                "Failed unicode(toAddress ):",
+                                exc_info=True)
+                        logger.error(
+                            'Error: Could not decode recipient address %s: %s',
+                            toAddress, status)
 
                         if status == 'missingbm':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: Bitmessage addresses start with"
-                                " BM-   Please check the recipient address %1"
-                                ).arg(toAddress))
+                                " BM-   Please check the recipient address {0}"
+                                ).format(toAddress))
                         elif status == 'checksumfailed':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
-                                "Error: The recipient address %1 is not"
+                                "Error: The recipient address {0} is not"
                                 " typed or copied correctly. Please check it."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         elif status == 'invalidcharacters':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
-                                "Error: The recipient address %1 contains"
+                                "Error: The recipient address {0} contains"
                                 " invalid characters. Please check it."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         elif status == 'versiontoohigh':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: The version of the recipient address"
-                                " %1 is too high. Either you need to upgrade"
+                                " {0} is too high. Either you need to upgrade"
                                 " your Bitmessage software or your"
                                 " acquaintance is being clever."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         elif status == 'ripetooshort':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: Some data encoded in the recipient"
-                                " address %1 is too short. There might be"
+                                " address {0} is too short. There might be"
                                 " something wrong with the software of"
                                 " your acquaintance."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         elif status == 'ripetoolong':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: Some data encoded in the recipient"
-                                " address %1 is too long. There might be"
+                                " address {0} is too long. There might be"
                                 " something wrong with the software of"
                                 " your acquaintance."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         elif status == 'varintmalformed':
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: Some data encoded in the recipient"
-                                " address %1 is malformed. There might be"
+                                " address {0} is malformed. There might be"
                                 " something wrong with the software of"
                                 " your acquaintance."
-                                ).arg(toAddress))
+                                ).format(toAddress))
                         else:
                             self.updateStatusBar(_translate(
                                 "MainWindow",
                                 "Error: Something is wrong with the"
-                                " recipient address %1."
-                                ).arg(toAddress))
+                                " recipient address {0}."
+                                ).format(toAddress))
                     elif fromAddress == '':
                         self.updateStatusBar(_translate(
                             "MainWindow",
@@ -2020,12 +2117,31 @@ class MyForm(settingsmixin.SMainWindow):
                         toAddress = addBMIfNotPresent(toAddress)
 
                         if addressVersionNumber > 4 or addressVersionNumber <= 1:
-                            QtGui.QMessageBox.about(self, _translate("MainWindow", "Address version number"), _translate(
-                                "MainWindow", "Concerning the address %1, Bitmessage cannot understand address version numbers of %2. Perhaps upgrade Bitmessage to the latest version.").arg(toAddress).arg(str(addressVersionNumber)))
+                            QtWidgets.QMessageBox.about(
+                                self,
+                                _translate(
+                                    "MainWindow", "Address version number"),
+                                _translate(
+                                    "MainWindow",
+                                    "Concerning the address {0}, Bitmessage"
+                                    " cannot understand address version"
+                                    " numbers of {1}. Perhaps upgrade"
+                                    " Bitmessage to the latest version."
+                                ).format(toAddress, addressVersionNumber)
+                            )
                             continue
                         if streamNumber > 1 or streamNumber == 0:
-                            QtGui.QMessageBox.about(self, _translate("MainWindow", "Stream number"), _translate(
-                                "MainWindow", "Concerning the address %1, Bitmessage cannot handle stream numbers of %2. Perhaps upgrade Bitmessage to the latest version.").arg(toAddress).arg(str(streamNumber)))
+                            QtWidgets.QMessageBox.about(
+                                self,
+                                _translate("MainWindow", "Stream number"),
+                                _translate(
+                                    "MainWindow",
+                                    "Concerning the address {0}, Bitmessage"
+                                    " cannot handle stream numbers of {1}."
+                                    " Perhaps upgrade Bitmessage to the"
+                                    " latest version."
+                                ).format(toAddress, streamNumber)
+                            )
                             continue
                         self.statusbar.clearMessage()
                         if shared.statusIconColor == 'red':
@@ -2119,7 +2235,7 @@ class MyForm(settingsmixin.SMainWindow):
                     '''INSERT INTO sent VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)''', *t)
 
                 toLabel = str_broadcast_subscribers
-                
+
                 self.displayNewSentMessage(
                     toAddress, toLabel, fromAddress, subject, message, ackdata)
 
@@ -2149,11 +2265,11 @@ class MyForm(settingsmixin.SMainWindow):
 
     def click_pushButtonFetchNamecoinID(self):
         nc = namecoinConnection()
-        identities = str(self.ui.lineEditTo.text().toUtf8()).split(";")
+        identities = str(self.ui.lineEditTo.text()).split(";")
         err, addr = nc.query(identities[-1].strip())
         if err is not None:
             self.updateStatusBar(
-                _translate("MainWindow", "Error: %1").arg(err))
+                _translate("MainWindow", "Error: {0}").format(err))
         else:
             identities[-1] = addr
             self.ui.lineEditTo.setText("; ".join(identities))
@@ -2184,7 +2300,7 @@ class MyForm(settingsmixin.SMainWindow):
 #        self.ui.comboBoxSendFrom.model().sort(1, Qt.AscendingOrder)
         for i in range(self.ui.comboBoxSendFrom.count()):
             address = str(self.ui.comboBoxSendFrom.itemData(
-                i, QtCore.Qt.UserRole).toString())
+                i, QtCore.Qt.UserRole))
             self.ui.comboBoxSendFrom.setItemData(
                 i, AccountColor(address).accountColor(),
                 QtCore.Qt.ForegroundRole)
@@ -2207,7 +2323,7 @@ class MyForm(settingsmixin.SMainWindow):
                 self.ui.comboBoxSendFromBroadcast.addItem(avatarize(addressInKeysFile), label, addressInKeysFile)
         for i in range(self.ui.comboBoxSendFromBroadcast.count()):
             address = str(self.ui.comboBoxSendFromBroadcast.itemData(
-                i, QtCore.Qt.UserRole).toString())
+                i, QtCore.Qt.UserRole))
             self.ui.comboBoxSendFromBroadcast.setItemData(
                 i, AccountColor(address).accountColor(),
                 QtCore.Qt.ForegroundRole)
@@ -2221,29 +2337,46 @@ class MyForm(settingsmixin.SMainWindow):
     # receives a message to an address that is acting as a
     # pseudo-mailing-list. The message will be broadcast out. This function
     # puts the message on the 'Sent' tab.
-    def displayNewSentMessage(self, toAddress, toLabel, fromAddress, subject, message, ackdata):
+    def displayNewSentMessage(
+            self, toAddress, toLabel, fromAddress, subject,
+            message, ackdata):
         acct = accountClass(fromAddress)
         acct.parseMessage(toAddress, fromAddress, subject, message)
         tab = -1
-        for sent in [self.ui.tableWidgetInbox, self.ui.tableWidgetInboxSubscriptions, self.ui.tableWidgetInboxChans]:
+        for sent in (
+            self.ui.tableWidgetInbox,
+            self.ui.tableWidgetInboxSubscriptions,
+            self.ui.tableWidgetInboxChans
+        ):
             tab += 1
             if tab == 1:
                 tab = 2
             treeWidget = self.widgetConvert(sent)
             if self.getCurrentFolder(treeWidget) != "sent":
                 continue
-            if treeWidget == self.ui.treeWidgetYourIdentities and self.getCurrentAccount(treeWidget) != fromAddress:
+            if treeWidget == self.ui.treeWidgetYourIdentities \
+                    and self.getCurrentAccount(treeWidget) != fromAddress:
                 continue
-            elif treeWidget in [self.ui.treeWidgetSubscriptions, self.ui.treeWidgetChans] and self.getCurrentAccount(treeWidget) != toAddress:
+            elif treeWidget in (
+                self.ui.treeWidgetSubscriptions,
+                self.ui.treeWidgetChans
+            ) and self.getCurrentAccount(treeWidget) != toAddress:
                 continue
-            elif not helper_search.check_match(toAddress, fromAddress, subject, message, self.getCurrentSearchOption(tab), self.getCurrentSearchLine(tab)):
+            elif not helper_search.check_match(
+                toAddress, fromAddress, subject, message,
+                self.getCurrentSearchOption(tab),
+                self.getCurrentSearchLine(tab)
+            ):
                 continue
-            
-            self.addMessageListItemSent(sent, toAddress, fromAddress, subject, "msgqueued", ackdata, time.time())
-            self.getAccountTextedit(acct).setPlainText(unicode(message, 'utf-8)', 'replace'))
+
+            self.addMessageListItemSent(
+                sent, toAddress, fromAddress, subject, "msgqueued",
+                ackdata, time.time())
+            self.getAccountTextedit(acct).setPlainText(message)
             sent.setCurrentCell(0, 0)
 
-    def displayNewInboxMessage(self, inventoryHash, toAddress, fromAddress, subject, message):
+    def displayNewInboxMessage(
+            self, inventoryHash, toAddress, fromAddress, subject, message):
         if toAddress == str_broadcast_subscribers:
             acct = accountClass(fromAddress)
         else:
@@ -2251,17 +2384,38 @@ class MyForm(settingsmixin.SMainWindow):
         inbox = self.getAccountMessagelist(acct)
         ret = None
         tab = -1
-        for treeWidget in [self.ui.treeWidgetYourIdentities, self.ui.treeWidgetSubscriptions, self.ui.treeWidgetChans]:
+        for treeWidget in (
+            self.ui.treeWidgetYourIdentities,
+            self.ui.treeWidgetSubscriptions,
+            self.ui.treeWidgetChans
+        ):
             tab += 1
             if tab == 1:
                 tab = 2
             tableWidget = self.widgetConvert(treeWidget)
-            if not helper_search.check_match(toAddress, fromAddress, subject, message, self.getCurrentSearchOption(tab), self.getCurrentSearchLine(tab)):
+            if not helper_search.check_match(
+                toAddress, fromAddress, subject, message,
+                self.getCurrentSearchOption(tab),
+                self.getCurrentSearchLine(tab)
+            ):
                 continue
-            if tableWidget == inbox and self.getCurrentAccount(treeWidget) == acct.address and self.getCurrentFolder(treeWidget) in ["inbox", None]:
-                ret = self.addMessageListItemInbox(inbox, "inbox", inventoryHash, toAddress, fromAddress, subject, time.time(), 0)
-            elif treeWidget == self.ui.treeWidgetYourIdentities and self.getCurrentAccount(treeWidget) is None and self.getCurrentFolder(treeWidget) in ["inbox", "new", None]:
-                ret = self.addMessageListItemInbox(tableWidget, "inbox", inventoryHash, toAddress, fromAddress, subject, time.time(), 0)
+
+            if tableWidget == inbox \
+                and self.getCurrentAccount(treeWidget) == acct.address \
+                and self.getCurrentFolder(treeWidget) \
+                    in ("inbox", None):
+                ret = self.addMessageListItemInbox(
+                    inbox, "inbox", inventoryHash, toAddress, fromAddress,
+                    subject, time.time(), 0
+                )
+            elif treeWidget == self.ui.treeWidgetYourIdentities \
+                and self.getCurrentAccount(treeWidget) is None \
+                and self.getCurrentFolder(treeWidget) \
+                    in ("inbox", "new", None):
+                ret = self.addMessageListItemInbox(
+                    tableWidget, "inbox", inventoryHash, toAddress,
+                    fromAddress, subject, time.time(), 0
+                )
         if ret is None:
             acct.parseMessage(toAddress, fromAddress, subject, "")
         else:
@@ -2271,11 +2425,13 @@ class MyForm(settingsmixin.SMainWindow):
                 'bitmessagesettings', 'showtraynotifications'):
             self.notifierShow(
                 _translate("MainWindow", "New Message"),
-                _translate("MainWindow", "From %1").arg(
-                    unicode(acct.fromLabel, 'utf-8')),
+                _translate("MainWindow", "From {0}").format(acct.fromLabel),
                 sound.SOUND_UNKNOWN
             )
-        if self.getCurrentAccount() is not None and ((self.getCurrentFolder(treeWidget) != "inbox" and self.getCurrentFolder(treeWidget) is not None) or self.getCurrentAccount(treeWidget) != acct.address):
+        if self.getCurrentAccount() is not None and (
+            (self.getCurrentFolder(treeWidget) != "inbox"
+             and self.getCurrentFolder(treeWidget) is not None)
+                or self.getCurrentAccount(treeWidget) != acct.address):
             # Ubuntu should notify of new message irespective of
             # whether it's in current message list or not
             self.indicatorUpdate(True, to_label=acct.toLabel)
@@ -2400,14 +2556,14 @@ class MyForm(settingsmixin.SMainWindow):
                 self.settingsDialogInstance.ui.checkBoxUseIdenticons.isChecked()))
             BMConfigParser().set('bitmessagesettings', 'replybelow', str(
                 self.settingsDialogInstance.ui.checkBoxReplyBelow.isChecked()))
-                
-            lang = str(self.settingsDialogInstance.ui.languageComboBox.itemData(self.settingsDialogInstance.ui.languageComboBox.currentIndex()).toString())
+
+            lang = str(self.settingsDialogInstance.ui.languageComboBox.itemData(self.settingsDialogInstance.ui.languageComboBox.currentIndex()))
             BMConfigParser().set('bitmessagesettings', 'userlocale', lang)
             change_translation(l10n.getTranslationLanguage())
-            
+
             if int(BMConfigParser().get('bitmessagesettings', 'port')) != int(self.settingsDialogInstance.ui.lineEditTCPPort.text()):
                 if not BMConfigParser().safeGetBoolean('bitmessagesettings', 'dontconnect'):
-                    QtGui.QMessageBox.about(self, _translate("MainWindow", "Restart"), _translate(
+                    QtWidgets.QMessageBox.about(self, _translate("MainWindow", "Restart"), _translate(
                         "MainWindow", "You must restart Bitmessage for the port number change to take effect."))
                 BMConfigParser().set('bitmessagesettings', 'port', str(
                     self.settingsDialogInstance.ui.lineEditTCPPort.text()))
@@ -2421,7 +2577,7 @@ class MyForm(settingsmixin.SMainWindow):
             #print 'self.settingsDialogInstance.ui.comboBoxProxyType.currentText())[0:5]', self.settingsDialogInstance.ui.comboBoxProxyType.currentText()[0:5]
             if BMConfigParser().get('bitmessagesettings', 'socksproxytype') == 'none' and self.settingsDialogInstance.ui.comboBoxProxyType.currentText()[0:5] == 'SOCKS':
                 if shared.statusIconColor != 'red':
-                    QtGui.QMessageBox.about(self, _translate("MainWindow", "Restart"), _translate(
+                    QtWidgets.QMessageBox.about(self, _translate("MainWindow", "Restart"), _translate(
                         "MainWindow", "Bitmessage will use your proxy from now on but you may want to manually restart Bitmessage now to close existing connections (if any)."))
             if BMConfigParser().get('bitmessagesettings', 'socksproxytype')[0:5] == 'SOCKS' and self.settingsDialogInstance.ui.comboBoxProxyType.currentText()[0:5] != 'SOCKS':
                 self.statusbar.clearMessage()
@@ -2450,7 +2606,7 @@ class MyForm(settingsmixin.SMainWindow):
                 BMConfigParser().set('bitmessagesettings', 'maxuploadrate', str(
                     int(float(self.settingsDialogInstance.ui.lineEditMaxUploadRate.text()))))
             except ValueError:
-                QtGui.QMessageBox.about(self, _translate("MainWindow", "Number needed"), _translate(
+                QtWidgets.QMessageBox.about(self, _translate("MainWindow", "Number needed"), _translate(
                     "MainWindow", "Your maximum download and upload rate must be numbers. Ignoring what you typed."))
             else:
                 set_rates(BMConfigParser().safeGetInt("bitmessagesettings", "maxdownloadrate"),
@@ -2478,7 +2634,7 @@ class MyForm(settingsmixin.SMainWindow):
                 BMConfigParser().set('bitmessagesettings', 'defaultpayloadlengthextrabytes', str(int(float(
                     self.settingsDialogInstance.ui.lineEditSmallMessageDifficulty.text()) * defaults.networkDefaultPayloadLengthExtraBytes)))
 
-            if self.settingsDialogInstance.ui.comboBoxOpenCL.currentText().toUtf8() != BMConfigParser().safeGet("bitmessagesettings", "opencl"):
+            if self.settingsDialogInstance.ui.comboBoxOpenCL.currentText() != BMConfigParser().safeGet("bitmessagesettings", "opencl"):
                 BMConfigParser().set('bitmessagesettings', 'opencl', str(self.settingsDialogInstance.ui.comboBoxOpenCL.currentText()))
                 queues.workerQueue.put(('resetPoW', ''))
 
@@ -2530,7 +2686,7 @@ class MyForm(settingsmixin.SMainWindow):
                 if (float(self.settingsDialogInstance.ui.lineEditDays.text()) >=0 and float(self.settingsDialogInstance.ui.lineEditMonths.text()) >=0):
                     shared.maximumLengthOfTimeToBotherResendingMessages = (float(str(self.settingsDialogInstance.ui.lineEditDays.text())) * 24 * 60 * 60) + (float(str(self.settingsDialogInstance.ui.lineEditMonths.text())) * (60 * 60 * 24 *365)/12)
                     if shared.maximumLengthOfTimeToBotherResendingMessages < 432000: # If the time period is less than 5 hours, we give zero values to all fields. No message will be sent again.
-                        QtGui.QMessageBox.about(self, _translate("MainWindow", "Will not resend ever"), _translate(
+                        QtWidgets.QMessageBox.about(self, _translate("MainWindow", "Will not resend ever"), _translate(
                             "MainWindow", "Note that the time limit you entered is less than the amount of time Bitmessage waits for the first resend attempt therefore your messages will never be resent."))
                         BMConfigParser().set('bitmessagesettings', 'stopresendingafterxdays', '0')
                         BMConfigParser().set('bitmessagesettings', 'stopresendingafterxmonths', '0')
@@ -2609,7 +2765,7 @@ class MyForm(settingsmixin.SMainWindow):
         # Only settings remain here
         acct.settings()
         for i in range(self.ui.comboBoxSendFrom.count()):
-            if str(self.ui.comboBoxSendFrom.itemData(i).toPyObject()) \
+            if str(self.ui.comboBoxSendFrom.itemData(i)) \
                     == acct.fromAddress:
                 self.ui.comboBoxSendFrom.setCurrentIndex(i)
                 break
@@ -2628,13 +2784,13 @@ class MyForm(settingsmixin.SMainWindow):
         self.ui.textEditMessage.setFocus()
 
     def on_action_MarkAllRead(self):
-        if QtGui.QMessageBox.question(
+        if QtWidgets.QMessageBox.question(
                 self, "Marking all messages as read?",
                 _translate(
                     "MainWindow",
                     "Are you sure you would like to mark all messages read?"
-                ), QtGui.QMessageBox.Yes | QtGui.QMessageBox.No
-        ) != QtGui.QMessageBox.Yes:
+                ), QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+        ) != QtWidgets.QMessageBox.Yes:
             return
         # addressAtCurrentRow = self.getCurrentAccount()
         tableWidget = self.getCurrentMessagelist()
@@ -2649,7 +2805,7 @@ class MyForm(settingsmixin.SMainWindow):
         msgids = []
         for i in range(0, idCount):
             msgids.append(str(tableWidget.item(
-                i, 3).data(QtCore.Qt.UserRole).toPyObject()))
+                i, 3).data(QtCore.Qt.UserRole)))
             tableWidget.item(i, 0).setUnread(False)
             tableWidget.item(i, 1).setUnread(False)
             tableWidget.item(i, 2).setUnread(False)
@@ -2679,13 +2835,6 @@ class MyForm(settingsmixin.SMainWindow):
 
     # Quit selected from menu or application indicator
     def quit(self):
-        '''quit_msg = "Are you sure you want to exit Bitmessage?"
-        reply = QtGui.QMessageBox.question(self, 'Message',
-                         quit_msg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
-
-        if reply is QtGui.QMessageBox.No:
-            return
-        '''
 
         if self.quitAccepted:
             return
@@ -2699,43 +2848,69 @@ class MyForm(settingsmixin.SMainWindow):
         waitForSync = False
 
         # C PoW currently doesn't support interrupting and OpenCL is untested
-        if getPowType() == "python" and (powQueueSize() > 0 or PendingUpload().len() > 0):
-            reply = QtGui.QMessageBox.question(self, _translate("MainWindow", "Proof of work pending"),
-                    _translate("MainWindow", "%n object(s) pending proof of work", None, QtCore.QCoreApplication.CodecForTr, powQueueSize()) + ", " +
-                    _translate("MainWindow", "%n object(s) waiting to be distributed", None, QtCore.QCoreApplication.CodecForTr, PendingUpload().len()) + "\n\n" + 
-                    _translate("MainWindow", "Wait until these tasks finish?"),
-                    QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel, QtGui.QMessageBox.Cancel)
-            if reply == QtGui.QMessageBox.No:
+        if getPowType() == "python" and (
+                powQueueSize() > 0 or PendingUpload().len() > 0):
+            reply = QtWidgets.QMessageBox.question(
+                self, _translate("MainWindow", "Proof of work pending"),
+                _translate(
+                    "MainWindow",
+                    "%n object(s) pending proof of work", None, powQueueSize()
+                ) + ", " +
+                _translate(
+                    "MainWindow",
+                    "%n object(s) waiting to be distributed",
+                    None, PendingUpload().len()
+                ) + "\n\n" +
+                _translate("MainWindow", "Wait until these tasks finish?"),
+                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+                | QtWidgets.QMessageBox.Cancel,
+                QtWidgets.QMessageBox.Cancel
+            )
+            if reply == QtWidgets.QMessageBox.No:
                 waitForPow = False
-            elif reply == QtGui.QMessageBox.Cancel:
+            elif reply == QtWidgets.QMessageBox.Cancel:
                 return
 
         if PendingDownloadQueue.totalSize() > 0:
-            reply = QtGui.QMessageBox.question(self, _translate("MainWindow", "Synchronisation pending"),
-                    _translate("MainWindow", "Bitmessage hasn't synchronised with the network, %n object(s) to be downloaded. If you quit now, it may cause delivery delays. Wait until the synchronisation finishes?", None, QtCore.QCoreApplication.CodecForTr, PendingDownloadQueue.totalSize()),
-                    QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel, QtGui.QMessageBox.Cancel)
-            if reply == QtGui.QMessageBox.Yes:
+            reply = QtWidgets.QMessageBox.question(
+                self, _translate("MainWindow", "Synchronisation pending"),
+                _translate(
+                    "MainWindow",
+                    "Bitmessage hasn't synchronised with the network,"
+                    " %n object(s) to be downloaded. If you quit now, it may"
+                    " cause delivery delays. Wait until the synchronisation"
+                    " finishes?", None, PendingDownloadQueue.totalSize()
+                ), QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+                | QtWidgets.QMessageBox.Cancel, QtWidgets.QMessageBox.Cancel)
+            if reply == QtWidgets.QMessageBox.Yes:
                 waitForSync = True
-            elif reply == QtGui.QMessageBox.Cancel:
+            elif reply == QtWidgets.QMessageBox.Cancel:
                 return
             else:
                 PendingDownloadQueue.stop()
 
-        if shared.statusIconColor == 'red' and not BMConfigParser().safeGetBoolean(
+        if shared.statusIconColor == 'red' \
+            and not BMConfigParser().safeGetBoolean(
                 'bitmessagesettings', 'dontconnect'):
-            reply = QtGui.QMessageBox.question(self, _translate("MainWindow", "Not connected"),
-                    _translate("MainWindow", "Bitmessage isn't connected to the network. If you quit now, it may cause delivery delays. Wait until connected and the synchronisation finishes?"),
-                    QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel, QtGui.QMessageBox.Cancel)
-            if reply == QtGui.QMessageBox.Yes:
+            reply = QtWidgets.QMessageBox.question(
+                self, _translate("MainWindow", "Not connected"),
+                _translate(
+                    "MainWindow",
+                    "Bitmessage isn't connected to the network."
+                    " If you quit now, it may cause delivery delays."
+                    " Wait until connected and the synchronisation finishes?"
+                ), QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+                | QtWidgets.QMessageBox.Cancel, QtWidgets.QMessageBox.Cancel)
+            if reply == QtWidgets.QMessageBox.Yes:
                 waitForConnection = True
                 waitForSync = True
-            elif reply == QtGui.QMessageBox.Cancel:
+            elif reply == QtWidgets.QMessageBox.Cancel:
                 return
 
         self.quitAccepted = True
 
         self.updateStatusBar(_translate(
-            "MainWindow", "Shutting down PyBitmessage... %1%").arg(0))
+            "MainWindow", "Shutting down PyBitmessage... {0}%").format(0))
 
         if waitForConnection:
             self.updateStatusBar(_translate(
@@ -2746,7 +2921,9 @@ class MyForm(settingsmixin.SMainWindow):
                     QtCore.QEventLoop.AllEvents, 1000
                 )
 
-        # this probably will not work correctly, because there is a delay between the status icon turning red and inventory exchange, but it's better than nothing.
+        # this probably will not work correctly, because there is a delay
+        # between the status icon turning red and inventory exchange,
+        # but it's better than nothing.
         if waitForSync:
             self.updateStatusBar(_translate(
                 "MainWindow", "Waiting for finishing synchronisation..."))
@@ -2767,17 +2944,18 @@ class MyForm(settingsmixin.SMainWindow):
                     maxWorkerQueue = curWorkerQueue
                 if curWorkerQueue > 0:
                     self.updateStatusBar(_translate(
-                        "MainWindow", "Waiting for PoW to finish... %1%"
-                        ).arg(50 * (maxWorkerQueue - curWorkerQueue)
-                              / maxWorkerQueue)
-                    )
+                        "MainWindow", "Waiting for PoW to finish... {0}%"
+                    ).format(
+                        50 * (maxWorkerQueue - curWorkerQueue) / maxWorkerQueue
+                    ))
                     time.sleep(0.5)
                     QtCore.QCoreApplication.processEvents(
                         QtCore.QEventLoop.AllEvents, 1000
                     )
 
             self.updateStatusBar(_translate(
-                "MainWindow", "Shutting down Pybitmessage... %1%").arg(50))
+                "MainWindow", "Shutting down Pybitmessage... {0}%"
+            ).format(50))
 
             QtCore.QCoreApplication.processEvents(
                 QtCore.QEventLoop.AllEvents, 1000
@@ -2791,14 +2969,14 @@ class MyForm(settingsmixin.SMainWindow):
 
             # check if upload (of objects created locally) pending
             self.updateStatusBar(_translate(
-                "MainWindow", "Waiting for objects to be sent... %1%").arg(50))
+                "MainWindow", "Waiting for objects to be sent... {0}%"
+            ).format(50))
             try:
                 while PendingUpload().progress() < 1:
                     self.updateStatusBar(_translate(
                         "MainWindow",
-                        "Waiting for objects to be sent... %1%"
-                        ).arg(int(50 + 20 * PendingUpload().progress()))
-                    )
+                        "Waiting for objects to be sent... {0}%"
+                    ).format(int(50 + 20 * PendingUpload().progress())))
                     time.sleep(0.5)
                     QtCore.QCoreApplication.processEvents(
                         QtCore.QEventLoop.AllEvents, 1000
@@ -2815,7 +2993,7 @@ class MyForm(settingsmixin.SMainWindow):
 
         # save state and geometry self and all widgets
         self.updateStatusBar(_translate(
-            "MainWindow", "Saving settings... %1%").arg(70))
+            "MainWindow", "Saving settings... {0}%").format(70))
         QtCore.QCoreApplication.processEvents(
             QtCore.QEventLoop.AllEvents, 1000
         )
@@ -2828,17 +3006,17 @@ class MyForm(settingsmixin.SMainWindow):
                     obj.saveSettings()
 
         self.updateStatusBar(_translate(
-            "MainWindow", "Shutting down core... %1%").arg(80))
+            "MainWindow", "Shutting down core... {0}%").format(80))
         QtCore.QCoreApplication.processEvents(
             QtCore.QEventLoop.AllEvents, 1000
         )
         shutdown.doCleanShutdown()
         self.updateStatusBar(_translate(
-            "MainWindow", "Stopping notifications... %1%").arg(90))
+            "MainWindow", "Stopping notifications... {0}%").format(90))
         self.tray.hide()
 
         self.updateStatusBar(_translate(
-            "MainWindow", "Shutdown imminent... %1%").arg(100))
+            "MainWindow", "Shutdown imminent... {0}%").format(100))
         shared.thisapp.cleanup()
         logger.info("Shutdown complete")
         super(MyForm, myapp).close()
@@ -2888,10 +3066,10 @@ class MyForm(settingsmixin.SMainWindow):
             elif lines[i] == '' and (i+1) < totalLines and \
                  lines[i+1] != '------------------------------------------------------':
                 lines[i] = '<br><br>'
-        content = ' '.join(lines) # To keep the whitespace between lines
+        content = ' '.join(lines)  # To keep the whitespace between lines
         content = shared.fixPotentiallyInvalidUTF8Data(content)
-        content = unicode(content, 'utf-8)')
-        textEdit.setHtml(QtCore.QString(content))
+        content = unicode(content, 'utf-8')
+        textEdit.setHtml(content)
 
     def on_action_InboxMarkUnread(self):
         tableWidget = self.getCurrentMessagelist()
@@ -2903,7 +3081,7 @@ class MyForm(settingsmixin.SMainWindow):
         for row in tableWidget.selectedIndexes():
             currentRow = row.row()
             msgid = str(tableWidget.item(
-                currentRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+                currentRow, 3).data(QtCore.Qt.UserRole))
             msgids.add(msgid)
             # if not tableWidget.item(currentRow, 0).unread:
             #     modified += 1
@@ -2918,26 +3096,18 @@ class MyForm(settingsmixin.SMainWindow):
         )
 
         self.propagateUnreadCount()
-        # if rowcount == 1:
-        #     # performance optimisation
-        #     self.propagateUnreadCount(tableWidget.item(currentRow, 1 if tableWidget.item(currentRow, 1).type == AccountMixin.SUBSCRIPTION else 0).data(QtCore.Qt.UserRole), self.getCurrentFolder())
-        # else:
-        #     self.propagateUnreadCount(tableWidget.item(currentRow, 1 if tableWidget.item(currentRow, 1).type == AccountMixin.SUBSCRIPTION else 0).data(QtCore.Qt.UserRole), self.getCurrentFolder(), self.getCurrentTreeWidget(), 0)
-        # tableWidget.selectRow(currentRow + 1) 
-        # This doesn't de-select the last message if you try to mark it unread, but that doesn't interfere. Might not be necessary.
-        # We could also select upwards, but then our problem would be with the topmost message.
-        # tableWidget.clearSelection() manages to mark the message as read again.
 
     # Format predefined text on message reply.
     def quoted_text(self, message):
         if not BMConfigParser().safeGetBoolean('bitmessagesettings', 'replybelow'):
           return '\n\n------------------------------------------------------\n' + message
 
-        quoteWrapper = textwrap.TextWrapper(replace_whitespace = False,
-                                            initial_indent = '> ',
-                                            subsequent_indent = '> ',
-                                            break_long_words = False,
-                                            break_on_hyphens = False)
+        quoteWrapper = textwrap.TextWrapper(
+            replace_whitespace=False, initial_indent='> ',
+            subsequent_indent='> ', break_long_words=False,
+            break_on_hyphens=False
+        )
+
         def quote_line(line):
             # Do quote empty lines.
             if line == '' or line.isspace():
@@ -2950,15 +3120,18 @@ class MyForm(settingsmixin.SMainWindow):
                 return quoteWrapper.fill(line)
         return '\n'.join([quote_line(l) for l in message.splitlines()]) + '\n\n'
 
-    def setSendFromComboBox(self, address = None):
+    def setSendFromComboBox(self, address=None):
         if address is None:
             messagelist = self.getCurrentMessagelist()
             if messagelist:
                 currentInboxRow = messagelist.currentRow()
                 address = messagelist.item(
                     currentInboxRow, 0).address
-        for box in [self.ui.comboBoxSendFrom, self.ui.comboBoxSendFromBroadcast]:
-            listOfAddressesInComboBoxSendFrom = [str(box.itemData(i).toPyObject()) for i in range(box.count())]
+        for box in (
+            self.ui.comboBoxSendFrom, self.ui.comboBoxSendFromBroadcast
+        ):
+            listOfAddressesInComboBoxSendFrom = [
+                str(box.itemData(i)) for i in range(box.count())]
             if address in listOfAddressesInComboBoxSendFrom:
                 currentIndex = listOfAddressesInComboBoxSendFrom.index(address)
                 box.setCurrentIndex(currentIndex)
@@ -2967,18 +3140,18 @@ class MyForm(settingsmixin.SMainWindow):
 
     def on_action_InboxReplyChan(self):
         self.on_action_InboxReply(self.REPLY_TYPE_CHAN)
-    
-    def on_action_InboxReply(self, replyType = None):
+
+    def on_action_InboxReply(self, replyType=None):
         tableWidget = self.getCurrentMessagelist()
         if not tableWidget:
             return
-        
+
         if replyType is None:
             replyType = self.REPLY_TYPE_SENDER
-        
+
         # save this to return back after reply is done
         self.replyFromTab = self.ui.tabWidget.currentIndex()
-        
+
         currentInboxRow = tableWidget.currentRow()
         toAddressAtCurrentInboxRow = tableWidget.item(
             currentInboxRow, 0).address
@@ -2986,13 +3159,17 @@ class MyForm(settingsmixin.SMainWindow):
         fromAddressAtCurrentInboxRow = tableWidget.item(
             currentInboxRow, 1).address
         msgid = str(tableWidget.item(
-            currentInboxRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+            currentInboxRow, 3).data(QtCore.Qt.UserRole))
         queryreturn = sqlQuery(
             '''select message from inbox where msgid=?''', msgid)
         if queryreturn != []:
             for row in queryreturn:
                 messageAtCurrentInboxRow, = row
-        acct.parseMessage(toAddressAtCurrentInboxRow, fromAddressAtCurrentInboxRow, tableWidget.item(currentInboxRow, 2).subject, messageAtCurrentInboxRow)
+        acct.parseMessage(
+            toAddressAtCurrentInboxRow, fromAddressAtCurrentInboxRow,
+            tableWidget.item(currentInboxRow, 2).subject,
+            messageAtCurrentInboxRow
+        )
         widget = {
             'subject': self.ui.lineEditSubject,
             'from': self.ui.comboBoxSendFrom,
@@ -3004,11 +3181,26 @@ class MyForm(settingsmixin.SMainWindow):
             )
 #            toAddressAtCurrentInboxRow = fromAddressAtCurrentInboxRow
         elif not BMConfigParser().has_section(toAddressAtCurrentInboxRow):
-            QtGui.QMessageBox.information(self, _translate("MainWindow", "Address is gone"), _translate(
-                "MainWindow", "Bitmessage cannot find your address %1. Perhaps you removed it?").arg(toAddressAtCurrentInboxRow), QtGui.QMessageBox.Ok)
-        elif not BMConfigParser().getboolean(toAddressAtCurrentInboxRow, 'enabled'):
-            QtGui.QMessageBox.information(self, _translate("MainWindow", "Address disabled"), _translate(
-                "MainWindow", "Error: The address from which you are trying to send is disabled. You\'ll have to enable it on the \'Your Identities\' tab before using it."), QtGui.QMessageBox.Ok)
+            QtWidgets.QMessageBox.information(
+                self,
+                _translate("MainWindow", "Address is gone"),
+                _translate(
+                    "MainWindow",
+                    "Bitmessage cannot find your address {0}. Perhaps you"
+                    " removed it?"
+                ).format(toAddressAtCurrentInboxRow),
+                QtWidgets.QMessageBox.Ok)
+        elif not BMConfigParser().getboolean(
+                toAddressAtCurrentInboxRow, 'enabled'):
+            QtWidgets.QMessageBox.information(
+                self,
+                _translate("MainWindow", "Address disabled"),
+                _translate(
+                    "MainWindow",
+                    "Error: The address from which you are trying to send"
+                    " is disabled. You\'ll have to enable it on the \'Your"
+                    " Identities\' tab before using it."
+                ), QtWidgets.QMessageBox.Ok)
         else:
             self.setBroadcastEnablementDependingOnWhetherThisIsAMailingListAddress(toAddressAtCurrentInboxRow)
             broadcast_tab_index = self.ui.tabWidgetSend.indexOf(
@@ -3026,24 +3218,35 @@ class MyForm(settingsmixin.SMainWindow):
             isinstance(acct, GatewayAccount) and fromAddressAtCurrentInboxRow == acct.relayAddress):
             self.ui.lineEditTo.setText(str(acct.fromAddress))
         else:
-            self.ui.lineEditTo.setText(tableWidget.item(currentInboxRow, 1).label + " <" + str(acct.fromAddress) + ">")
-        
-        # If the previous message was to a chan then we should send our reply to the chan rather than to the particular person who sent the message.
+            self.ui.lineEditTo.setText(
+                tableWidget.item(currentInboxRow, 1).label +
+                " <" + str(acct.fromAddress) + ">"
+            )
+
+        # If the previous message was to a chan then we should send our
+        # reply to the chan rather than to the particular person
+        # who sent the message.
         if acct.type == AccountMixin.CHAN and replyType == self.REPLY_TYPE_CHAN:
-            logger.debug('original sent to a chan. Setting the to address in the reply to the chan address.')
+            logger.debug(
+                'original sent to a chan. Setting the to address'
+                ' in the reply to the chan address.'
+            )
             if toAddressAtCurrentInboxRow == tableWidget.item(currentInboxRow, 0).label:
                 self.ui.lineEditTo.setText(str(toAddressAtCurrentInboxRow))
             else:
                 self.ui.lineEditTo.setText(tableWidget.item(currentInboxRow, 0).label + " <" + str(acct.toAddress) + ">")
-        
+
         self.setSendFromComboBox(toAddressAtCurrentInboxRow)
-        
-        quotedText = self.quoted_text(unicode(messageAtCurrentInboxRow, 'utf-8', 'replace'))
+
+        quotedText = self.quoted_text(
+            unicode(messageAtCurrentInboxRow, 'utf-8', 'replace'))
         widget['message'].setPlainText(quotedText)
-        if acct.subject[0:3] in ['Re:', 'RE:']:
-            widget['subject'].setText(tableWidget.item(currentInboxRow, 2).label)
+        if acct.subject[0:3] in ('Re:', 'RE:'):
+            widget['subject'].setText(
+                tableWidget.item(currentInboxRow, 2).label)
         else:
-            widget['subject'].setText('Re: ' + tableWidget.item(currentInboxRow, 2).label)
+            widget['subject'].setText(
+                'Re: ' + tableWidget.item(currentInboxRow, 2).label)
         self.ui.tabWidget.setCurrentIndex(
             self.ui.tabWidget.indexOf(self.ui.send)
         )
@@ -3054,7 +3257,7 @@ class MyForm(settingsmixin.SMainWindow):
         if not tableWidget:
             return
         currentInboxRow = tableWidget.currentRow()
-        # tableWidget.item(currentRow,1).data(Qt.UserRole).toPyObject()
+        # tableWidget.item(currentRow,1).data(Qt.UserRole)
         addressAtCurrentInboxRow = tableWidget.item(
             currentInboxRow, 1).data(QtCore.Qt.UserRole)
         self.ui.tabWidget.setCurrentIndex(
@@ -3068,7 +3271,7 @@ class MyForm(settingsmixin.SMainWindow):
         if not tableWidget:
             return
         currentInboxRow = tableWidget.currentRow()
-        # tableWidget.item(currentRow,1).data(Qt.UserRole).toPyObject()
+        # tableWidget.item(currentRow,1).data(Qt.UserRole)
         addressAtCurrentInboxRow = tableWidget.item(
             currentInboxRow, 1).data(QtCore.Qt.UserRole)
         recipientAddress = tableWidget.item(
@@ -3092,23 +3295,28 @@ class MyForm(settingsmixin.SMainWindow):
                 "Error: You cannot add the same address to your blacklist"
                 " twice. Try renaming the existing one if you want."))
 
-    def deleteRowFromMessagelist(self, row = None, inventoryHash = None, ackData = None, messageLists = None):
+    def deleteRowFromMessagelist(
+        self, row=None, inventoryHash=None, ackData=None, messageLists=None
+    ):
         if messageLists is None:
-            messageLists = (self.ui.tableWidgetInbox, self.ui.tableWidgetInboxChans, self.ui.tableWidgetInboxSubscriptions)
+            messageLists = (
+                self.ui.tableWidgetInbox, self.ui.tableWidgetInboxChans,
+                self.ui.tableWidgetInboxSubscriptions
+            )
         elif type(messageLists) not in (list, tuple):
             messageLists = (messageLists)
         for messageList in messageLists:
             if row is not None:
-                inventoryHash = str(messageList.item(row, 3).data(
-                    QtCore.Qt.UserRole).toPyObject())
+                inventoryHash = messageList.item(row, 3).data(
+                    QtCore.Qt.UserRole)
                 messageList.removeRow(row)
             elif inventoryHash is not None:
                 for i in range(messageList.rowCount() - 1, -1, -1):
-                    if messageList.item(i, 3).data(QtCore.Qt.UserRole).toPyObject() == inventoryHash:
+                    if messageList.item(i, 3).data(QtCore.Qt.UserRole) == inventoryHash:
                         messageList.removeRow(i)
             elif ackData is not None:
                 for i in range(messageList.rowCount() - 1, -1, -1):
-                    if messageList.item(i, 3).data(QtCore.Qt.UserRole).toPyObject() == ackData:
+                    if messageList.item(i, 3).data(QtCore.Qt.UserRole) == ackData:
                         messageList.removeRow(i)
 
     # Send item on the Inbox tab to trash
@@ -3118,20 +3326,23 @@ class MyForm(settingsmixin.SMainWindow):
             return
         currentRow = 0
         folder = self.getCurrentFolder()
-        shifted = QtGui.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier
-        tableWidget.setUpdatesEnabled(False);
+        shifted = QtWidgets.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier
+        tableWidget.setUpdatesEnabled(False)
         inventoryHashesToTrash = []
         # ranges in reversed order
-        for r in sorted(tableWidget.selectedRanges(), key=lambda r: r.topRow())[::-1]:
+        for r in sorted(
+            tableWidget.selectedRanges(), key=lambda r: r.topRow()
+        )[::-1]:
             for i in range(r.bottomRow()-r.topRow()+1):
                 inventoryHashToTrash = str(tableWidget.item(
-                    r.topRow()+i, 3).data(QtCore.Qt.UserRole).toPyObject())
+                    r.topRow()+i, 3).data(QtCore.Qt.UserRole))
                 if inventoryHashToTrash in inventoryHashesToTrash:
                     continue
                 inventoryHashesToTrash.append(inventoryHashToTrash)
             currentRow = r.topRow()
             self.getCurrentMessageTextedit().setText("")
-            tableWidget.model().removeRows(r.topRow(), r.bottomRow()-r.topRow()+1)
+            tableWidget.model().removeRows(
+                r.topRow(), r.bottomRow() - r.topRow() + 1)
         idCount = len(inventoryHashesToTrash)
         if folder == "trash" or shifted:
             sqlExecuteChunked('''DELETE FROM inbox WHERE msgid IN ({0})''',
@@ -3153,16 +3364,19 @@ class MyForm(settingsmixin.SMainWindow):
         tableWidget.setUpdatesEnabled(False)
         inventoryHashesToTrash = []
         # ranges in reversed order
-        for r in sorted(tableWidget.selectedRanges(), key=lambda r: r.topRow())[::-1]:
-            for i in range(r.bottomRow()-r.topRow()+1):
+        for r in sorted(
+            tableWidget.selectedRanges(),
+                key=lambda r: r.topRow())[::-1]:
+            for i in range(r.bottomRow() - r.topRow() + 1):
                 inventoryHashToTrash = str(tableWidget.item(
-                    r.topRow()+i, 3).data(QtCore.Qt.UserRole).toPyObject())
+                    r.topRow()+i, 3).data(QtCore.Qt.UserRole))
                 if inventoryHashToTrash in inventoryHashesToTrash:
                     continue
                 inventoryHashesToTrash.append(inventoryHashToTrash)
             currentRow = r.topRow()
             self.getCurrentMessageTextedit().setText("")
-            tableWidget.model().removeRows(r.topRow(), r.bottomRow()-r.topRow()+1)
+            tableWidget.model().removeRows(
+                r.topRow(), r.bottomRow() - r.topRow() + 1)
         if currentRow == 0:
             tableWidget.selectRow(currentRow)
         else:
@@ -3188,16 +3402,20 @@ class MyForm(settingsmixin.SMainWindow):
 
         # Retrieve the message data out of the SQL database
         msgid = str(tableWidget.item(
-            currentInboxRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+            currentInboxRow, 3).data(QtCore.Qt.UserRole))
         queryreturn = sqlQuery(
             '''select message from inbox where msgid=?''', msgid)
         if queryreturn != []:
             for row in queryreturn:
                 message, = row
 
-        defaultFilename = "".join(x for x in subjectAtCurrentInboxRow if x.isalnum()) + '.txt'
-        filename = QtGui.QFileDialog.getSaveFileName(self, _translate("MainWindow","Save As..."), defaultFilename, "Text files (*.txt);;All files (*.*)")
-        if filename == '':
+        defaultFilename = "".join(
+            x for x in subjectAtCurrentInboxRow if x.isalnum()) + '.txt'
+        filename, filetype = QtWidgets.QFileDialog.getSaveFileName(
+            self, _translate("MainWindow", "Save As..."), defaultFilename,
+            "Text files (*.txt);;All files (*.*)"
+        )
+        if not filename:
             return
         try:
             f = open(filename, 'w')
@@ -3210,16 +3428,15 @@ class MyForm(settingsmixin.SMainWindow):
     # Send item on the Sent tab to trash
     def on_action_SentTrash(self):
         currentRow = 0
-        unread = False
         tableWidget = self.getCurrentMessagelist()
         if not tableWidget:
             return
         folder = self.getCurrentFolder()
-        shifted = (QtGui.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier) > 0
+        shifted = (QtWidgets.QApplication.queryKeyboardModifiers() & QtCore.Qt.ShiftModifier) > 0
         while tableWidget.selectedIndexes() != []:
             currentRow = tableWidget.selectedIndexes()[0].row()
             ackdataToTrash = str(tableWidget.item(
-                currentRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+                currentRow, 3).data(QtCore.Qt.UserRole))
             if folder == "trash" or shifted:
                 sqlExecute('''DELETE FROM sent WHERE ackdata=?''', ackdataToTrash)
             else:
@@ -3245,15 +3462,18 @@ class MyForm(settingsmixin.SMainWindow):
         queryreturn = sqlQuery('''select ackdata FROM sent WHERE status='forcepow' ''')
         for row in queryreturn:
             ackdata, = row
-            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                ackdata, 'Overriding maximum-difficulty setting. Work queued.')))
+            queues.UISignalQueue.put((
+                'updateSentItemStatusByAckdata',
+                (ackdata, 'Overriding maximum-difficulty setting.'
+                 ' Work queued.')
+            ))
         queues.workerQueue.put(('sendmessage', ''))
 
     def on_action_SentClipboard(self):
         currentRow = self.ui.tableWidgetInbox.currentRow()
         addressAtCurrentRow = self.ui.tableWidgetInbox.item(
             currentRow, 0).data(QtCore.Qt.UserRole)
-        clipboard = QtGui.QApplication.clipboard()
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(str(addressAtCurrentRow))
 
     # Group of functions for the Address Book dialog box
@@ -3265,11 +3485,11 @@ class MyForm(settingsmixin.SMainWindow):
             currentRow = self.ui.tableWidgetAddressBook.selectedIndexes()[
                 0].row()
             labelAtCurrentRow = self.ui.tableWidgetAddressBook.item(
-                currentRow, 0).text().toUtf8()
+                currentRow, 0).text()
             addressAtCurrentRow = self.ui.tableWidgetAddressBook.item(
                 currentRow, 1).text()
             sqlExecute('''DELETE FROM addressbook WHERE label=? AND address=?''',
-                       str(labelAtCurrentRow), str(addressAtCurrentRow))
+                       labelAtCurrentRow, addressAtCurrentRow)
             self.ui.tableWidgetAddressBook.removeRow(currentRow)
             self.rerenderMessagelistFromLabels()
             self.rerenderMessagelistToLabels()
@@ -3287,7 +3507,7 @@ class MyForm(settingsmixin.SMainWindow):
                 fullStringOfAddresses = addressAtCurrentRow
             else:
                 fullStringOfAddresses += ', ' + str(addressAtCurrentRow)
-        clipboard = QtGui.QApplication.clipboard()
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(fullStringOfAddresses)
 
     def on_action_AddressBookSend(self):
@@ -3304,8 +3524,8 @@ class MyForm(settingsmixin.SMainWindow):
             if self.ui.lineEditTo.text() == '':
                 self.ui.lineEditTo.setText(stringToAdd)
             else:
-                self.ui.lineEditTo.setText(unicode(
-                    self.ui.lineEditTo.text().toUtf8(), encoding="UTF-8") + '; ' + stringToAdd)
+                self.ui.lineEditTo.setText(
+                    self.ui.lineEditTo.text() + '; ' + stringToAdd)
         if listOfSelectedRows == {}:
             self.updateStatusBar(_translate(
                 "MainWindow", "No addresses selected."))
@@ -3329,14 +3549,14 @@ class MyForm(settingsmixin.SMainWindow):
                     " subscriptions twice. Perhaps rename the existing"
                     " one if you want."))
                 continue
-            labelAtCurrentRow = self.ui.tableWidgetAddressBook.item(currentRow,0).text().toUtf8()
+            labelAtCurrentRow = self.ui.tableWidgetAddressBook.item(currentRow,0).text()
             self.addSubscription(addressAtCurrentRow, labelAtCurrentRow)
             self.ui.tabWidget.setCurrentIndex(
                 self.ui.tabWidget.indexOf(self.ui.subscriptions)
             )
 
     def on_context_menuAddressBook(self, point):
-        self.popMenuAddressBook = QtGui.QMenu(self)
+        self.popMenuAddressBook = QtWidgets.QMenu(self)
         self.popMenuAddressBook.addAction(self.actionAddressBookSend)
         self.popMenuAddressBook.addAction(self.actionAddressBookClipboard)
         self.popMenuAddressBook.addAction(self.actionAddressBookSubscribe)
@@ -3362,7 +3582,7 @@ class MyForm(settingsmixin.SMainWindow):
         self.click_pushButtonAddSubscription()
 
     def on_action_SubscriptionsDelete(self):
-        if QtGui.QMessageBox.question(
+        if QtWidgets.QMessageBox.question(
                 self, "Delete subscription?",
                 _translate(
                     "MainWindow",
@@ -3373,8 +3593,8 @@ class MyForm(settingsmixin.SMainWindow):
                     " messages, but you can still view messages you"
                     " already received.\n\nAre you sure you want to"
                     " delete the subscription?"
-                ), QtGui.QMessageBox.Yes | QtGui.QMessageBox.No
-        ) != QtGui.QMessageBox.Yes:
+                ), QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+        ) != QtWidgets.QMessageBox.Yes:
             return
         address = self.getCurrentAccount()
         sqlExecute('''DELETE FROM subscriptions WHERE address=?''',
@@ -3386,7 +3606,7 @@ class MyForm(settingsmixin.SMainWindow):
 
     def on_action_SubscriptionsClipboard(self):
         address = self.getCurrentAccount()
-        clipboard = QtGui.QApplication.clipboard()
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(str(address))
 
     def on_action_SubscriptionsEnable(self):
@@ -3411,7 +3631,7 @@ class MyForm(settingsmixin.SMainWindow):
 
     def on_context_menuSubscriptions(self, point):
         currentItem = self.getCurrentItem()
-        self.popMenuSubscriptions = QtGui.QMenu(self)
+        self.popMenuSubscriptions = QtWidgets.QMenu(self)
         if isinstance(currentItem, Ui_AddressWidget):
             self.popMenuSubscriptions.addAction(self.actionsubscriptionsNew)
             self.popMenuSubscriptions.addAction(self.actionsubscriptionsDelete)
@@ -3445,7 +3665,7 @@ class MyForm(settingsmixin.SMainWindow):
             return None
 
     def getCurrentTreeWidget(self):
-        currentIndex = self.ui.tabWidget.currentIndex();
+        currentIndex = self.ui.tabWidget.currentIndex()
         treeWidgetList = [
             self.ui.treeWidgetYourIdentities,
             False,
@@ -3469,7 +3689,7 @@ class MyForm(settingsmixin.SMainWindow):
             return self.ui.treeWidgetYourIdentities
 
     def getCurrentMessagelist(self):
-        currentIndex = self.ui.tabWidget.currentIndex();
+        currentIndex = self.ui.tabWidget.currentIndex()
         messagelistList = [
             self.ui.tableWidgetInbox,
             False,
@@ -3480,7 +3700,7 @@ class MyForm(settingsmixin.SMainWindow):
             return messagelistList[currentIndex]
         else:
             return False
-            
+
     def getAccountMessagelist(self, account):
         try:
             if account.type == AccountMixin.CHAN:
@@ -3497,20 +3717,20 @@ class MyForm(settingsmixin.SMainWindow):
         if messagelist:
             currentRow = messagelist.currentRow()
             if currentRow >= 0:
-                msgid = str(messagelist.item(
-                    currentRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+                msgid = messagelist.item(
+                    currentRow, 3).data(QtCore.Qt.UserRole)
                 # data is saved at the 4. column of the table...
                 return msgid
         return False
 
     def getCurrentMessageTextedit(self):
         currentIndex = self.ui.tabWidget.currentIndex()
-        messagelistList = [
+        messagelistList = (
             self.ui.textEditInboxMessage,
             False,
             self.ui.textEditInboxMessageSubscriptions,
             self.ui.textEditInboxMessageChans,
-        ]
+        )
         if currentIndex >= 0 and currentIndex < len(messagelistList):
             return messagelistList[currentIndex]
         else:
@@ -3530,33 +3750,31 @@ class MyForm(settingsmixin.SMainWindow):
     def getCurrentSearchLine(self, currentIndex=None, retObj=False):
         if currentIndex is None:
             currentIndex = self.ui.tabWidget.currentIndex()
-        messagelistList = [
+        messagelistList = (
             self.ui.inboxSearchLineEdit,
             False,
             self.ui.inboxSearchLineEditSubscriptions,
             self.ui.inboxSearchLineEditChans,
-        ]
+        )
         if currentIndex >= 0 and currentIndex < len(messagelistList):
             if retObj:
                 return messagelistList[currentIndex]
             else:
-                return messagelistList[currentIndex].text().toUtf8().data()
+                return messagelistList[currentIndex].text()
         else:
             return None
 
     def getCurrentSearchOption(self, currentIndex=None):
         if currentIndex is None:
             currentIndex = self.ui.tabWidget.currentIndex()
-        messagelistList = [
+        messagelistList = (
             self.ui.inboxSearchOption,
             False,
             self.ui.inboxSearchOptionSubscriptions,
             self.ui.inboxSearchOptionChans,
-        ]
+        )
         if currentIndex >= 0 and currentIndex < len(messagelistList):
-            return messagelistList[currentIndex].currentText().toUtf8().data()
-        else:
-            return None
+            return messagelistList[currentIndex].currentText()
 
     # Group of functions for the Your Identities dialog box
     def getCurrentItem(self, treeWidget=None):
@@ -3567,7 +3785,7 @@ class MyForm(settingsmixin.SMainWindow):
             if currentItem:
                 return currentItem
         return False
-    
+
     def getCurrentAccount(self, treeWidget=None):
         currentItem = self.getCurrentItem(treeWidget)
         if currentItem:
@@ -3580,13 +3798,11 @@ class MyForm(settingsmixin.SMainWindow):
     def getCurrentFolder(self, treeWidget=None):
         if treeWidget is None:
             treeWidget = self.getCurrentTreeWidget()
-        #treeWidget = self.ui.treeWidgetYourIdentities
+        # treeWidget = self.ui.treeWidgetYourIdentities
         if treeWidget:
             currentItem = treeWidget.currentItem()
             if currentItem and hasattr(currentItem, 'folderName'):
                 return currentItem.folderName
-            else:
-                return None
 
     def setCurrentItemColor(self, color):
         treeWidget = self.getCurrentTreeWidget()
@@ -3605,7 +3821,7 @@ class MyForm(settingsmixin.SMainWindow):
         if account.type == AccountMixin.NORMAL:
             return  # maybe in the future
         elif account.type == AccountMixin.CHAN:
-            if QtGui.QMessageBox.question(
+            if QtWidgets.QMessageBox.question(
                     self, "Delete channel?",
                     _translate(
                         "MainWindow",
@@ -3616,8 +3832,8 @@ class MyForm(settingsmixin.SMainWindow):
                         " messages, but you can still view messages you"
                         " already received.\n\nAre you sure you want to"
                         " delete the channel?"
-                    ), QtGui.QMessageBox.Yes | QtGui.QMessageBox.No
-            ) == QtGui.QMessageBox.Yes:
+                    ), QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
+            ) == QtWidgets.QMessageBox.Yes:
                 BMConfigParser().remove_section(str(account.address))
             else:
                 return
@@ -3658,43 +3874,43 @@ class MyForm(settingsmixin.SMainWindow):
 
     def on_action_Clipboard(self):
         address = self.getCurrentAccount()
-        clipboard = QtGui.QApplication.clipboard()
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(str(address))
 
     def on_action_ClipboardMessagelist(self):
         tableWidget = self.getCurrentMessagelist()
         currentColumn = tableWidget.currentColumn()
         currentRow = tableWidget.currentRow()
-        if currentColumn not in [0, 1, 2]: # to, from, subject
-            if self.getCurrentFolder() == "sent":
-                currentColumn = 0
-            else:
-                currentColumn = 1
-        if self.getCurrentFolder() == "sent":
+        currentFolder = self.getCurrentFolder()
+        if currentColumn not in (0, 1, 2):  # to, from, subject
+            currentColumn = 0 if currentFolder == "sent" else 1
+
+        if currentFolder == "sent":
             myAddress = tableWidget.item(currentRow, 1).data(QtCore.Qt.UserRole)
             otherAddress = tableWidget.item(currentRow, 0).data(QtCore.Qt.UserRole)
         else:
             myAddress = tableWidget.item(currentRow, 0).data(QtCore.Qt.UserRole)
             otherAddress = tableWidget.item(currentRow, 1).data(QtCore.Qt.UserRole)
         account = accountClass(myAddress)
-        if isinstance(account, GatewayAccount) and otherAddress == account.relayAddress and (
-            (currentColumn in [0, 2] and self.getCurrentFolder() == "sent") or
-            (currentColumn in [1, 2] and self.getCurrentFolder() != "sent")):
+        if isinstance(account, GatewayAccount) \
+            and otherAddress == account.relayAddress and (
+                (currentColumn in (0, 2) and currentFolder == "sent")
+                or (currentColumn in (1, 2) and currentFolder != "sent")):
             text = str(tableWidget.item(currentRow, currentColumn).label)
         else:
             text = tableWidget.item(currentRow, currentColumn).data(QtCore.Qt.UserRole)
-        text = unicode(str(text), 'utf-8', 'ignore')
-        clipboard = QtGui.QApplication.clipboard()
+
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(text)
 
-    #set avatar functions
+    # set avatar functions
     def on_action_TreeWidgetSetAvatar(self):
         address = self.getCurrentAccount()
         self.setAvatar(address)
 
     def on_action_AddressBookSetAvatar(self):
         self.on_action_SetAvatar(self.ui.tableWidgetAddressBook)
-        
+
     def on_action_SetAvatar(self, thisTableWidget):
         currentRow = thisTableWidget.currentRow()
         addressAtCurrentRow = thisTableWidget.item(
@@ -3708,15 +3924,33 @@ class MyForm(settingsmixin.SMainWindow):
         if not os.path.exists(state.appdata + 'avatars/'):
             os.makedirs(state.appdata + 'avatars/')
         hash = hashlib.md5(addBMIfNotPresent(addressAtCurrentRow)).hexdigest()
-        extensions = ['PNG', 'GIF', 'JPG', 'JPEG', 'SVG', 'BMP', 'MNG', 'PBM', 'PGM', 'PPM', 'TIFF', 'XBM', 'XPM', 'TGA']
+        extensions = [
+            'PNG', 'GIF', 'JPG', 'JPEG', 'SVG', 'BMP', 'MNG', 'PBM',
+            'PGM', 'PPM', 'TIFF', 'XBM', 'XPM', 'TGA'
+        ]
         # http://pyqt.sourceforge.net/Docs/PyQt4/qimagereader.html#supportedImageFormats
-        names = {'BMP':'Windows Bitmap', 'GIF':'Graphic Interchange Format', 'JPG':'Joint Photographic Experts Group', 'JPEG':'Joint Photographic Experts Group', 'MNG':'Multiple-image Network Graphics', 'PNG':'Portable Network Graphics', 'PBM':'Portable Bitmap', 'PGM':'Portable Graymap', 'PPM':'Portable Pixmap', 'TIFF':'Tagged Image File Format', 'XBM':'X11 Bitmap', 'XPM':'X11 Pixmap', 'SVG':'Scalable Vector Graphics', 'TGA':'Targa Image Format'}
+        names = {
+            'BMP': 'Windows Bitmap',
+            'GIF': 'Graphic Interchange Format',
+            'JPG': 'Joint Photographic Experts Group',
+            'JPEG': 'Joint Photographic Experts Group',
+            'MNG': 'Multiple-image Network Graphics',
+            'PNG': 'Portable Network Graphics',
+            'PBM': 'Portable Bitmap',
+            'PGM': 'Portable Graymap',
+            'PPM': 'Portable Pixmap',
+            'TIFF': 'Tagged Image File Format',
+            'XBM': 'X11 Bitmap',
+            'XPM': 'X11 Pixmap',
+            'SVG': 'Scalable Vector Graphics',
+            'TGA': 'Targa Image Format'
+        }
         filters = []
         all_images_filter = []
         current_files = []
         for ext in extensions:
-            filters += [ names[ext] + ' (*.' + ext.lower() + ')' ]
-            all_images_filter += [ '*.' + ext.lower() ]
+            filters += [names[ext] + ' (*.' + ext.lower() + ')']
+            all_images_filter += ['*.' + ext.lower()]
             upper = state.appdata + 'avatars/' + hash + '.' + ext.upper()
             lower = state.appdata + 'avatars/' + hash + '.' + ext.lower()
             if os.path.isfile(lower):
@@ -3725,33 +3959,43 @@ class MyForm(settingsmixin.SMainWindow):
                 current_files += [upper]
         filters[0:0] = ['Image files (' + ' '.join(all_images_filter) + ')']
         filters[1:1] = ['All files (*.*)']
-        sourcefile = QtGui.QFileDialog.getOpenFileName(
+        sourcefile, filetype = QtWidgets.QFileDialog.getOpenFileName(
             self, _translate("MainWindow", "Set avatar..."),
-            filter = ';;'.join(filters)
+            filter=';;'.join(filters)
         )
         # determine the correct filename (note that avatars don't use the suffix)
         destination = state.appdata + 'avatars/' + hash + '.' + sourcefile.split('.')[-1]
         exists = QtCore.QFile.exists(destination)
         if sourcefile == '':
             # ask for removal of avatar
-            if exists | (len(current_files)>0):
-                displayMsg = _translate("MainWindow", "Do you really want to remove this avatar?")
-                overwrite = QtGui.QMessageBox.question(
-                            self, 'Message', displayMsg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
+            if exists | (len(current_files) > 0):
+                displayMsg = _translate(
+                    "MainWindow", "Do you really want to remove this avatar?"
+                )
+                overwrite = QtWidgets.QMessageBox.question(
+                    self, 'Message', displayMsg,
+                    QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No
+                )
             else:
-                overwrite = QtGui.QMessageBox.No
+                overwrite = QtWidgets.QMessageBox.No
         else:
             # ask whether to overwrite old avatar
-            if exists | (len(current_files)>0):
-                displayMsg = _translate("MainWindow", "You have already set an avatar for this address. Do you really want to overwrite it?")
-                overwrite = QtGui.QMessageBox.question(
-                            self, 'Message', displayMsg, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
+            if exists | (len(current_files) > 0):
+                displayMsg = _translate(
+                    "MainWindow",
+                    "You have already set an avatar for this address."
+                    " Do you really want to overwrite it?"
+                )
+                overwrite = QtWidgets.QMessageBox.question(
+                    self, 'Message', displayMsg,
+                    QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No
+                )
             else:
-                overwrite = QtGui.QMessageBox.No
-            
+                overwrite = QtWidgets.QMessageBox.No
+
         # copy the image file to the appdata folder
-        if (not exists) | (overwrite == QtGui.QMessageBox.Yes):
-            if overwrite == QtGui.QMessageBox.Yes:
+        if (not exists) | (overwrite == QtWidgets.QMessageBox.Yes):
+            if overwrite == QtWidgets.QMessageBox.Yes:
                 for file in current_files:
                     QtCore.QFile.remove(file)
                 QtCore.QFile.remove(destination)
@@ -3783,10 +4027,10 @@ class MyForm(settingsmixin.SMainWindow):
             "MainWindow", "Sound files (%s)" %
             ' '.join(['*%s%s' % (os.extsep, ext) for ext in sound.extensions])
         ))]
-        sourcefile = unicode(QtGui.QFileDialog.getOpenFileName(
+        sourcefile, filetype = QtWidgets.QFileDialog.getOpenFileName(
             self, _translate("MainWindow", "Set notification sound..."),
             filter=';;'.join(filters)
-        ))
+        )
 
         if not sourcefile:
             return
@@ -3801,15 +4045,15 @@ class MyForm(settingsmixin.SMainWindow):
         pattern = destfile.lower()
         for item in os.listdir(destdir):
             if item.lower() == pattern:
-                overwrite = QtGui.QMessageBox.question(
+                overwrite = QtWidgets.QMessageBox.question(
                     self, _translate("MainWindow", "Message"),
                     _translate(
                         "MainWindow",
                         "You have already set a notification sound"
                         " for this address book entry."
                         " Do you really want to overwrite it?"),
-                    QtGui.QMessageBox.Yes, QtGui.QMessageBox.No
-                ) == QtGui.QMessageBox.Yes
+                    QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No
+                ) == QtWidgets.QMessageBox.Yes
                 if overwrite:
                     QtCore.QFile.remove(os.path.join(destdir, item))
                 break
@@ -3820,18 +4064,23 @@ class MyForm(settingsmixin.SMainWindow):
 
     def on_context_menuYourIdentities(self, point):
         currentItem = self.getCurrentItem()
-        self.popMenuYourIdentities = QtGui.QMenu(self)
+        self.popMenuYourIdentities = QtWidgets.QMenu(self)
         if isinstance(currentItem, Ui_AddressWidget):
             self.popMenuYourIdentities.addAction(self.actionNewYourIdentities)
             self.popMenuYourIdentities.addSeparator()
-            self.popMenuYourIdentities.addAction(self.actionClipboardYourIdentities)
+            self.popMenuYourIdentities.addAction(
+                self.actionClipboardYourIdentities)
             self.popMenuYourIdentities.addSeparator()
             if currentItem.isEnabled:
-                self.popMenuYourIdentities.addAction(self.actionDisableYourIdentities)
+                self.popMenuYourIdentities.addAction(
+                    self.actionDisableYourIdentities)
             else:
-                self.popMenuYourIdentities.addAction(self.actionEnableYourIdentities)
-            self.popMenuYourIdentities.addAction(self.actionSetAvatarYourIdentities)
-            self.popMenuYourIdentities.addAction(self.actionSpecialAddressBehaviorYourIdentities)
+                self.popMenuYourIdentities.addAction(
+                    self.actionEnableYourIdentities)
+            self.popMenuYourIdentities.addAction(
+                self.actionSetAvatarYourIdentities)
+            self.popMenuYourIdentities.addAction(
+                self.actionSpecialAddressBehaviorYourIdentities)
             self.popMenuYourIdentities.addAction(self.actionEmailGateway)
             self.popMenuYourIdentities.addSeparator()
         self.popMenuYourIdentities.addAction(self.actionMarkAllRead)
@@ -3847,7 +4096,7 @@ class MyForm(settingsmixin.SMainWindow):
     # TODO make one popMenu
     def on_context_menuChan(self, point):
         currentItem = self.getCurrentItem()
-        self.popMenu = QtGui.QMenu(self)
+        self.popMenu = QtWidgets.QMenu(self)
         if isinstance(currentItem, Ui_AddressWidget):
             self.popMenu.addAction(self.actionNew)
             self.popMenu.addAction(self.actionDelete)
@@ -3873,7 +4122,7 @@ class MyForm(settingsmixin.SMainWindow):
             if currentFolder == 'sent':
                 self.on_context_menuSent(point)
             else:
-                self.popMenuInbox = QtGui.QMenu(self)
+                self.popMenuInbox = QtWidgets.QMenu(self)
                 self.popMenuInbox.addAction(self.actionForceHtml)
                 self.popMenuInbox.addAction(self.actionMarkUnread)
                 self.popMenuInbox.addSeparator()
@@ -3895,13 +4144,14 @@ class MyForm(settingsmixin.SMainWindow):
                 self.popMenuInbox.addSeparator()
                 self.popMenuInbox.addAction(self.actionSaveMessageAs)
                 if currentFolder == "trash":
-                    self.popMenuInbox.addAction(self.actionUndeleteTrashedMessage)
+                    self.popMenuInbox.addAction(
+                        self.actionUndeleteTrashedMessage)
                 else:
                     self.popMenuInbox.addAction(self.actionTrashInboxMessage)
                 self.popMenuInbox.exec_(tableWidget.mapToGlobal(point))
 
     def on_context_menuSent(self, point):
-        self.popMenuSent = QtGui.QMenu(self)
+        self.popMenuSent = QtWidgets.QMenu(self)
         self.popMenuSent.addAction(self.actionSentClipboard)
         self.popMenuSent.addAction(self.actionTrashSentMessage)
 
@@ -3910,7 +4160,7 @@ class MyForm(settingsmixin.SMainWindow):
         currentRow = self.ui.tableWidgetInbox.currentRow()
         if currentRow >= 0:
             ackData = str(self.ui.tableWidgetInbox.item(
-                currentRow, 3).data(QtCore.Qt.UserRole).toPyObject())
+                currentRow, 3).data(QtCore.Qt.UserRole))
             queryreturn = sqlQuery('''SELECT status FROM sent where ackdata=?''', ackData)
             for row in queryreturn:
                 status, = row
@@ -3928,7 +4178,8 @@ class MyForm(settingsmixin.SMainWindow):
         if messagelist:
             account = self.getCurrentAccount()
             folder = self.getCurrentFolder()
-            self.loadMessagelist(messagelist, account, folder, searchOption, str(text))
+            self.loadMessagelist(
+                messagelist, account, folder, searchOption, str(text))
 
     def inboxSearchLineEditReturnPressed(self):
         logger.debug("Search return pressed")
@@ -3938,7 +4189,8 @@ class MyForm(settingsmixin.SMainWindow):
             searchOption = self.getCurrentSearchOption()
             account = self.getCurrentAccount()
             folder = self.getCurrentFolder()
-            self.loadMessagelist(messagelist, account, folder, searchOption, searchLine)
+            self.loadMessagelist(
+                messagelist, account, folder, searchOption, searchLine)
         if messagelist:
             messagelist.setFocus()
 
@@ -3947,15 +4199,16 @@ class MyForm(settingsmixin.SMainWindow):
         searchOption = self.getCurrentSearchOption()
         messageTextedit = self.getCurrentMessageTextedit()
         if messageTextedit:
-            messageTextedit.setPlainText(QtCore.QString(""))
+            messageTextedit.setPlainText("")
         messagelist = self.getCurrentMessagelist()
         if messagelist:
             account = self.getCurrentAccount()
             folder = self.getCurrentFolder()
-            treeWidget = self.getCurrentTreeWidget()
+            # treeWidget = self.getCurrentTreeWidget()
             # refresh count indicator
-            self.propagateUnreadCount(account.address if hasattr(account, 'address') else None, folder, treeWidget, 0)
-            self.loadMessagelist(messagelist, account, folder, searchOption, searchLine)
+            self.propagateUnreadCount()
+            self.loadMessagelist(
+                messagelist, account, folder, searchOption, searchLine)
 
     def treeWidgetItemChanged(self, item, column):
         # only for manual edits. automatic edits (setText) are ignored
@@ -3973,8 +4226,8 @@ class MyForm(settingsmixin.SMainWindow):
         # "All accounts" can't be renamed
         if item.type == AccountMixin.ALL:
             return
-        
-        newLabel = unicode(item.text(0), 'utf-8', 'ignore')
+
+        newLabel = item.text(0)
         oldLabel = item.defaultLabel()
 
         # unchanged, do not do anything either
@@ -3993,7 +4246,9 @@ class MyForm(settingsmixin.SMainWindow):
         self.rerenderMessagelistFromLabels()
         if item.type != AccountMixin.SUBSCRIPTION:
             self.rerenderMessagelistToLabels()
-        if item.type in (AccountMixin.NORMAL, AccountMixin.CHAN, AccountMixin.SUBSCRIPTION):
+        if item.type in (
+            AccountMixin.NORMAL, AccountMixin.CHAN, AccountMixin.SUBSCRIPTION
+        ):
             self.rerenderAddressBook()
         self.recurDepth -= 1
 
@@ -4013,9 +4268,9 @@ class MyForm(settingsmixin.SMainWindow):
             )
 
         try:
-            message = queryreturn[-1][0]
+            message = unicode(queryreturn[-1][0], 'utf-8')
         except NameError:
-            message = ""
+            message = u""
         except IndexError:
             message = _translate(
                 "MainWindow",
@@ -4091,10 +4346,10 @@ class MyForm(settingsmixin.SMainWindow):
                     obj.loadSettings()
 
 
-class settingsDialog(QtGui.QDialog):
+class settingsDialog(QtWidgets.QDialog):
 
     def __init__(self, parent):
-        QtGui.QWidget.__init__(self, parent)
+        super(settingsDialog, self).__init__(parent)
         self.ui = Ui_settingsDialog()
         self.ui.setupUi(self)
         self.parent = parent
@@ -4116,7 +4371,7 @@ class settingsDialog(QtGui.QDialog):
             BMConfigParser().safeGetBoolean('bitmessagesettings', 'useidenticons'))
         self.ui.checkBoxReplyBelow.setChecked(
             BMConfigParser().safeGetBoolean('bitmessagesettings', 'replybelow'))
-        
+
         if state.appdata == paths.lookupExeFolder():
             self.ui.checkBoxPortableMode.setChecked(True)
         else:
@@ -4172,8 +4427,8 @@ class settingsDialog(QtGui.QDialog):
             BMConfigParser().get('bitmessagesettings', 'socksusername')))
         self.ui.lineEditSocksPassword.setText(str(
             BMConfigParser().get('bitmessagesettings', 'sockspassword')))
-        QtCore.QObject.connect(self.ui.comboBoxProxyType, QtCore.SIGNAL(
-            "currentIndexChanged(int)"), self.comboBoxProxyTypeChanged)
+        self.ui.comboBoxProxyType.currentIndexChanged.connect(
+            self.comboBoxProxyTypeChanged)
         self.ui.lineEditMaxDownloadRate.setText(str(
             BMConfigParser().get('bitmessagesettings', 'maxdownloadrate')))
         self.ui.lineEditMaxUploadRate.setText(str(
@@ -4229,39 +4484,39 @@ class settingsDialog(QtGui.QDialog):
         else:
             assert False
 
-        QtCore.QObject.connect(self.ui.radioButtonNamecoinNamecoind, QtCore.SIGNAL(
-            "toggled(bool)"), self.namecoinTypeChanged)
-        QtCore.QObject.connect(self.ui.radioButtonNamecoinNmcontrol, QtCore.SIGNAL(
-            "toggled(bool)"), self.namecoinTypeChanged)
-        QtCore.QObject.connect(self.ui.pushButtonNamecoinTest, QtCore.SIGNAL(
-            "clicked()"), self.click_pushButtonNamecoinTest)
+        self.ui.radioButtonNamecoinNamecoind.toggled.connect(
+            self.namecoinTypeChanged)
+        self.ui.radioButtonNamecoinNmcontrol.toggled.connect(
+            self.namecoinTypeChanged)
+        self.ui.pushButtonNamecoinTest.clicked.connect(
+            self.click_pushButtonNamecoinTest)
 
-        #Message Resend tab
+        # Message Resend tab
         self.ui.lineEditDays.setText(str(
             BMConfigParser().get('bitmessagesettings', 'stopresendingafterxdays')))
         self.ui.lineEditMonths.setText(str(
             BMConfigParser().get('bitmessagesettings', 'stopresendingafterxmonths')))
-        
-        
-        #'System' tab removed for now.
-        """try:
-            maxCores = BMConfigParser().getint('bitmessagesettings', 'maxcores')
-        except:
-            maxCores = 99999
-        if maxCores <= 1:
-            self.ui.comboBoxMaxCores.setCurrentIndex(0)
-        elif maxCores == 2:
-            self.ui.comboBoxMaxCores.setCurrentIndex(1)
-        elif maxCores <= 4:
-            self.ui.comboBoxMaxCores.setCurrentIndex(2)
-        elif maxCores <= 8:
-            self.ui.comboBoxMaxCores.setCurrentIndex(3)
-        elif maxCores <= 16:
-            self.ui.comboBoxMaxCores.setCurrentIndex(4)
-        else:
-            self.ui.comboBoxMaxCores.setCurrentIndex(5)"""
 
-        QtGui.QWidget.resize(self, QtGui.QWidget.sizeHint(self))
+        # 'System' tab removed for now.
+        # try:
+        #     maxCores = BMConfigParser().getint(
+        #         'bitmessagesettings', 'maxcores')
+        # except:
+        #     maxCores = 99999
+        # if maxCores <= 1:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(0)
+        # elif maxCores == 2:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(1)
+        # elif maxCores <= 4:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(2)
+        # elif maxCores <= 8:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(3)
+        # elif maxCores <= 16:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(4)
+        # else:
+        #     self.ui.comboBoxMaxCores.setCurrentIndex(5)
+
+        QtWidgets.QWidget.resize(self, QtWidgets.QWidget.sizeHint(self))
 
     def comboBoxProxyTypeChanged(self, comboBoxIndex):
         if comboBoxIndex == 0:
@@ -4293,7 +4548,7 @@ class settingsDialog(QtGui.QDialog):
     def namecoinTypeChanged(self, checked):
         nmctype = self.getNamecoinType()
         assert nmctype == "namecoind" or nmctype == "nmcontrol"
-            
+
         isNamecoind = (nmctype == "namecoind")
         self.ui.lineEditNamecoinUser.setEnabled(isNamecoind)
         self.ui.labelNamecoinUser.setEnabled(isNamecoind)
@@ -4311,33 +4566,43 @@ class settingsDialog(QtGui.QDialog):
                 "MainWindow", "Testing..."))
         options = {}
         options["type"] = self.getNamecoinType()
-        options["host"] = str(self.ui.lineEditNamecoinHost.text().toUtf8())
-        options["port"] = str(self.ui.lineEditNamecoinPort.text().toUtf8())
-        options["user"] = str(self.ui.lineEditNamecoinUser.text().toUtf8())
-        options["password"] = str(self.ui.lineEditNamecoinPassword.text().toUtf8())
+        options["host"] = str(self.ui.lineEditNamecoinHost.text())
+        options["port"] = str(self.ui.lineEditNamecoinPort.text())
+        options["user"] = str(self.ui.lineEditNamecoinUser.text())
+        options["password"] = str(self.ui.lineEditNamecoinPassword.text())
         nc = namecoinConnection(options)
         response = nc.test()
         responseStatus = response[0]
         responseText = response[1]
         self.ui.labelNamecoinTestResult.setText(responseText)
-        if responseStatus== 'success':
+        if responseStatus == 'success':
             self.parent.ui.pushButtonFetchNamecoinID.show()
 
 
 # In order for the time columns on the Inbox and Sent tabs to be sorted
 # correctly (rather than alphabetically), we need to overload the <
 # operator and use this class instead of QTableWidgetItem.
-class myTableWidgetItem(QtGui.QTableWidgetItem):
+class myTableWidgetItem(QtWidgets.QTableWidgetItem):
 
     def __lt__(self, other):
-        return int(self.data(33).toPyObject()) < int(other.data(33).toPyObject())
+        return self.data(33) < other.data(33)
+
+    def setData(self, role, value):
+        if role == QtCore.Qt.UserRole:
+            self._data = value
+        return super(myTableWidgetItem, self).setData(role, value)
+
+    def data(self, role):
+        if role == QtCore.Qt.UserRole:
+            return self._data
+        return super(myTableWidgetItem, self).data(role)
 
 
 app = None
 myapp = None
 
 
-class MySingleApplication(QtGui.QApplication):
+class MySingleApplication(QtWidgets.QApplication):
     """
     Listener to allow our Qt form to get focus when another instance of the
     application is open.
@@ -4356,15 +4621,15 @@ class MySingleApplication(QtGui.QApplication):
         self.server = None
         self.is_running = False
 
-        socket = QLocalSocket()
+        socket = QtNetwork.QLocalSocket()
         socket.connectToServer(id)
         self.is_running = socket.waitForConnected()
 
         # Cleanup past crashed servers
         if not self.is_running:
-            if socket.error() == QLocalSocket.ConnectionRefusedError:
+            if socket.error() == QtNetwork.QLocalSocket.ConnectionRefusedError:
                 socket.disconnectFromServer()
-                QLocalServer.removeServer(id)
+                QtNetwork.QLocalServer.removeServer(id)
 
         socket.abort()
 
@@ -4375,7 +4640,7 @@ class MySingleApplication(QtGui.QApplication):
         else:
             # Nope, create a local server with this id and assign on_new_connection
             # for whenever a second instance tries to run focus the application.
-            self.server = QLocalServer()
+            self.server = QtNetwork.QLocalServer()
             self.server.listen(id)
             self.server.newConnection.connect(self.on_new_connection)
 
diff --git a/src/bitmessageqt/account.py b/src/bitmessageqt/account.py
index 92d497f..fd5adc5 100644
--- a/src/bitmessageqt/account.py
+++ b/src/bitmessageqt/account.py
@@ -1,4 +1,4 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtGui
 
 import queues
 import re
@@ -9,18 +9,21 @@ from helper_ackPayload import genAckPayload
 from addresses import decodeAddress
 from bmconfigparser import BMConfigParser
 from foldertree import AccountMixin
-from pyelliptic.openssl import OpenSSL
 from utils import str_broadcast_subscribers
 import time
 
+
 def getSortedAccounts():
     configSections = BMConfigParser().addresses()
-    configSections.sort(cmp = 
-        lambda x,y: cmp(unicode(BMConfigParser().get(x, 'label'), 'utf-8').lower(), unicode(BMConfigParser().get(y, 'label'), 'utf-8').lower())
-        )
+    configSections.sort(
+        cmp=lambda x, y: cmp(
+            unicode(BMConfigParser().get(x, 'label'), 'utf-8').lower(),
+            unicode(BMConfigParser().get(y, 'label'), 'utf-8').lower())
+    )
     return configSections
 
-def getSortedSubscriptions(count = False):
+
+def getSortedSubscriptions(count=False):
     queryreturn = sqlQuery('SELECT label, address, enabled FROM subscriptions ORDER BY label COLLATE NOCASE ASC')
     ret = {}
     for row in queryreturn:
@@ -37,7 +40,7 @@ def getSortedSubscriptions(count = False):
             GROUP BY inbox.fromaddress, folder''', str_broadcast_subscribers)
         for row in queryreturn:
             address, folder, cnt = row
-            if not folder in ret[address]:
+            if folder not in ret[address]:
                 ret[address][folder] = {
                     'label': ret[address]['inbox']['label'],
                     'enabled': ret[address]['inbox']['enabled']
@@ -45,6 +48,7 @@ def getSortedSubscriptions(count = False):
             ret[address][folder]['count'] = cnt
     return ret
 
+
 def accountClass(address):
     if not BMConfigParser().has_section(address):
         # FIXME: This BROADCAST section makes no sense
@@ -60,8 +64,9 @@ def accountClass(address):
         return subscription
     try:
         gateway = BMConfigParser().get(address, "gateway")
-        for name, cls in inspect.getmembers(sys.modules[__name__], inspect.isclass):
-#            obj = g(address)
+        for name, cls in inspect.getmembers(
+                sys.modules[__name__], inspect.isclass):
+            # obj = g(address)
             if issubclass(cls, GatewayAccount) and cls.gatewayName == gateway:
                 return cls(address)
         # general gateway
@@ -70,9 +75,10 @@ def accountClass(address):
         pass
     # no gateway
     return BMAccount(address)
-    
+
+
 class AccountColor(AccountMixin):
-    def __init__(self, address, type = None):
+    def __init__(self, address, type=None):
         self.isEnabled = True
         self.address = address
         if type is None:
@@ -90,9 +96,9 @@ class AccountColor(AccountMixin):
         else:
             self.type = type
 
-    
+
 class BMAccount(object):
-    def __init__(self, address = None):
+    def __init__(self, address=None):
         self.address = address
         self.type = AccountMixin.NORMAL
         if BMConfigParser().has_section(address):
@@ -108,7 +114,7 @@ class BMAccount(object):
             if queryreturn:
                 self.type = AccountMixin.SUBSCRIPTION
 
-    def getLabel(self, address = None):
+    def getLabel(self, address=None):
         if address is None:
             address = self.address
         label = address
@@ -125,46 +131,48 @@ class BMAccount(object):
             if queryreturn != []:
                 for row in queryreturn:
                     label, = row
-        return label
-        
+        try:
+            return unicode(label, 'utf-8')
+        except TypeError:
+            print("WARNING: label is of type unicode:  %s" % label)
+            return label
+
     def parseMessage(self, toAddress, fromAddress, subject, message):
         self.toAddress = toAddress
         self.fromAddress = fromAddress
-        if isinstance(subject, unicode):
-            self.subject = str(subject)
-        else:
-            self.subject = subject
+        self.subject = subject
         self.message = message
         self.fromLabel = self.getLabel(fromAddress)
         self.toLabel = self.getLabel(toAddress)
 
 
 class NoAccount(BMAccount):
-    def __init__(self, address = None):
+    def __init__(self, address=None):
         self.address = address
         self.type = AccountMixin.NORMAL
 
-    def getLabel(self, address = None):
+    def getLabel(self, address=None):
         if address is None:
             address = self.address
         return address
 
-        
+
 class SubscriptionAccount(BMAccount):
     pass
-    
+
 
 class BroadcastAccount(BMAccount):
     pass
-        
-        
+
+
 class GatewayAccount(BMAccount):
     gatewayName = None
     ALL_OK = 0
     REGISTRATION_DENIED = 1
+
     def __init__(self, address):
         super(GatewayAccount, self).__init__(address)
-        
+
     def send(self):
         status, addressVersionNumber, streamNumber, ripe = decodeAddress(self.toAddress)
         stealthLevel = BMConfigParser().safeGetInt('bitmessagesettings', 'ackstealthlevel')
@@ -190,9 +198,7 @@ class GatewayAccount(BMAccount):
         )
 
         queues.workerQueue.put(('sendmessage', self.toAddress))
-    
-    def parseMessage(self, toAddress, fromAddress, subject, message):
-        super(GatewayAccount, self).parseMessage(toAddress, fromAddress, subject, message)
+
 
 class MailchuckAccount(GatewayAccount):
     # set "gateway" in keys.dat to this
@@ -202,23 +208,24 @@ class MailchuckAccount(GatewayAccount):
     relayAddress = "BM-2cWim8aZwUNqxzjMxstnUMtVEUQJeezstf"
     regExpIncoming = re.compile("(.*)MAILCHUCK-FROM::(\S+) \| (.*)")
     regExpOutgoing = re.compile("(\S+) (.*)")
+
     def __init__(self, address):
         super(MailchuckAccount, self).__init__(address)
         self.feedback = self.ALL_OK
-        
+
     def createMessage(self, toAddress, fromAddress, subject, message):
         self.subject = toAddress + " " + subject
         self.toAddress = self.relayAddress
         self.fromAddress = fromAddress
         self.message = message
-        
+
     def register(self, email):
         self.toAddress = self.registrationAddress
         self.subject = email
         self.message = ""
         self.fromAddress = self.address
         self.send()
-        
+
     def unregister(self):
         self.toAddress = self.unregistrationAddress
         self.subject = ""
@@ -255,7 +262,7 @@ class MailchuckAccount(GatewayAccount):
 #
 # attachments: no
 # Attachments will be ignored.
-# 
+#
 # archive: yes
 # Your incoming emails will be archived on the server. Use this if you need
 # help with debugging problems or you need a third party proof of emails. This
@@ -279,10 +286,12 @@ class MailchuckAccount(GatewayAccount):
         self.fromAddress = self.address
 
     def parseMessage(self, toAddress, fromAddress, subject, message):
-        super(MailchuckAccount, self).parseMessage(toAddress, fromAddress, subject, message)
+        super(MailchuckAccount, self).parseMessage(
+            toAddress, fromAddress, subject, message
+        )
         if fromAddress == self.relayAddress:
             matches = self.regExpIncoming.search(subject)
-            if not matches is None:
+            if matches is not None:
                 self.subject = ""
                 if not matches.group(1) is None:
                     self.subject += matches.group(1)
@@ -293,13 +302,14 @@ class MailchuckAccount(GatewayAccount):
                     self.fromAddress = matches.group(2)
         if toAddress == self.relayAddress:
             matches = self.regExpOutgoing.search(subject)
-            if not matches is None:
+            if matches is not None:
                 if not matches.group(2) is None:
                     self.subject = matches.group(2)
                 if not matches.group(1) is None:
                     self.toLabel = matches.group(1)
                     self.toAddress = matches.group(1)
         self.feedback = self.ALL_OK
-        if fromAddress == self.registrationAddress and self.subject == "Registration Request Denied":
+        if fromAddress == self.registrationAddress \
+                and self.subject == "Registration Request Denied":
             self.feedback = self.REGISTRATION_DENIED
         return self.feedback
diff --git a/src/bitmessageqt/address_dialogs.py b/src/bitmessageqt/address_dialogs.py
index 2ea5cef..b53ebc4 100644
--- a/src/bitmessageqt/address_dialogs.py
+++ b/src/bitmessageqt/address_dialogs.py
@@ -1,4 +1,4 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtGui, QtWidgets
 from addresses import decodeAddress, encodeVarint, addBMIfNotPresent
 from account import (
     GatewayAccount, MailchuckAccount, AccountMixin, accountClass,
@@ -15,17 +15,15 @@ from inventory import Inventory
 
 class AddressCheckMixin(object):
 
-    def __init__(self):
+    def _setup(self):
         self.valid = False
-        QtCore.QObject.connect(self.lineEditAddress, QtCore.SIGNAL(
-            "textChanged(QString)"), self.addressChanged)
+        self.lineEditAddress.textChanged.connect(self.addressChanged)
 
     def _onSuccess(self, addressVersion, streamNumber, ripe):
         pass
 
-    def addressChanged(self, QString):
-        status, addressVersion, streamNumber, ripe = decodeAddress(
-            str(QString))
+    def addressChanged(self, address):
+        status, addressVersion, streamNumber, ripe = decodeAddress(address)
         self.valid = status == 'success'
         if self.valid:
             self.labelAddressCheck.setText(
@@ -70,7 +68,7 @@ class AddressCheckMixin(object):
             ))
 
 
-class AddressDataDialog(QtGui.QDialog, AddressCheckMixin):
+class AddressDataDialog(QtWidgets.QDialog, AddressCheckMixin):
     def __init__(self, parent):
         super(AddressDataDialog, self).__init__(parent)
         self.parent = parent
@@ -79,7 +77,7 @@ class AddressDataDialog(QtGui.QDialog, AddressCheckMixin):
         if self.valid:
             self.data = (
                 addBMIfNotPresent(str(self.lineEditAddress.text())),
-                str(self.lineEditLabel.text().toUtf8())
+                self.lineEditLabel.text().encode('utf-8')
             )
         else:
             queues.UISignalQueue.put(('updateStatusBar', _translate(
@@ -94,12 +92,12 @@ class AddAddressDialog(AddressDataDialog, RetranslateMixin):
     def __init__(self, parent=None, address=None):
         super(AddAddressDialog, self).__init__(parent)
         widgets.load('addaddressdialog.ui', self)
-        AddressCheckMixin.__init__(self)
+        self._setup()
         if address:
             self.lineEditAddress.setText(address)
 
 
-class NewAddressDialog(QtGui.QDialog, RetranslateMixin):
+class NewAddressDialog(QtWidgets.QDialog, RetranslateMixin):
 
     def __init__(self, parent=None):
         super(NewAddressDialog, self).__init__(parent)
@@ -111,7 +109,7 @@ class NewAddressDialog(QtGui.QDialog, RetranslateMixin):
             self.radioButtonExisting.click()
             self.comboBoxExisting.addItem(address)
         self.groupBoxDeterministic.setHidden(True)
-        QtGui.QWidget.resize(self, QtGui.QWidget.sizeHint(self))
+        QtWidgets.QWidget.resize(self, QtWidgets.QWidget.sizeHint(self))
         self.show()
 
     def accept(self):
@@ -127,13 +125,13 @@ class NewAddressDialog(QtGui.QDialog, RetranslateMixin):
                     self.comboBoxExisting.currentText())[2]
             queues.addressGeneratorQueue.put((
                 'createRandomAddress', 4, streamNumberForAddress,
-                str(self.newaddresslabel.text().toUtf8()), 1, "",
+                self.newaddresslabel.text().encode('utf-8'), 1, "",
                 self.checkBoxEighteenByteRipe.isChecked()
             ))
         else:
             if self.lineEditPassphrase.text() != \
                     self.lineEditPassphraseAgain.text():
-                QtGui.QMessageBox.about(
+                QtWidgets.QMessageBox.about(
                     self, _translate("MainWindow", "Passphrase mismatch"),
                     _translate(
                         "MainWindow",
@@ -141,7 +139,7 @@ class NewAddressDialog(QtGui.QDialog, RetranslateMixin):
                         " match. Try again.")
                 )
             elif self.lineEditPassphrase.text() == "":
-                QtGui.QMessageBox.about(
+                QtWidgets.QMessageBox.about(
                     self, _translate("MainWindow", "Choose a passphrase"),
                     _translate(
                         "MainWindow", "You really do need a passphrase.")
@@ -154,7 +152,7 @@ class NewAddressDialog(QtGui.QDialog, RetranslateMixin):
                     'createDeterministicAddresses', 4, streamNumberForAddress,
                     "unused deterministic address",
                     self.spinBoxNumberOfAddressesToMake.value(),
-                    self.lineEditPassphrase.text().toUtf8(),
+                    self.lineEditPassphrase.text(),
                     self.checkBoxEighteenByteRipe.isChecked()
                 ))
 
@@ -164,7 +162,7 @@ class NewSubscriptionDialog(AddressDataDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(NewSubscriptionDialog, self).__init__(parent)
         widgets.load('newsubscriptiondialog.ui', self)
-        AddressCheckMixin.__init__(self)
+        self._setup()
 
     def _onSuccess(self, addressVersion, streamNumber, ripe):
         if addressVersion <= 3:
@@ -195,21 +193,19 @@ class NewSubscriptionDialog(AddressDataDialog, RetranslateMixin):
                     _translate(
                         "MainWindow",
                         "Display the %n recent broadcast(s) from this address.",
-                        None,
-                        QtCore.QCoreApplication.CodecForTr,
-                        count
+                        None, count
                     ))
 
 
-class RegenerateAddressesDialog(QtGui.QDialog, RetranslateMixin):
+class RegenerateAddressesDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(RegenerateAddressesDialog, self).__init__(parent)
         widgets.load('regenerateaddresses.ui', self)
         self.groupBox.setTitle('')
-        QtGui.QWidget.resize(self, QtGui.QWidget.sizeHint(self))
+        QtWidgets.QWidget.resize(self, QtWidgets.QWidget.sizeHint(self))
 
 
-class SpecialAddressBehaviorDialog(QtGui.QDialog, RetranslateMixin):
+class SpecialAddressBehaviorDialog(QtWidgets.QDialog, RetranslateMixin):
 
     def __init__(self, parent=None, config=None):
         super(SpecialAddressBehaviorDialog, self).__init__(parent)
@@ -246,7 +242,7 @@ class SpecialAddressBehaviorDialog(QtGui.QDialog, RetranslateMixin):
                     unicode(mailingListName, 'utf-8')
                 )
 
-        QtGui.QWidget.resize(self, QtGui.QWidget.sizeHint(self))
+        QtWidgets.QWidget.resize(self, QtWidgets.QWidget.sizeHint(self))
         self.show()
 
     def accept(self):
@@ -258,14 +254,15 @@ class SpecialAddressBehaviorDialog(QtGui.QDialog, RetranslateMixin):
             # Set the color to either black or grey
             if self.config.getboolean(self.address, 'enabled'):
                 self.parent.setCurrentItemColor(
-                    QtGui.QApplication.palette().text().color()
+                    QtWidgets.QApplication.palette().text().color()
                 )
             else:
                 self.parent.setCurrentItemColor(QtGui.QColor(128, 128, 128))
         else:
             self.config.set(str(self.address), 'mailinglist', 'true')
-            self.config.set(str(self.address), 'mailinglistname', str(
-                self.lineEditMailingListName.text().toUtf8()))
+            self.config.set(
+                str(self.address), 'mailinglistname',
+                self.lineEditMailingListName.text().encode('utf-8'))
             self.parent.setCurrentItemColor(
                 QtGui.QColor(137, 04, 177))  # magenta
         self.parent.rerenderComboBoxSendFrom()
@@ -274,7 +271,7 @@ class SpecialAddressBehaviorDialog(QtGui.QDialog, RetranslateMixin):
         self.parent.rerenderMessagelistToLabels()
 
 
-class EmailGatewayDialog(QtGui.QDialog, RetranslateMixin):
+class EmailGatewayDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent, config=None, account=None):
         super(EmailGatewayDialog, self).__init__(parent)
         widgets.load('emailgateway.ui', self)
@@ -312,7 +309,7 @@ class EmailGatewayDialog(QtGui.QDialog, RetranslateMixin):
             else:
                 self.acct = MailchuckAccount(address)
         self.lineEditEmail.setFocus()
-        QtGui.QWidget.resize(self, QtGui.QWidget.sizeHint(self))
+        QtWidgets.QWidget.resize(self, QtWidgets.QWidget.sizeHint(self))
 
     def accept(self):
         self.hide()
@@ -325,7 +322,7 @@ class EmailGatewayDialog(QtGui.QDialog, RetranslateMixin):
 
         if self.radioButtonRegister.isChecked() \
                 or self.radioButtonRegister.isHidden():
-            email = str(self.lineEditEmail.text().toUtf8())
+            email = self.lineEditEmail.text().encode('utf-8')
             self.acct.register(email)
             self.config.set(self.acct.fromAddress, 'label', email)
             self.config.set(self.acct.fromAddress, 'gateway', 'mailchuck')
diff --git a/src/bitmessageqt/addressvalidator.py b/src/bitmessageqt/addressvalidator.py
index f9de70a..b0c0c22 100644
--- a/src/bitmessageqt/addressvalidator.py
+++ b/src/bitmessageqt/addressvalidator.py
@@ -1,4 +1,4 @@
-from PyQt4 import QtGui
+from qtpy import QtGui
 from Queue import Empty
 
 from addresses import decodeAddress, addBMIfNotPresent
@@ -7,16 +7,22 @@ from queues import apiAddressGeneratorReturnQueue, addressGeneratorQueue
 from tr import _translate
 from utils import str_chan
 
-class AddressPassPhraseValidatorMixin():
-    def setParams(self, passPhraseObject=None, addressObject=None, feedBackObject=None, buttonBox=None, addressMandatory=True):
+from debug import logger
+
+
+class AddressPassPhraseValidatorMixin(object):
+    def setParams(
+        self, passPhraseObject=None, addressObject=None,
+        feedBackObject=None, button=None, addressMandatory=True
+    ):
         self.addressObject = addressObject
         self.passPhraseObject = passPhraseObject
         self.feedBackObject = feedBackObject
-        self.buttonBox = buttonBox
         self.addressMandatory = addressMandatory
         self.isValid = False
         # save default text
-        self.okButtonLabel = self.buttonBox.button(QtGui.QDialogButtonBox.Ok).text()
+        self.okButton = button
+        self.okButtonLabel = button.text()
 
     def setError(self, string):
         if string is not None and self.feedBackObject is not None:
@@ -26,12 +32,14 @@ class AddressPassPhraseValidatorMixin():
             self.feedBackObject.setStyleSheet("QLabel { color : red; }")
             self.feedBackObject.setText(string)
         self.isValid = False
-        if self.buttonBox:
-            self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setEnabled(False)
+        if self.okButton:
+            self.okButton.setEnabled(False)
             if string is not None and self.feedBackObject is not None:
-                self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setText(_translate("AddressValidator", "Invalid"))
+                self.okButton.setText(
+                    _translate("AddressValidator", "Invalid"))
             else:
-                self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setText(_translate("AddressValidator", "Validating..."))
+                self.okButton.setText(
+                    _translate("AddressValidator", "Validating..."))
 
     def setOK(self, string):
         if string is not None and self.feedBackObject is not None:
@@ -41,9 +49,9 @@ class AddressPassPhraseValidatorMixin():
             self.feedBackObject.setStyleSheet("QLabel { }")
             self.feedBackObject.setText(string)
         self.isValid = True
-        if self.buttonBox:
-            self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setEnabled(True)
-            self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setText(self.okButtonLabel)
+        if self.okButton:
+            self.okButton.setEnabled(True)
+            self.okButton.setText(self.okButtonLabel)
 
     def checkQueue(self):
         gotOne = False
@@ -55,7 +63,8 @@ class AddressPassPhraseValidatorMixin():
 
         while True:
             try:
-                addressGeneratorReturnValue = apiAddressGeneratorReturnQueue.get(False)
+                addressGeneratorReturnValue = \
+                    apiAddressGeneratorReturnQueue.get(False)
             except Empty:
                 if gotOne:
                     break
@@ -65,80 +74,132 @@ class AddressPassPhraseValidatorMixin():
                 gotOne = True
 
         if len(addressGeneratorReturnValue) == 0:
-            self.setError(_translate("AddressValidator", "Address already present as one of your identities."))
-            return (QtGui.QValidator.Intermediate, 0)
-        if addressGeneratorReturnValue[0] == 'chan name does not match address':
-            self.setError(_translate("AddressValidator", "Although the Bitmessage address you entered was valid, it doesn\'t match the chan name."))
-            return (QtGui.QValidator.Intermediate, 0)
-        self.setOK(_translate("MainWindow", "Passphrase and address appear to be valid."))
+            self.setError(
+                _translate(
+                    "AddressValidator",
+                    "Address already present as one of your identities."
+                ))
+            return
+        if addressGeneratorReturnValue[0] == \
+                'chan name does not match address':
+            self.setError(
+                _translate(
+                    "AddressValidator",
+                    "Although the Bitmessage address you entered was"
+                    " valid, it doesn\'t match the chan name."
+                ))
+            return
+        self.setOK(
+            _translate(
+                "MainWindow", "Passphrase and address appear to be valid."))
 
     def returnValid(self):
-        if self.isValid:
-            return QtGui.QValidator.Acceptable
-        else:
-            return QtGui.QValidator.Intermediate
+        return QtGui.QValidator.Acceptable if self.isValid \
+            else QtGui.QValidator.Intermediate
 
     def validate(self, s, pos):
         if self.addressObject is None:
             address = None
         else:
-            address = str(self.addressObject.text().toUtf8())
+            address = self.addressObject.text().encode('utf-8')
             if address == "":
                 address = None
         if self.passPhraseObject is None:
             passPhrase = ""
         else:
-            passPhrase = str(self.passPhraseObject.text().toUtf8())
+            passPhrase = self.passPhraseObject.text().encode('utf-8')
             if passPhrase == "":
                 passPhrase = None
 
         # no chan name
         if passPhrase is None:
-            self.setError(_translate("AddressValidator", "Chan name/passphrase needed. You didn't enter a chan name."))
-            return (QtGui.QValidator.Intermediate, pos)
+            self.setError(
+                _translate(
+                    "AddressValidator",
+                    "Chan name/passphrase needed."
+                    " You didn't enter a chan name."
+                ))
+            return (QtGui.QValidator.Intermediate, s, pos)
 
         if self.addressMandatory or address is not None:
             # check if address already exists:
             if address in getSortedAccounts():
-                self.setError(_translate("AddressValidator", "Address already present as one of your identities."))
-                return (QtGui.QValidator.Intermediate, pos)
+                self.setError(
+                    _translate(
+                        "AddressValidator",
+                        "Address already present as one of your identities."
+                    ))
+                return (QtGui.QValidator.Intermediate, s, pos)
 
             # version too high
             if decodeAddress(address)[0] == 'versiontoohigh':
-                self.setError(_translate("AddressValidator", "Address too new. Although that Bitmessage address might be valid, its version number is too new for us to handle. Perhaps you need to upgrade Bitmessage."))
-                return (QtGui.QValidator.Intermediate, pos)
-    
+                self.setError(
+                    _translate(
+                        "AddressValidator",
+                        "Address too new. Although that Bitmessage address"
+                        " might be valid, its version number is too new"
+                        " for us to handle. Perhaps you need to upgrade"
+                        " Bitmessage."
+                    ))
+                return (QtGui.QValidator.Intermediate, s, pos)
+
             # invalid
             if decodeAddress(address)[0] != 'success':
-                self.setError(_translate("AddressValidator", "The Bitmessage address is not valid."))
-                return (QtGui.QValidator.Intermediate, pos)
+                self.setError(
+                    _translate(
+                        "AddressValidator",
+                        "The Bitmessage address is not valid."
+                    ))
+                return (QtGui.QValidator.Intermediate, s, pos)
 
         # this just disables the OK button without changing the feedback text
         # but only if triggered by textEdited, not by clicking the Ok button
-        if not self.buttonBox.button(QtGui.QDialogButtonBox.Ok).hasFocus():
+        if not self.okButton.hasFocus():
             self.setError(None)
 
         # check through generator
         if address is None:
-            addressGeneratorQueue.put(('createChan', 4, 1, str_chan + ' ' + str(passPhrase), passPhrase, False))
+            addressGeneratorQueue.put((
+                'createChan', 4, 1, ' '.join([str_chan, passPhrase]),
+                passPhrase, False
+            ))
         else:
-            addressGeneratorQueue.put(('joinChan', addBMIfNotPresent(address), str_chan + ' ' + str(passPhrase), passPhrase, False))
+            addressGeneratorQueue.put((
+                'joinChan', addBMIfNotPresent(address),
+                ' '.join([str_chan, passPhrase]), passPhrase, False
+            ))
 
-        if self.buttonBox.button(QtGui.QDialogButtonBox.Ok).hasFocus():
-            return (self.returnValid(), pos)
+        if self.okButton.hasFocus():
+            return (self.returnValid(), s, pos)
         else:
-            return (QtGui.QValidator.Intermediate, pos)
+            return (QtGui.QValidator.Intermediate, s, pos)
 
     def checkData(self):
-        return self.validate("", 0)
+        try:
+            return self.validate(u"", 0)
+        except Exception:
+            logger.warning("Exception in validate():", exc_info=True)
+
 
 class AddressValidator(QtGui.QValidator, AddressPassPhraseValidatorMixin):
-    def __init__(self, parent=None, passPhraseObject=None, feedBackObject=None, buttonBox=None, addressMandatory=True):
+    def __init__(
+        self, parent=None, passPhraseObject=None, feedBackObject=None,
+        button=None, addressMandatory=True
+    ):
         super(AddressValidator, self).__init__(parent)
-        self.setParams(passPhraseObject, parent, feedBackObject, buttonBox, addressMandatory)
+        self.setParams(
+            passPhraseObject, parent, feedBackObject, button,
+            addressMandatory
+        )
 
 
 class PassPhraseValidator(QtGui.QValidator, AddressPassPhraseValidatorMixin):
-    def __init__(self, parent=None, addressObject=None, feedBackObject=None, buttonBox=None, addressMandatory=False):
+    def __init__(
+        self, parent=None, addressObject=None, feedBackObject=None,
+        button=None, addressMandatory=False
+    ):
         super(PassPhraseValidator, self).__init__(parent)
-        self.setParams(parent, addressObject, feedBackObject, buttonBox, addressMandatory)
+        self.setParams(
+            parent, addressObject, feedBackObject, button,
+            addressMandatory
+        )
diff --git a/src/bitmessageqt/bitmessage_icons_rc.py b/src/bitmessageqt/bitmessage_icons_rc.py
index bb0a02c..6840474 100644
--- a/src/bitmessageqt/bitmessage_icons_rc.py
+++ b/src/bitmessageqt/bitmessage_icons_rc.py
@@ -7,7 +7,7 @@
 #
 # WARNING! All changes made in this file will be lost!
 
-from PyQt4 import QtCore
+from qtpy import QtCore
 
 qt_resource_data = "\
 \x00\x00\x03\x66\
@@ -1666,10 +1666,15 @@ qt_resource_struct = "\
 \x00\x00\x01\xe6\x00\x00\x00\x00\x00\x01\x00\x00\x34\xdf\
 "
 
+
 def qInitResources():
-    QtCore.qRegisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
+    QtCore.qRegisterResourceData(
+        0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
+
 
 def qCleanupResources():
-    QtCore.qUnregisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
+    QtCore.qUnregisterResourceData(
+        0x01, qt_resource_struct, qt_resource_name, qt_resource_data)
+
 
 qInitResources()
diff --git a/src/bitmessageqt/bitmessageui.py b/src/bitmessageqt/bitmessageui.py
index cb3578c..d154e22 100644
--- a/src/bitmessageqt/bitmessageui.py
+++ b/src/bitmessageqt/bitmessageui.py
@@ -1,13 +1,5 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'bitmessageui.ui'
-#
-# Created: Mon Mar 23 22:18:07 2015
-#      by: PyQt4 UI code generator 4.10.4
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
+from tr import _translate
 from bmconfigparser import BMConfigParser
 from foldertree import AddressBookCompleter
 from messageview import MessageView
@@ -16,40 +8,23 @@ import settingsmixin
 from networkstatus import NetworkStatus
 from blacklist import Blacklist
 
-try:
-    _fromUtf8 = QtCore.QString.fromUtf8
-except AttributeError:
-    def _fromUtf8(s):
-        return s
+import bitmessage_icons_rc
 
-try:
-    _encoding = QtGui.QApplication.UnicodeUTF8
-    def _translate(context, text, disambig, encoding = QtCore.QCoreApplication.CodecForTr, n = None):
-        if n is None:
-            return QtGui.QApplication.translate(context, text, disambig, _encoding)
-        else:
-            return QtGui.QApplication.translate(context, text, disambig, _encoding, n)
-except AttributeError:
-    def _translate(context, text, disambig, encoding = QtCore.QCoreApplication.CodecForTr, n = None):
-        if n is None:
-            return QtGui.QApplication.translate(context, text, disambig)
-        else:
-            return QtGui.QApplication.translate(context, text, disambig, QtCore.QCoreApplication.CodecForTr, n)
 
 class Ui_MainWindow(object):
     def setupUi(self, MainWindow):
-        MainWindow.setObjectName(_fromUtf8("MainWindow"))
+        MainWindow.setObjectName("MainWindow")
         MainWindow.resize(885, 580)
         icon = QtGui.QIcon()
-        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/can-icon-24px.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
+        icon.addPixmap(QtGui.QPixmap(":/newPrefix/images/can-icon-24px.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
         MainWindow.setWindowIcon(icon)
-        MainWindow.setTabShape(QtGui.QTabWidget.Rounded)
-        self.centralwidget = QtGui.QWidget(MainWindow)
-        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
-        self.gridLayout_10 = QtGui.QGridLayout(self.centralwidget)
-        self.gridLayout_10.setObjectName(_fromUtf8("gridLayout_10"))
-        self.tabWidget = QtGui.QTabWidget(self.centralwidget)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
+        MainWindow.setTabShape(QtWidgets.QTabWidget.Rounded)
+        self.centralwidget = QtWidgets.QWidget(MainWindow)
+        self.centralwidget.setObjectName("centralwidget")
+        self.gridLayout_10 = QtWidgets.QGridLayout(self.centralwidget)
+        self.gridLayout_10.setObjectName("gridLayout_10")
+        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
@@ -59,27 +34,27 @@ class Ui_MainWindow(object):
         font = QtGui.QFont()
         font.setPointSize(9)
         self.tabWidget.setFont(font)
-        self.tabWidget.setTabPosition(QtGui.QTabWidget.North)
-        self.tabWidget.setTabShape(QtGui.QTabWidget.Rounded)
-        self.tabWidget.setObjectName(_fromUtf8("tabWidget"))
-        self.inbox = QtGui.QWidget()
-        self.inbox.setObjectName(_fromUtf8("inbox"))
-        self.gridLayout = QtGui.QGridLayout(self.inbox)
-        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
+        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.North)
+        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
+        self.tabWidget.setObjectName("tabWidget")
+        self.inbox = QtWidgets.QWidget()
+        self.inbox.setObjectName("inbox")
+        self.gridLayout = QtWidgets.QGridLayout(self.inbox)
+        self.gridLayout.setObjectName("gridLayout")
         self.horizontalSplitter_3 = settingsmixin.SSplitter()
-        self.horizontalSplitter_3.setObjectName(_fromUtf8("horizontalSplitter_3"))
+        self.horizontalSplitter_3.setObjectName("horizontalSplitter_3")
         self.verticalSplitter_12 = settingsmixin.SSplitter()
-        self.verticalSplitter_12.setObjectName(_fromUtf8("verticalSplitter_12"))
+        self.verticalSplitter_12.setObjectName("verticalSplitter_12")
         self.verticalSplitter_12.setOrientation(QtCore.Qt.Vertical)
         self.treeWidgetYourIdentities = settingsmixin.STreeWidget(self.inbox)
-        self.treeWidgetYourIdentities.setObjectName(_fromUtf8("treeWidgetYourIdentities"))
+        self.treeWidgetYourIdentities.setObjectName("treeWidgetYourIdentities")
         self.treeWidgetYourIdentities.resize(200, self.treeWidgetYourIdentities.height())
         icon1 = QtGui.QIcon()
-        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/identities.png")), QtGui.QIcon.Selected, QtGui.QIcon.Off)
+        icon1.addPixmap(QtGui.QPixmap(":/newPrefix/images/identities.png"), QtGui.QIcon.Selected, QtGui.QIcon.Off)
         self.treeWidgetYourIdentities.headerItem().setIcon(0, icon1)
         self.verticalSplitter_12.addWidget(self.treeWidgetYourIdentities)
-        self.pushButtonNewAddress = QtGui.QPushButton(self.inbox)
-        self.pushButtonNewAddress.setObjectName(_fromUtf8("pushButtonNewAddress"))
+        self.pushButtonNewAddress = QtWidgets.QPushButton(self.inbox)
+        self.pushButtonNewAddress.setObjectName("pushButtonNewAddress")
         self.pushButtonNewAddress.resize(200, self.pushButtonNewAddress.height())
         self.verticalSplitter_12.addWidget(self.pushButtonNewAddress)
         self.verticalSplitter_12.setStretchFactor(0, 1)
@@ -89,42 +64,42 @@ class Ui_MainWindow(object):
         self.verticalSplitter_12.handle(1).setEnabled(False)
         self.horizontalSplitter_3.addWidget(self.verticalSplitter_12)
         self.verticalSplitter_7 = settingsmixin.SSplitter()
-        self.verticalSplitter_7.setObjectName(_fromUtf8("verticalSplitter_7"))
+        self.verticalSplitter_7.setObjectName("verticalSplitter_7")
         self.verticalSplitter_7.setOrientation(QtCore.Qt.Vertical)
-        self.horizontalSplitterSearch = QtGui.QSplitter()
-        self.horizontalSplitterSearch.setObjectName(_fromUtf8("horizontalSplitterSearch"))
-        self.inboxSearchLineEdit = QtGui.QLineEdit(self.inbox)
-        self.inboxSearchLineEdit.setObjectName(_fromUtf8("inboxSearchLineEdit"))
+        self.horizontalSplitterSearch = QtWidgets.QSplitter()
+        self.horizontalSplitterSearch.setObjectName("horizontalSplitterSearch")
+        self.inboxSearchLineEdit = QtWidgets.QLineEdit(self.inbox)
+        self.inboxSearchLineEdit.setObjectName("inboxSearchLineEdit")
         self.horizontalSplitterSearch.addWidget(self.inboxSearchLineEdit)
-        self.inboxSearchOption = QtGui.QComboBox(self.inbox)
-        self.inboxSearchOption.setObjectName(_fromUtf8("inboxSearchOption"))
-        self.inboxSearchOption.addItem(_fromUtf8(""))
-        self.inboxSearchOption.addItem(_fromUtf8(""))
-        self.inboxSearchOption.addItem(_fromUtf8(""))
-        self.inboxSearchOption.addItem(_fromUtf8(""))
-        self.inboxSearchOption.addItem(_fromUtf8(""))
-        self.inboxSearchOption.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)
+        self.inboxSearchOption = QtWidgets.QComboBox(self.inbox)
+        self.inboxSearchOption.setObjectName("inboxSearchOption")
+        self.inboxSearchOption.addItem("")
+        self.inboxSearchOption.addItem("")
+        self.inboxSearchOption.addItem("")
+        self.inboxSearchOption.addItem("")
+        self.inboxSearchOption.addItem("")
+        self.inboxSearchOption.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
         self.horizontalSplitterSearch.addWidget(self.inboxSearchOption)
         self.horizontalSplitterSearch.handle(1).setEnabled(False)
         self.horizontalSplitterSearch.setStretchFactor(0, 1)
         self.horizontalSplitterSearch.setStretchFactor(1, 0)
         self.verticalSplitter_7.addWidget(self.horizontalSplitterSearch)
         self.tableWidgetInbox = settingsmixin.STableWidget(self.inbox)
-        self.tableWidgetInbox.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
+        self.tableWidgetInbox.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
         self.tableWidgetInbox.setAlternatingRowColors(True)
-        self.tableWidgetInbox.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
-        self.tableWidgetInbox.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
+        self.tableWidgetInbox.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
+        self.tableWidgetInbox.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
         self.tableWidgetInbox.setWordWrap(False)
-        self.tableWidgetInbox.setObjectName(_fromUtf8("tableWidgetInbox"))
+        self.tableWidgetInbox.setObjectName("tableWidgetInbox")
         self.tableWidgetInbox.setColumnCount(4)
         self.tableWidgetInbox.setRowCount(0)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInbox.setHorizontalHeaderItem(0, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInbox.setHorizontalHeaderItem(1, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInbox.setHorizontalHeaderItem(2, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInbox.setHorizontalHeaderItem(3, item)
         self.tableWidgetInbox.horizontalHeader().setCascadingSectionResizes(True)
         self.tableWidgetInbox.horizontalHeader().setDefaultSectionSize(200)
@@ -138,7 +113,7 @@ class Ui_MainWindow(object):
         self.textEditInboxMessage = MessageView(self.inbox)
         self.textEditInboxMessage.setBaseSize(QtCore.QSize(0, 500))
         self.textEditInboxMessage.setReadOnly(True)
-        self.textEditInboxMessage.setObjectName(_fromUtf8("textEditInboxMessage"))
+        self.textEditInboxMessage.setObjectName("textEditInboxMessage")
         self.verticalSplitter_7.addWidget(self.textEditInboxMessage)
         self.verticalSplitter_7.setStretchFactor(0, 0)
         self.verticalSplitter_7.setStretchFactor(1, 1)
@@ -154,31 +129,31 @@ class Ui_MainWindow(object):
         self.horizontalSplitter_3.setCollapsible(1, False)
         self.gridLayout.addWidget(self.horizontalSplitter_3)
         icon2 = QtGui.QIcon()
-        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/inbox.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
-        self.tabWidget.addTab(self.inbox, icon2, _fromUtf8(""))
-        self.send = QtGui.QWidget()
-        self.send.setObjectName(_fromUtf8("send"))
-        self.gridLayout_7 = QtGui.QGridLayout(self.send)
-        self.gridLayout_7.setObjectName(_fromUtf8("gridLayout_7"))
+        icon2.addPixmap(QtGui.QPixmap(":/newPrefix/images/inbox.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
+        self.tabWidget.addTab(self.inbox, icon2, "")
+        self.send = QtWidgets.QWidget()
+        self.send.setObjectName("send")
+        self.gridLayout_7 = QtWidgets.QGridLayout(self.send)
+        self.gridLayout_7.setObjectName("gridLayout_7")
         self.horizontalSplitter = settingsmixin.SSplitter()
-        self.horizontalSplitter.setObjectName(_fromUtf8("horizontalSplitter"))
+        self.horizontalSplitter.setObjectName("horizontalSplitter")
         self.verticalSplitter_2 = settingsmixin.SSplitter()
-        self.verticalSplitter_2.setObjectName(_fromUtf8("verticalSplitter_2"))
+        self.verticalSplitter_2.setObjectName("verticalSplitter_2")
         self.verticalSplitter_2.setOrientation(QtCore.Qt.Vertical)
         self.tableWidgetAddressBook = settingsmixin.STableWidget(self.send)
         self.tableWidgetAddressBook.setAlternatingRowColors(True)
-        self.tableWidgetAddressBook.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
-        self.tableWidgetAddressBook.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
-        self.tableWidgetAddressBook.setObjectName(_fromUtf8("tableWidgetAddressBook"))
+        self.tableWidgetAddressBook.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
+        self.tableWidgetAddressBook.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
+        self.tableWidgetAddressBook.setObjectName("tableWidgetAddressBook")
         self.tableWidgetAddressBook.setColumnCount(2)
         self.tableWidgetAddressBook.setRowCount(0)
         self.tableWidgetAddressBook.resize(200, self.tableWidgetAddressBook.height())
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         icon3 = QtGui.QIcon()
-        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/addressbook.png")), QtGui.QIcon.Selected, QtGui.QIcon.Off)
+        icon3.addPixmap(QtGui.QPixmap(":/newPrefix/images/addressbook.png"), QtGui.QIcon.Selected, QtGui.QIcon.Off)
         item.setIcon(icon3)
         self.tableWidgetAddressBook.setHorizontalHeaderItem(0, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetAddressBook.setHorizontalHeaderItem(1, item)
         self.tableWidgetAddressBook.horizontalHeader().setCascadingSectionResizes(True)
         self.tableWidgetAddressBook.horizontalHeader().setDefaultSectionSize(200)
@@ -187,17 +162,17 @@ class Ui_MainWindow(object):
         self.tableWidgetAddressBook.verticalHeader().setVisible(False)
         self.verticalSplitter_2.addWidget(self.tableWidgetAddressBook)
         self.addressBookCompleter = AddressBookCompleter()
-        self.addressBookCompleter.setCompletionMode(QtGui.QCompleter.PopupCompletion)
+        self.addressBookCompleter.setCompletionMode(QtWidgets.QCompleter.PopupCompletion)
         self.addressBookCompleter.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
-        self.addressBookCompleterModel = QtGui.QStringListModel()
+        self.addressBookCompleterModel = QtCore.QStringListModel()
         self.addressBookCompleter.setModel(self.addressBookCompleterModel)
-        self.pushButtonAddAddressBook = QtGui.QPushButton(self.send)
-        self.pushButtonAddAddressBook.setObjectName(_fromUtf8("pushButtonAddAddressBook"))
+        self.pushButtonAddAddressBook = QtWidgets.QPushButton(self.send)
+        self.pushButtonAddAddressBook.setObjectName("pushButtonAddAddressBook")
         self.pushButtonAddAddressBook.resize(200, self.pushButtonAddAddressBook.height())
         self.verticalSplitter_2.addWidget(self.pushButtonAddAddressBook)
-        self.pushButtonFetchNamecoinID = QtGui.QPushButton(self.send)
+        self.pushButtonFetchNamecoinID = QtWidgets.QPushButton(self.send)
         self.pushButtonFetchNamecoinID.resize(200, self.pushButtonFetchNamecoinID.height())
-        self.pushButtonFetchNamecoinID.setObjectName(_fromUtf8("pushButtonFetchNamecoinID"))
+        self.pushButtonFetchNamecoinID.setObjectName("pushButtonFetchNamecoinID")
         self.verticalSplitter_2.addWidget(self.pushButtonFetchNamecoinID)
         self.verticalSplitter_2.setStretchFactor(0, 1)
         self.verticalSplitter_2.setStretchFactor(1, 0)
@@ -209,45 +184,45 @@ class Ui_MainWindow(object):
         self.verticalSplitter_2.handle(2).setEnabled(False)
         self.horizontalSplitter.addWidget(self.verticalSplitter_2)
         self.verticalSplitter = settingsmixin.SSplitter()
-        self.verticalSplitter.setObjectName(_fromUtf8("verticalSplitter"))
+        self.verticalSplitter.setObjectName("verticalSplitter")
         self.verticalSplitter.setOrientation(QtCore.Qt.Vertical)
-        self.tabWidgetSend = QtGui.QTabWidget(self.send)
-        self.tabWidgetSend.setObjectName(_fromUtf8("tabWidgetSend"))
-        self.sendDirect = QtGui.QWidget()
-        self.sendDirect.setObjectName(_fromUtf8("sendDirect"))
-        self.gridLayout_8 = QtGui.QGridLayout(self.sendDirect)
-        self.gridLayout_8.setObjectName(_fromUtf8("gridLayout_8"))
+        self.tabWidgetSend = QtWidgets.QTabWidget(self.send)
+        self.tabWidgetSend.setObjectName("tabWidgetSend")
+        self.sendDirect = QtWidgets.QWidget()
+        self.sendDirect.setObjectName("sendDirect")
+        self.gridLayout_8 = QtWidgets.QGridLayout(self.sendDirect)
+        self.gridLayout_8.setObjectName("gridLayout_8")
         self.verticalSplitter_5 = settingsmixin.SSplitter()
-        self.verticalSplitter_5.setObjectName(_fromUtf8("verticalSplitter_5"))
+        self.verticalSplitter_5.setObjectName("verticalSplitter_5")
         self.verticalSplitter_5.setOrientation(QtCore.Qt.Vertical)
-        self.gridLayout_2 = QtGui.QGridLayout()
-        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
-        self.label_3 = QtGui.QLabel(self.sendDirect)
-        self.label_3.setObjectName(_fromUtf8("label_3"))
+        self.gridLayout_2 = QtWidgets.QGridLayout()
+        self.gridLayout_2.setObjectName("gridLayout_2")
+        self.label_3 = QtWidgets.QLabel(self.sendDirect)
+        self.label_3.setObjectName("label_3")
         self.gridLayout_2.addWidget(self.label_3, 2, 0, 1, 1)
-        self.label_2 = QtGui.QLabel(self.sendDirect)
-        self.label_2.setObjectName(_fromUtf8("label_2"))
+        self.label_2 = QtWidgets.QLabel(self.sendDirect)
+        self.label_2.setObjectName("label_2")
         self.gridLayout_2.addWidget(self.label_2, 0, 0, 1, 1)
-        self.lineEditSubject = QtGui.QLineEdit(self.sendDirect)
-        self.lineEditSubject.setText(_fromUtf8(""))
-        self.lineEditSubject.setObjectName(_fromUtf8("lineEditSubject"))
+        self.lineEditSubject = QtWidgets.QLineEdit(self.sendDirect)
+        self.lineEditSubject.setText("")
+        self.lineEditSubject.setObjectName("lineEditSubject")
         self.gridLayout_2.addWidget(self.lineEditSubject, 2, 1, 1, 1)
-        self.label = QtGui.QLabel(self.sendDirect)
-        self.label.setObjectName(_fromUtf8("label"))
+        self.label = QtWidgets.QLabel(self.sendDirect)
+        self.label.setObjectName("label")
         self.gridLayout_2.addWidget(self.label, 1, 0, 1, 1)
-        self.comboBoxSendFrom = QtGui.QComboBox(self.sendDirect)
+        self.comboBoxSendFrom = QtWidgets.QComboBox(self.sendDirect)
         self.comboBoxSendFrom.setMinimumSize(QtCore.QSize(300, 0))
-        self.comboBoxSendFrom.setObjectName(_fromUtf8("comboBoxSendFrom"))
+        self.comboBoxSendFrom.setObjectName("comboBoxSendFrom")
         self.gridLayout_2.addWidget(self.comboBoxSendFrom, 0, 1, 1, 1)
-        self.lineEditTo = QtGui.QLineEdit(self.sendDirect)
-        self.lineEditTo.setObjectName(_fromUtf8("lineEditTo"))
+        self.lineEditTo = QtWidgets.QLineEdit(self.sendDirect)
+        self.lineEditTo.setObjectName("lineEditTo")
         self.gridLayout_2.addWidget(self.lineEditTo, 1, 1, 1, 1)
         self.lineEditTo.setCompleter(self.addressBookCompleter)
-        self.gridLayout_2_Widget = QtGui.QWidget()
+        self.gridLayout_2_Widget = QtWidgets.QWidget()
         self.gridLayout_2_Widget.setLayout(self.gridLayout_2)
         self.verticalSplitter_5.addWidget(self.gridLayout_2_Widget)
         self.textEditMessage = MessageCompose(self.sendDirect)
-        self.textEditMessage.setObjectName(_fromUtf8("textEditMessage"))
+        self.textEditMessage.setObjectName("textEditMessage")
         self.verticalSplitter_5.addWidget(self.textEditMessage)
         self.verticalSplitter_5.setStretchFactor(0, 0)
         self.verticalSplitter_5.setStretchFactor(1, 1)
@@ -255,35 +230,35 @@ class Ui_MainWindow(object):
         self.verticalSplitter_5.setCollapsible(1, False)
         self.verticalSplitter_5.handle(1).setEnabled(False)
         self.gridLayout_8.addWidget(self.verticalSplitter_5, 0, 0, 1, 1)
-        self.tabWidgetSend.addTab(self.sendDirect, _fromUtf8(""))
-        self.sendBroadcast = QtGui.QWidget()
-        self.sendBroadcast.setObjectName(_fromUtf8("sendBroadcast"))
-        self.gridLayout_9 = QtGui.QGridLayout(self.sendBroadcast)
-        self.gridLayout_9.setObjectName(_fromUtf8("gridLayout_9"))
+        self.tabWidgetSend.addTab(self.sendDirect, "")
+        self.sendBroadcast = QtWidgets.QWidget()
+        self.sendBroadcast.setObjectName("sendBroadcast")
+        self.gridLayout_9 = QtWidgets.QGridLayout(self.sendBroadcast)
+        self.gridLayout_9.setObjectName("gridLayout_9")
         self.verticalSplitter_6 = settingsmixin.SSplitter()
-        self.verticalSplitter_6.setObjectName(_fromUtf8("verticalSplitter_6"))
+        self.verticalSplitter_6.setObjectName("verticalSplitter_6")
         self.verticalSplitter_6.setOrientation(QtCore.Qt.Vertical)
-        self.gridLayout_5 = QtGui.QGridLayout()
-        self.gridLayout_5.setObjectName(_fromUtf8("gridLayout_5"))
-        self.label_8 = QtGui.QLabel(self.sendBroadcast)
-        self.label_8.setObjectName(_fromUtf8("label_8"))
+        self.gridLayout_5 = QtWidgets.QGridLayout()
+        self.gridLayout_5.setObjectName("gridLayout_5")
+        self.label_8 = QtWidgets.QLabel(self.sendBroadcast)
+        self.label_8.setObjectName("label_8")
         self.gridLayout_5.addWidget(self.label_8, 0, 0, 1, 1)
-        self.lineEditSubjectBroadcast = QtGui.QLineEdit(self.sendBroadcast)
-        self.lineEditSubjectBroadcast.setText(_fromUtf8(""))
-        self.lineEditSubjectBroadcast.setObjectName(_fromUtf8("lineEditSubjectBroadcast"))
+        self.lineEditSubjectBroadcast = QtWidgets.QLineEdit(self.sendBroadcast)
+        self.lineEditSubjectBroadcast.setText("")
+        self.lineEditSubjectBroadcast.setObjectName("lineEditSubjectBroadcast")
         self.gridLayout_5.addWidget(self.lineEditSubjectBroadcast, 1, 1, 1, 1)
-        self.label_7 = QtGui.QLabel(self.sendBroadcast)
-        self.label_7.setObjectName(_fromUtf8("label_7"))
+        self.label_7 = QtWidgets.QLabel(self.sendBroadcast)
+        self.label_7.setObjectName("label_7")
         self.gridLayout_5.addWidget(self.label_7, 1, 0, 1, 1)
-        self.comboBoxSendFromBroadcast = QtGui.QComboBox(self.sendBroadcast)
+        self.comboBoxSendFromBroadcast = QtWidgets.QComboBox(self.sendBroadcast)
         self.comboBoxSendFromBroadcast.setMinimumSize(QtCore.QSize(300, 0))
-        self.comboBoxSendFromBroadcast.setObjectName(_fromUtf8("comboBoxSendFromBroadcast"))
+        self.comboBoxSendFromBroadcast.setObjectName("comboBoxSendFromBroadcast")
         self.gridLayout_5.addWidget(self.comboBoxSendFromBroadcast, 0, 1, 1, 1)
-        self.gridLayout_5_Widget = QtGui.QWidget()
+        self.gridLayout_5_Widget = QtWidgets.QWidget()
         self.gridLayout_5_Widget.setLayout(self.gridLayout_5)
         self.verticalSplitter_6.addWidget(self.gridLayout_5_Widget)
         self.textEditMessageBroadcast = MessageCompose(self.sendBroadcast)
-        self.textEditMessageBroadcast.setObjectName(_fromUtf8("textEditMessageBroadcast"))
+        self.textEditMessageBroadcast.setObjectName("textEditMessageBroadcast")
         self.verticalSplitter_6.addWidget(self.textEditMessageBroadcast)
         self.verticalSplitter_6.setStretchFactor(0, 0)
         self.verticalSplitter_6.setStretchFactor(1, 1)
@@ -291,15 +266,15 @@ class Ui_MainWindow(object):
         self.verticalSplitter_6.setCollapsible(1, False)
         self.verticalSplitter_6.handle(1).setEnabled(False)
         self.gridLayout_9.addWidget(self.verticalSplitter_6, 0, 0, 1, 1)
-        self.tabWidgetSend.addTab(self.sendBroadcast, _fromUtf8(""))
+        self.tabWidgetSend.addTab(self.sendBroadcast, "")
         self.verticalSplitter.addWidget(self.tabWidgetSend)
-        self.tTLContainer = QtGui.QWidget()
-        self.tTLContainer.setSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Fixed)
-        self.horizontalLayout_5 = QtGui.QHBoxLayout()
+        self.tTLContainer = QtWidgets.QWidget()
+        self.tTLContainer.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
+        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
         self.tTLContainer.setLayout(self.horizontalLayout_5)
-        self.horizontalLayout_5.setObjectName(_fromUtf8("horizontalLayout_5"))
-        self.pushButtonTTL = QtGui.QPushButton(self.send)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Fixed)
+        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
+        self.pushButtonTTL = QtWidgets.QPushButton(self.send)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.pushButtonTTL.sizePolicy().hasHeightForWidth())
@@ -319,29 +294,29 @@ class Ui_MainWindow(object):
         font.setUnderline(True)
         self.pushButtonTTL.setFont(font)
         self.pushButtonTTL.setFlat(True)
-        self.pushButtonTTL.setObjectName(_fromUtf8("pushButtonTTL"))
+        self.pushButtonTTL.setObjectName("pushButtonTTL")
         self.horizontalLayout_5.addWidget(self.pushButtonTTL, 0, QtCore.Qt.AlignRight)
-        self.horizontalSliderTTL = QtGui.QSlider(self.send)
+        self.horizontalSliderTTL = QtWidgets.QSlider(self.send)
         self.horizontalSliderTTL.setMinimumSize(QtCore.QSize(70, 0))
         self.horizontalSliderTTL.setOrientation(QtCore.Qt.Horizontal)
         self.horizontalSliderTTL.setInvertedAppearance(False)
         self.horizontalSliderTTL.setInvertedControls(False)
-        self.horizontalSliderTTL.setObjectName(_fromUtf8("horizontalSliderTTL"))
+        self.horizontalSliderTTL.setObjectName("horizontalSliderTTL")
         self.horizontalLayout_5.addWidget(self.horizontalSliderTTL, 0, QtCore.Qt.AlignLeft)
-        self.labelHumanFriendlyTTLDescription = QtGui.QLabel(self.send)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Fixed)
+        self.labelHumanFriendlyTTLDescription = QtWidgets.QLabel(self.send)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.labelHumanFriendlyTTLDescription.sizePolicy().hasHeightForWidth())
         self.labelHumanFriendlyTTLDescription.setSizePolicy(sizePolicy)
         self.labelHumanFriendlyTTLDescription.setMinimumSize(QtCore.QSize(45, 0))
-        self.labelHumanFriendlyTTLDescription.setObjectName(_fromUtf8("labelHumanFriendlyTTLDescription"))
+        self.labelHumanFriendlyTTLDescription.setObjectName("labelHumanFriendlyTTLDescription")
         self.horizontalLayout_5.addWidget(self.labelHumanFriendlyTTLDescription, 1, QtCore.Qt.AlignLeft)
-        self.pushButtonClear = QtGui.QPushButton(self.send)
-        self.pushButtonClear.setObjectName(_fromUtf8("pushButtonClear"))
+        self.pushButtonClear = QtWidgets.QPushButton(self.send)
+        self.pushButtonClear.setObjectName("pushButtonClear")
         self.horizontalLayout_5.addWidget(self.pushButtonClear, 0, QtCore.Qt.AlignRight)
-        self.pushButtonSend = QtGui.QPushButton(self.send)
-        self.pushButtonSend.setObjectName(_fromUtf8("pushButtonSend"))
+        self.pushButtonSend = QtWidgets.QPushButton(self.send)
+        self.pushButtonSend.setObjectName("pushButtonSend")
         self.horizontalLayout_5.addWidget(self.pushButtonSend, 0, QtCore.Qt.AlignRight)
         self.horizontalSliderTTL.setMaximumSize(QtCore.QSize(105, self.pushButtonSend.height()))
         self.verticalSplitter.addWidget(self.tTLContainer)
@@ -358,29 +333,29 @@ class Ui_MainWindow(object):
         self.horizontalSplitter.setCollapsible(1, False)
         self.gridLayout_7.addWidget(self.horizontalSplitter, 0, 0, 1, 1)
         icon4 = QtGui.QIcon()
-        icon4.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/send.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
-        self.tabWidget.addTab(self.send, icon4, _fromUtf8(""))
-        self.subscriptions = QtGui.QWidget()
-        self.subscriptions.setObjectName(_fromUtf8("subscriptions"))
-        self.gridLayout_3 = QtGui.QGridLayout(self.subscriptions)
-        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
+        icon4.addPixmap(QtGui.QPixmap(":/newPrefix/images/send.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
+        self.tabWidget.addTab(self.send, icon4, "")
+        self.subscriptions = QtWidgets.QWidget()
+        self.subscriptions.setObjectName("subscriptions")
+        self.gridLayout_3 = QtWidgets.QGridLayout(self.subscriptions)
+        self.gridLayout_3.setObjectName("gridLayout_3")
         self.horizontalSplitter_4 = settingsmixin.SSplitter()
-        self.horizontalSplitter_4.setObjectName(_fromUtf8("horizontalSplitter_4"))
+        self.horizontalSplitter_4.setObjectName("horizontalSplitter_4")
         self.verticalSplitter_3 = settingsmixin.SSplitter()
-        self.verticalSplitter_3.setObjectName(_fromUtf8("verticalSplitter_3"))
+        self.verticalSplitter_3.setObjectName("verticalSplitter_3")
         self.verticalSplitter_3.setOrientation(QtCore.Qt.Vertical)
         self.treeWidgetSubscriptions = settingsmixin.STreeWidget(self.subscriptions)
         self.treeWidgetSubscriptions.setAlternatingRowColors(True)
-        self.treeWidgetSubscriptions.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
-        self.treeWidgetSubscriptions.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
-        self.treeWidgetSubscriptions.setObjectName(_fromUtf8("treeWidgetSubscriptions"))
+        self.treeWidgetSubscriptions.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
+        self.treeWidgetSubscriptions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
+        self.treeWidgetSubscriptions.setObjectName("treeWidgetSubscriptions")
         self.treeWidgetSubscriptions.resize(200, self.treeWidgetSubscriptions.height())
         icon5 = QtGui.QIcon()
-        icon5.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/subscriptions.png")), QtGui.QIcon.Selected, QtGui.QIcon.Off)
+        icon5.addPixmap(QtGui.QPixmap(":/newPrefix/images/subscriptions.png"), QtGui.QIcon.Selected, QtGui.QIcon.Off)
         self.treeWidgetSubscriptions.headerItem().setIcon(0, icon5)
         self.verticalSplitter_3.addWidget(self.treeWidgetSubscriptions)
-        self.pushButtonAddSubscription = QtGui.QPushButton(self.subscriptions)
-        self.pushButtonAddSubscription.setObjectName(_fromUtf8("pushButtonAddSubscription"))
+        self.pushButtonAddSubscription = QtWidgets.QPushButton(self.subscriptions)
+        self.pushButtonAddSubscription.setObjectName("pushButtonAddSubscription")
         self.pushButtonAddSubscription.resize(200, self.pushButtonAddSubscription.height())
         self.verticalSplitter_3.addWidget(self.pushButtonAddSubscription)
         self.verticalSplitter_3.setStretchFactor(0, 1)
@@ -390,42 +365,42 @@ class Ui_MainWindow(object):
         self.verticalSplitter_3.handle(1).setEnabled(False)
         self.horizontalSplitter_4.addWidget(self.verticalSplitter_3)
         self.verticalSplitter_4 = settingsmixin.SSplitter()
-        self.verticalSplitter_4.setObjectName(_fromUtf8("verticalSplitter_4"))
+        self.verticalSplitter_4.setObjectName("verticalSplitter_4")
         self.verticalSplitter_4.setOrientation(QtCore.Qt.Vertical)
-        self.horizontalSplitter_2 = QtGui.QSplitter()
-        self.horizontalSplitter_2.setObjectName(_fromUtf8("horizontalSplitter_2"))
-        self.inboxSearchLineEditSubscriptions = QtGui.QLineEdit(self.subscriptions)
-        self.inboxSearchLineEditSubscriptions.setObjectName(_fromUtf8("inboxSearchLineEditSubscriptions"))
+        self.horizontalSplitter_2 = QtWidgets.QSplitter()
+        self.horizontalSplitter_2.setObjectName("horizontalSplitter_2")
+        self.inboxSearchLineEditSubscriptions = QtWidgets.QLineEdit(self.subscriptions)
+        self.inboxSearchLineEditSubscriptions.setObjectName("inboxSearchLineEditSubscriptions")
         self.horizontalSplitter_2.addWidget(self.inboxSearchLineEditSubscriptions)
-        self.inboxSearchOptionSubscriptions = QtGui.QComboBox(self.subscriptions)
-        self.inboxSearchOptionSubscriptions.setObjectName(_fromUtf8("inboxSearchOptionSubscriptions"))
-        self.inboxSearchOptionSubscriptions.addItem(_fromUtf8(""))
-        self.inboxSearchOptionSubscriptions.addItem(_fromUtf8(""))
-        self.inboxSearchOptionSubscriptions.addItem(_fromUtf8(""))
-        self.inboxSearchOptionSubscriptions.addItem(_fromUtf8(""))
-        self.inboxSearchOptionSubscriptions.addItem(_fromUtf8(""))
-        self.inboxSearchOptionSubscriptions.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)
+        self.inboxSearchOptionSubscriptions = QtWidgets.QComboBox(self.subscriptions)
+        self.inboxSearchOptionSubscriptions.setObjectName("inboxSearchOptionSubscriptions")
+        self.inboxSearchOptionSubscriptions.addItem("")
+        self.inboxSearchOptionSubscriptions.addItem("")
+        self.inboxSearchOptionSubscriptions.addItem("")
+        self.inboxSearchOptionSubscriptions.addItem("")
+        self.inboxSearchOptionSubscriptions.addItem("")
+        self.inboxSearchOptionSubscriptions.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
         self.horizontalSplitter_2.addWidget(self.inboxSearchOptionSubscriptions)
         self.horizontalSplitter_2.handle(1).setEnabled(False)
         self.horizontalSplitter_2.setStretchFactor(0, 1)
         self.horizontalSplitter_2.setStretchFactor(1, 0)
         self.verticalSplitter_4.addWidget(self.horizontalSplitter_2)
         self.tableWidgetInboxSubscriptions = settingsmixin.STableWidget(self.subscriptions)
-        self.tableWidgetInboxSubscriptions.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
+        self.tableWidgetInboxSubscriptions.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
         self.tableWidgetInboxSubscriptions.setAlternatingRowColors(True)
-        self.tableWidgetInboxSubscriptions.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
-        self.tableWidgetInboxSubscriptions.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
+        self.tableWidgetInboxSubscriptions.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
+        self.tableWidgetInboxSubscriptions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
         self.tableWidgetInboxSubscriptions.setWordWrap(False)
-        self.tableWidgetInboxSubscriptions.setObjectName(_fromUtf8("tableWidgetInboxSubscriptions"))
+        self.tableWidgetInboxSubscriptions.setObjectName("tableWidgetInboxSubscriptions")
         self.tableWidgetInboxSubscriptions.setColumnCount(4)
         self.tableWidgetInboxSubscriptions.setRowCount(0)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxSubscriptions.setHorizontalHeaderItem(0, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxSubscriptions.setHorizontalHeaderItem(1, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxSubscriptions.setHorizontalHeaderItem(2, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxSubscriptions.setHorizontalHeaderItem(3, item)
         self.tableWidgetInboxSubscriptions.horizontalHeader().setCascadingSectionResizes(True)
         self.tableWidgetInboxSubscriptions.horizontalHeader().setDefaultSectionSize(200)
@@ -439,7 +414,7 @@ class Ui_MainWindow(object):
         self.textEditInboxMessageSubscriptions = MessageView(self.subscriptions)
         self.textEditInboxMessageSubscriptions.setBaseSize(QtCore.QSize(0, 500))
         self.textEditInboxMessageSubscriptions.setReadOnly(True)
-        self.textEditInboxMessageSubscriptions.setObjectName(_fromUtf8("textEditInboxMessageSubscriptions"))
+        self.textEditInboxMessageSubscriptions.setObjectName("textEditInboxMessageSubscriptions")
         self.verticalSplitter_4.addWidget(self.textEditInboxMessageSubscriptions)
         self.verticalSplitter_4.setStretchFactor(0, 0)
         self.verticalSplitter_4.setStretchFactor(1, 1)
@@ -455,31 +430,31 @@ class Ui_MainWindow(object):
         self.horizontalSplitter_4.setCollapsible(1, False)
         self.gridLayout_3.addWidget(self.horizontalSplitter_4, 0, 0, 1, 1)
         icon6 = QtGui.QIcon()
-        icon6.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/subscriptions.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
-        self.tabWidget.addTab(self.subscriptions, icon6, _fromUtf8(""))
-        self.chans = QtGui.QWidget()
-        self.chans.setObjectName(_fromUtf8("chans"))
-        self.gridLayout_4 = QtGui.QGridLayout(self.chans)
-        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
+        icon6.addPixmap(QtGui.QPixmap(":/newPrefix/images/subscriptions.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
+        self.tabWidget.addTab(self.subscriptions, icon6, "")
+        self.chans = QtWidgets.QWidget()
+        self.chans.setObjectName("chans")
+        self.gridLayout_4 = QtWidgets.QGridLayout(self.chans)
+        self.gridLayout_4.setObjectName("gridLayout_4")
         self.horizontalSplitter_7 = settingsmixin.SSplitter()
-        self.horizontalSplitter_7.setObjectName(_fromUtf8("horizontalSplitter_7"))
+        self.horizontalSplitter_7.setObjectName("horizontalSplitter_7")
         self.verticalSplitter_17 = settingsmixin.SSplitter()
-        self.verticalSplitter_17.setObjectName(_fromUtf8("verticalSplitter_17"))
+        self.verticalSplitter_17.setObjectName("verticalSplitter_17")
         self.verticalSplitter_17.setOrientation(QtCore.Qt.Vertical)
         self.treeWidgetChans = settingsmixin.STreeWidget(self.chans)
-        self.treeWidgetChans.setFrameShadow(QtGui.QFrame.Sunken)
+        self.treeWidgetChans.setFrameShadow(QtWidgets.QFrame.Sunken)
         self.treeWidgetChans.setLineWidth(1)
         self.treeWidgetChans.setAlternatingRowColors(True)
-        self.treeWidgetChans.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
-        self.treeWidgetChans.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
-        self.treeWidgetChans.setObjectName(_fromUtf8("treeWidgetChans"))
+        self.treeWidgetChans.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
+        self.treeWidgetChans.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
+        self.treeWidgetChans.setObjectName("treeWidgetChans")
         self.treeWidgetChans.resize(200, self.treeWidgetChans.height())
         icon7 = QtGui.QIcon()
-        icon7.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/can-icon-16px.png")), QtGui.QIcon.Selected, QtGui.QIcon.Off)
+        icon7.addPixmap(QtGui.QPixmap(":/newPrefix/images/can-icon-16px.png"), QtGui.QIcon.Selected, QtGui.QIcon.Off)
         self.treeWidgetChans.headerItem().setIcon(0, icon7)
         self.verticalSplitter_17.addWidget(self.treeWidgetChans)
-        self.pushButtonAddChan = QtGui.QPushButton(self.chans)
-        self.pushButtonAddChan.setObjectName(_fromUtf8("pushButtonAddChan"))
+        self.pushButtonAddChan = QtWidgets.QPushButton(self.chans)
+        self.pushButtonAddChan.setObjectName("pushButtonAddChan")
         self.pushButtonAddChan.resize(200, self.pushButtonAddChan.height())
         self.verticalSplitter_17.addWidget(self.pushButtonAddChan)
         self.verticalSplitter_17.setStretchFactor(0, 1)
@@ -489,42 +464,42 @@ class Ui_MainWindow(object):
         self.verticalSplitter_17.handle(1).setEnabled(False)
         self.horizontalSplitter_7.addWidget(self.verticalSplitter_17)
         self.verticalSplitter_8 = settingsmixin.SSplitter()
-        self.verticalSplitter_8.setObjectName(_fromUtf8("verticalSplitter_8"))
+        self.verticalSplitter_8.setObjectName("verticalSplitter_8")
         self.verticalSplitter_8.setOrientation(QtCore.Qt.Vertical)
-        self.horizontalSplitter_6 = QtGui.QSplitter()
-        self.horizontalSplitter_6.setObjectName(_fromUtf8("horizontalSplitter_6"))
-        self.inboxSearchLineEditChans = QtGui.QLineEdit(self.chans)
-        self.inboxSearchLineEditChans.setObjectName(_fromUtf8("inboxSearchLineEditChans"))
+        self.horizontalSplitter_6 = QtWidgets.QSplitter()
+        self.horizontalSplitter_6.setObjectName("horizontalSplitter_6")
+        self.inboxSearchLineEditChans = QtWidgets.QLineEdit(self.chans)
+        self.inboxSearchLineEditChans.setObjectName("inboxSearchLineEditChans")
         self.horizontalSplitter_6.addWidget(self.inboxSearchLineEditChans)
-        self.inboxSearchOptionChans = QtGui.QComboBox(self.chans)
-        self.inboxSearchOptionChans.setObjectName(_fromUtf8("inboxSearchOptionChans"))
-        self.inboxSearchOptionChans.addItem(_fromUtf8(""))
-        self.inboxSearchOptionChans.addItem(_fromUtf8(""))
-        self.inboxSearchOptionChans.addItem(_fromUtf8(""))
-        self.inboxSearchOptionChans.addItem(_fromUtf8(""))
-        self.inboxSearchOptionChans.addItem(_fromUtf8(""))
-        self.inboxSearchOptionChans.setSizeAdjustPolicy(QtGui.QComboBox.AdjustToContents)
+        self.inboxSearchOptionChans = QtWidgets.QComboBox(self.chans)
+        self.inboxSearchOptionChans.setObjectName("inboxSearchOptionChans")
+        self.inboxSearchOptionChans.addItem("")
+        self.inboxSearchOptionChans.addItem("")
+        self.inboxSearchOptionChans.addItem("")
+        self.inboxSearchOptionChans.addItem("")
+        self.inboxSearchOptionChans.addItem("")
+        self.inboxSearchOptionChans.setSizeAdjustPolicy(QtWidgets.QComboBox.AdjustToContents)
         self.horizontalSplitter_6.addWidget(self.inboxSearchOptionChans)
         self.horizontalSplitter_6.handle(1).setEnabled(False)
         self.horizontalSplitter_6.setStretchFactor(0, 1)
         self.horizontalSplitter_6.setStretchFactor(1, 0)
         self.verticalSplitter_8.addWidget(self.horizontalSplitter_6)
         self.tableWidgetInboxChans = settingsmixin.STableWidget(self.chans)
-        self.tableWidgetInboxChans.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
+        self.tableWidgetInboxChans.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
         self.tableWidgetInboxChans.setAlternatingRowColors(True)
-        self.tableWidgetInboxChans.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
-        self.tableWidgetInboxChans.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
+        self.tableWidgetInboxChans.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
+        self.tableWidgetInboxChans.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
         self.tableWidgetInboxChans.setWordWrap(False)
-        self.tableWidgetInboxChans.setObjectName(_fromUtf8("tableWidgetInboxChans"))
+        self.tableWidgetInboxChans.setObjectName("tableWidgetInboxChans")
         self.tableWidgetInboxChans.setColumnCount(4)
         self.tableWidgetInboxChans.setRowCount(0)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxChans.setHorizontalHeaderItem(0, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxChans.setHorizontalHeaderItem(1, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxChans.setHorizontalHeaderItem(2, item)
-        item = QtGui.QTableWidgetItem()
+        item = QtWidgets.QTableWidgetItem()
         self.tableWidgetInboxChans.setHorizontalHeaderItem(3, item)
         self.tableWidgetInboxChans.horizontalHeader().setCascadingSectionResizes(True)
         self.tableWidgetInboxChans.horizontalHeader().setDefaultSectionSize(200)
@@ -538,7 +513,7 @@ class Ui_MainWindow(object):
         self.textEditInboxMessageChans = MessageView(self.chans)
         self.textEditInboxMessageChans.setBaseSize(QtCore.QSize(0, 500))
         self.textEditInboxMessageChans.setReadOnly(True)
-        self.textEditInboxMessageChans.setObjectName(_fromUtf8("textEditInboxMessageChans"))
+        self.textEditInboxMessageChans.setObjectName("textEditInboxMessageChans")
         self.verticalSplitter_8.addWidget(self.textEditInboxMessageChans)
         self.verticalSplitter_8.setStretchFactor(0, 0)
         self.verticalSplitter_8.setStretchFactor(1, 1)
@@ -554,8 +529,8 @@ class Ui_MainWindow(object):
         self.horizontalSplitter_7.setCollapsible(1, False)
         self.gridLayout_4.addWidget(self.horizontalSplitter_7, 0, 0, 1, 1)
         icon8 = QtGui.QIcon()
-        icon8.addPixmap(QtGui.QPixmap(_fromUtf8(":/newPrefix/images/can-icon-16px.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
-        self.tabWidget.addTab(self.chans, icon8, _fromUtf8(""))
+        icon8.addPixmap(QtGui.QPixmap(":/newPrefix/images/can-icon-16px.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
+        self.tabWidget.addTab(self.chans, icon8, "")
         self.blackwhitelist = Blacklist()
         self.tabWidget.addTab(self.blackwhitelist, QtGui.QIcon(":/newPrefix/images/blacklist.png"), "")
         # Initialize the Blacklist or Whitelist
@@ -567,62 +542,62 @@ class Ui_MainWindow(object):
         self.tabWidget.addTab(self.networkstatus, QtGui.QIcon(":/newPrefix/images/networkstatus.png"), "")
         self.gridLayout_10.addWidget(self.tabWidget, 0, 0, 1, 1)
         MainWindow.setCentralWidget(self.centralwidget)
-        self.menubar = QtGui.QMenuBar(MainWindow)
+        self.menubar = QtWidgets.QMenuBar(MainWindow)
         self.menubar.setGeometry(QtCore.QRect(0, 0, 885, 27))
-        self.menubar.setObjectName(_fromUtf8("menubar"))
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(_fromUtf8("menuFile"))
-        self.menuSettings = QtGui.QMenu(self.menubar)
-        self.menuSettings.setObjectName(_fromUtf8("menuSettings"))
-        self.menuHelp = QtGui.QMenu(self.menubar)
-        self.menuHelp.setObjectName(_fromUtf8("menuHelp"))
+        self.menubar.setObjectName("menubar")
+        self.menuFile = QtWidgets.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+        self.menuSettings = QtWidgets.QMenu(self.menubar)
+        self.menuSettings.setObjectName("menuSettings")
+        self.menuHelp = QtWidgets.QMenu(self.menubar)
+        self.menuHelp.setObjectName("menuHelp")
         MainWindow.setMenuBar(self.menubar)
-        self.statusbar = QtGui.QStatusBar(MainWindow)
+        self.statusbar = QtWidgets.QStatusBar(MainWindow)
         self.statusbar.setMaximumSize(QtCore.QSize(16777215, 22))
-        self.statusbar.setObjectName(_fromUtf8("statusbar"))
+        self.statusbar.setObjectName("statusbar")
         MainWindow.setStatusBar(self.statusbar)
-        self.actionImport_keys = QtGui.QAction(MainWindow)
-        self.actionImport_keys.setObjectName(_fromUtf8("actionImport_keys"))
-        self.actionManageKeys = QtGui.QAction(MainWindow)
+        self.actionImport_keys = QtWidgets.QAction(MainWindow)
+        self.actionImport_keys.setObjectName("actionImport_keys")
+        self.actionManageKeys = QtWidgets.QAction(MainWindow)
         self.actionManageKeys.setCheckable(False)
         self.actionManageKeys.setEnabled(True)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("dialog-password"))
+        icon = QtGui.QIcon.fromTheme("dialog-password")
         self.actionManageKeys.setIcon(icon)
-        self.actionManageKeys.setObjectName(_fromUtf8("actionManageKeys"))
-        self.actionNetworkSwitch = QtGui.QAction(MainWindow)
-        self.actionNetworkSwitch.setObjectName(_fromUtf8("actionNetworkSwitch"))
-        self.actionExit = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("application-exit"))
+        self.actionManageKeys.setObjectName("actionManageKeys")
+        self.actionNetworkSwitch = QtWidgets.QAction(MainWindow)
+        self.actionNetworkSwitch.setObjectName("actionNetworkSwitch")
+        self.actionExit = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("application-exit")
         self.actionExit.setIcon(icon)
-        self.actionExit.setObjectName(_fromUtf8("actionExit"))
-        self.actionHelp = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("help-contents"))
+        self.actionExit.setObjectName("actionExit")
+        self.actionHelp = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("help-contents")
         self.actionHelp.setIcon(icon)
-        self.actionHelp.setObjectName(_fromUtf8("actionHelp"))
-        self.actionSupport = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("help-support"))
+        self.actionHelp.setObjectName("actionHelp")
+        self.actionSupport = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("help-support")
         self.actionSupport.setIcon(icon)
-        self.actionSupport.setObjectName(_fromUtf8("actionSupport"))
-        self.actionAbout = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("help-about"))
+        self.actionSupport.setObjectName("actionSupport")
+        self.actionAbout = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("help-about")
         self.actionAbout.setIcon(icon)
-        self.actionAbout.setObjectName(_fromUtf8("actionAbout"))
-        self.actionSettings = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("document-properties"))
+        self.actionAbout.setObjectName("actionAbout")
+        self.actionSettings = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("document-properties")
         self.actionSettings.setIcon(icon)
-        self.actionSettings.setObjectName(_fromUtf8("actionSettings"))
-        self.actionRegenerateDeterministicAddresses = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("view-refresh"))
+        self.actionSettings.setObjectName("actionSettings")
+        self.actionRegenerateDeterministicAddresses = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("view-refresh")
         self.actionRegenerateDeterministicAddresses.setIcon(icon)
-        self.actionRegenerateDeterministicAddresses.setObjectName(_fromUtf8("actionRegenerateDeterministicAddresses"))
-        self.actionDeleteAllTrashedMessages = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("user-trash"))
+        self.actionRegenerateDeterministicAddresses.setObjectName("actionRegenerateDeterministicAddresses")
+        self.actionDeleteAllTrashedMessages = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("user-trash")
         self.actionDeleteAllTrashedMessages.setIcon(icon)
-        self.actionDeleteAllTrashedMessages.setObjectName(_fromUtf8("actionDeleteAllTrashedMessages"))
-        self.actionJoinChan = QtGui.QAction(MainWindow)
-        icon = QtGui.QIcon.fromTheme(_fromUtf8("contact-new"))
+        self.actionDeleteAllTrashedMessages.setObjectName("actionDeleteAllTrashedMessages")
+        self.actionJoinChan = QtWidgets.QAction(MainWindow)
+        icon = QtGui.QIcon.fromTheme("contact-new")
         self.actionJoinChan.setIcon(icon)
-        self.actionJoinChan.setObjectName(_fromUtf8("actionJoinChan"))
+        self.actionJoinChan.setObjectName("actionJoinChan")
         self.menuFile.addAction(self.actionManageKeys)
         self.menuFile.addAction(self.actionDeleteAllTrashedMessages)
         self.menuFile.addAction(self.actionRegenerateDeterministicAddresses)
@@ -703,7 +678,7 @@ class Ui_MainWindow(object):
             hours = int(BMConfigParser().getint('bitmessagesettings', 'ttl')/60/60)
         except:
             pass
-        self.labelHumanFriendlyTTLDescription.setText(_translate("MainWindow", "%n hour(s)", None, QtCore.QCoreApplication.CodecForTr, hours))
+        self.labelHumanFriendlyTTLDescription.setText(_translate("MainWindow", "%n hour(s)", None, hours))
         self.pushButtonClear.setText(_translate("MainWindow", "Clear", None))
         self.pushButtonSend.setText(_translate("MainWindow", "Send", None))
         self.tabWidget.setTabText(self.tabWidget.indexOf(self.send), _translate("MainWindow", "Send", None))
@@ -763,15 +738,13 @@ class Ui_MainWindow(object):
         self.actionDeleteAllTrashedMessages.setText(_translate("MainWindow", "Delete all trashed messages", None))
         self.actionJoinChan.setText(_translate("MainWindow", "Join / Create chan", None))
 
-import bitmessage_icons_rc
 
 if __name__ == "__main__":
     import sys
-    
-    app = QtGui.QApplication(sys.argv)
+
+    app = QtWidgets.QApplication(sys.argv)
     MainWindow = settingsmixin.SMainWindow()
     ui = Ui_MainWindow()
     ui.setupUi(MainWindow)
     MainWindow.show()
     sys.exit(app.exec_())
-
diff --git a/src/bitmessageqt/blacklist.py b/src/bitmessageqt/blacklist.py
index e07f946..a1cf540 100644
--- a/src/bitmessageqt/blacklist.py
+++ b/src/bitmessageqt/blacklist.py
@@ -1,6 +1,5 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
 from tr import _translate
-import l10n
 import widgets
 from addresses import addBMIfNotPresent
 from bmconfigparser import BMConfigParser
@@ -11,31 +10,31 @@ from utils import avatarize
 from uisignaler import UISignaler
 
 
-class Blacklist(QtGui.QWidget, RetranslateMixin):
+class Blacklist(QtWidgets.QWidget, RetranslateMixin):
     def __init__(self, parent=None):
         super(Blacklist, self).__init__(parent)
         widgets.load('blacklist.ui', self)
 
-        QtCore.QObject.connect(self.radioButtonBlacklist, QtCore.SIGNAL(
-            "clicked()"), self.click_radioButtonBlacklist)
-        QtCore.QObject.connect(self.radioButtonWhitelist, QtCore.SIGNAL(
-            "clicked()"), self.click_radioButtonWhitelist)
-        QtCore.QObject.connect(self.pushButtonAddBlacklist, QtCore.SIGNAL(
-        "clicked()"), self.click_pushButtonAddBlacklist)
+        self.radioButtonBlacklist.clicked.connect(
+            self.click_radioButtonBlacklist)
+        self.radioButtonWhitelist.clicked.connect(
+            self.click_radioButtonWhitelist)
+        self.pushButtonAddBlacklist.clicked.connect(
+            self.click_pushButtonAddBlacklist)
 
         self.init_blacklist_popup_menu()
 
-        # Initialize blacklist
-        QtCore.QObject.connect(self.tableWidgetBlacklist, QtCore.SIGNAL(
-            "itemChanged(QTableWidgetItem *)"), self.tableWidgetBlacklistItemChanged)
+        self.tableWidgetBlacklist.itemChanged.connect(
+             self.tableWidgetBlacklistItemChanged)
 
         # Set the icon sizes for the identicons
         identicon_size = 3*7
-        self.tableWidgetBlacklist.setIconSize(QtCore.QSize(identicon_size, identicon_size))
+        self.tableWidgetBlacklist.setIconSize(
+            QtCore.QSize(identicon_size, identicon_size))
 
         self.UISignalThread = UISignaler.get()
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "rerenderBlackWhiteList()"), self.rerenderBlackWhiteList)
+        self.UISignalThread.rerenderBlackWhiteList.connect(
+            self.rerenderBlackWhiteList)
 
     def click_radioButtonBlacklist(self):
         if BMConfigParser().get('bitmessagesettings', 'blackwhitelist') == 'white':
@@ -67,20 +66,20 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
                     sql = '''select * from blacklist where address=?'''
                 else:
                     sql = '''select * from whitelist where address=?'''
-                queryreturn = sqlQuery(sql,*t)
+                queryreturn = sqlQuery(sql, *t)
                 if queryreturn == []:
                     self.tableWidgetBlacklist.setSortingEnabled(False)
                     self.tableWidgetBlacklist.insertRow(0)
-                    newItem = QtGui.QTableWidgetItem(unicode(
-                        self.NewBlacklistDialogInstance.ui.newAddressLabel.text().toUtf8(), 'utf-8'))
+                    newItem = QtWidgets.QTableWidgetItem(
+                        self.NewBlacklistDialogInstance.ui.newAddressLabel.text())
                     newItem.setIcon(avatarize(address))
                     self.tableWidgetBlacklist.setItem(0, 0, newItem)
-                    newItem = QtGui.QTableWidgetItem(address)
+                    newItem = QtWidgets.QTableWidgetItem(address)
                     newItem.setFlags(
                         QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
                     self.tableWidgetBlacklist.setItem(0, 1, newItem)
                     self.tableWidgetBlacklist.setSortingEnabled(True)
-                    t = (str(self.NewBlacklistDialogInstance.ui.newAddressLabel.text().toUtf8()), address, True)
+                    t = (str(self.NewBlacklistDialogInstance.ui.newAddressLabel.text()), address, True)
                     if BMConfigParser().get('bitmessagesettings', 'blackwhitelist') == 'black':
                         sql = '''INSERT INTO blacklist VALUES (?,?,?)'''
                     else:
@@ -88,15 +87,21 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
                     sqlExecute(sql, *t)
                 else:
                     self.statusBar().showMessage(_translate(
-                        "MainWindow", "Error: You cannot add the same address to your list twice. Perhaps rename the existing one if you want."))
+                        "MainWindow",
+                        "Error: You cannot add the same address to your"
+                        " list twice. Perhaps rename the existing one"
+                        " if you want."
+                    ))
             else:
                 self.statusBar().showMessage(_translate(
-                    "MainWindow", "The address you entered was invalid. Ignoring it."))
+                    "MainWindow",
+                    "The address you entered was invalid. Ignoring it."
+                ))
 
     def tableWidgetBlacklistItemChanged(self, item):
         if item.column() == 0:
             addressitem = self.tableWidgetBlacklist.item(item.row(), 1)
-            if isinstance(addressitem, QtGui.QTableWidgetItem):
+            if isinstance(addressitem, QtWidgets.QTableWidgetItem):
                 if self.radioButtonBlacklist.isChecked():
                     sqlExecute('''UPDATE blacklist SET label=? WHERE address=?''',
                             str(item.text()), str(addressitem.text()))
@@ -106,7 +111,7 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
 
     def init_blacklist_popup_menu(self, connectSignal=True):
         # Popup menu for the Blacklist page
-        self.blacklistContextMenuToolbar = QtGui.QToolBar()
+        self.blacklistContextMenuToolbar = QtWidgets.QToolBar()
         # Actions
         self.actionBlacklistNew = self.blacklistContextMenuToolbar.addAction(
             _translate(
@@ -131,10 +136,9 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
         self.tableWidgetBlacklist.setContextMenuPolicy(
             QtCore.Qt.CustomContextMenu)
         if connectSignal:
-            self.connect(self.tableWidgetBlacklist, QtCore.SIGNAL(
-                'customContextMenuRequested(const QPoint&)'),
-                        self.on_context_menuBlacklist)
-        self.popMenuBlacklist = QtGui.QMenu(self)
+            self.tableWidgetBlacklist.customContextMenuRequested.connect(
+                self.on_context_menuBlacklist)
+        self.popMenuBlacklist = QtWidgets.QMenu(self)
         # self.popMenuBlacklist.addAction( self.actionBlacklistNew )
         self.popMenuBlacklist.addAction(self.actionBlacklistDelete)
         self.popMenuBlacklist.addSeparator()
@@ -160,16 +164,16 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
         for row in queryreturn:
             label, address, enabled = row
             self.tableWidgetBlacklist.insertRow(0)
-            newItem = QtGui.QTableWidgetItem(unicode(label, 'utf-8'))
+            newItem = QtWidgets.QTableWidgetItem(label)
             if not enabled:
-                newItem.setTextColor(QtGui.QColor(128, 128, 128))
+                newItem.setForeground(QtGui.QColor(128, 128, 128))
             newItem.setIcon(avatarize(address))
             self.tableWidgetBlacklist.setItem(0, 0, newItem)
-            newItem = QtGui.QTableWidgetItem(address)
+            newItem = QtWidgets.QTableWidgetItem(address)
             newItem.setFlags(
                 QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
             if not enabled:
-                newItem.setTextColor(QtGui.QColor(128, 128, 128))
+                newItem.setForeground(QtGui.QColor(128, 128, 128))
             self.tableWidgetBlacklist.setItem(0, 1, newItem)
         self.tableWidgetBlacklist.setSortingEnabled(True)
 
@@ -180,7 +184,7 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
     def on_action_BlacklistDelete(self):
         currentRow = self.tableWidgetBlacklist.currentRow()
         labelAtCurrentRow = self.tableWidgetBlacklist.item(
-            currentRow, 0).text().toUtf8()
+            currentRow, 0).text()
         addressAtCurrentRow = self.tableWidgetBlacklist.item(
             currentRow, 1).text()
         if BMConfigParser().get('bitmessagesettings', 'blackwhitelist') == 'black':
@@ -197,7 +201,7 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
         currentRow = self.tableWidgetBlacklist.currentRow()
         addressAtCurrentRow = self.tableWidgetBlacklist.item(
             currentRow, 1).text()
-        clipboard = QtGui.QApplication.clipboard()
+        clipboard = QtWidgets.QApplication.clipboard()
         clipboard.setText(str(addressAtCurrentRow))
 
     def on_context_menuBlacklist(self, point):
@@ -208,11 +212,12 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
         currentRow = self.tableWidgetBlacklist.currentRow()
         addressAtCurrentRow = self.tableWidgetBlacklist.item(
             currentRow, 1).text()
-        self.tableWidgetBlacklist.item(
-            currentRow, 0).setTextColor(QtGui.QApplication.palette().text().color())
-        self.tableWidgetBlacklist.item(
-            currentRow, 1).setTextColor(QtGui.QApplication.palette().text().color())
-        if BMConfigParser().get('bitmessagesettings', 'blackwhitelist') == 'black':
+        self.tableWidgetBlacklist.item(currentRow, 0).setForeground(
+            QtWidgets.QApplication.palette().text().color())
+        self.tableWidgetBlacklist.item(currentRow, 1).setForeground(
+            QtWidgets.QApplication.palette().text().color())
+        if BMConfigParser().get(
+                'bitmessagesettings', 'blackwhitelist') == 'black':
             sqlExecute(
                 '''UPDATE blacklist SET enabled=1 WHERE address=?''',
                 str(addressAtCurrentRow))
@@ -225,11 +230,12 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
         currentRow = self.tableWidgetBlacklist.currentRow()
         addressAtCurrentRow = self.tableWidgetBlacklist.item(
             currentRow, 1).text()
-        self.tableWidgetBlacklist.item(
-            currentRow, 0).setTextColor(QtGui.QColor(128, 128, 128))
-        self.tableWidgetBlacklist.item(
-            currentRow, 1).setTextColor(QtGui.QColor(128, 128, 128))
-        if BMConfigParser().get('bitmessagesettings', 'blackwhitelist') == 'black':
+        self.tableWidgetBlacklist.item(currentRow, 0).setForeground(
+            QtGui.QColor(128, 128, 128))
+        self.tableWidgetBlacklist.item(currentRow, 1).setForeground(
+            QtGui.QColor(128, 128, 128))
+        if BMConfigParser().get(
+                'bitmessagesettings', 'blackwhitelist') == 'black':
             sqlExecute(
                 '''UPDATE blacklist SET enabled=0 WHERE address=?''', str(addressAtCurrentRow))
         else:
@@ -238,4 +244,3 @@ class Blacklist(QtGui.QWidget, RetranslateMixin):
 
     def on_action_BlacklistSetAvatar(self):
         self.window().on_action_SetAvatar(self.tableWidgetBlacklist)
-
diff --git a/src/bitmessageqt/blacklist.ui b/src/bitmessageqt/blacklist.ui
index 80993fa..3068a6a 100644
--- a/src/bitmessageqt/blacklist.ui
+++ b/src/bitmessageqt/blacklist.ui
@@ -98,7 +98,7 @@
   <customwidget>
    <class>STableWidget</class>
    <extends>QTableWidget</extends>
-   <header>bitmessageqt/settingsmixin.h</header>
+   <header>bitmessageqt.settingsmixin</header>
   </customwidget>
  </customwidgets>
  <resources>
diff --git a/src/bitmessageqt/dialogs.py b/src/bitmessageqt/dialogs.py
index cb82f34..1b7eb23 100644
--- a/src/bitmessageqt/dialogs.py
+++ b/src/bitmessageqt/dialogs.py
@@ -1,4 +1,4 @@
-from PyQt4 import QtGui
+from qtpy import QtWidgets
 from tr import _translate
 from retranslateui import RetranslateMixin
 import widgets
@@ -20,7 +20,7 @@ __all__ = [
 ]
 
 
-class AboutDialog(QtGui.QDialog, RetranslateMixin):
+class AboutDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(AboutDialog, self).__init__(parent)
         widgets.load('about.ui', self)
@@ -44,10 +44,10 @@ class AboutDialog(QtGui.QDialog, RetranslateMixin):
         except AttributeError:
             pass
 
-        self.setFixedSize(QtGui.QWidget.sizeHint(self))
+        self.setFixedSize(QtWidgets.QWidget.sizeHint(self))
 
 
-class IconGlossaryDialog(QtGui.QDialog, RetranslateMixin):
+class IconGlossaryDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None, config=None):
         super(IconGlossaryDialog, self).__init__(parent)
         widgets.load('iconglossary.ui', self)
@@ -57,20 +57,21 @@ class IconGlossaryDialog(QtGui.QDialog, RetranslateMixin):
 
         self.labelPortNumber.setText(_translate(
             "iconGlossaryDialog",
-            "You are using TCP port %1. (This can be changed in the settings)."
-            ).arg(config.getint('bitmessagesettings', 'port')))
-        self.setFixedSize(QtGui.QWidget.sizeHint(self))
+            "You are using TCP port {0}."
+            " (This can be changed in the settings)."
+            ).format(config.getint('bitmessagesettings', 'port')))
+        self.setFixedSize(QtWidgets.QWidget.sizeHint(self))
 
 
-class HelpDialog(QtGui.QDialog, RetranslateMixin):
+class HelpDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(HelpDialog, self).__init__(parent)
         widgets.load('help.ui', self)
-        self.setFixedSize(QtGui.QWidget.sizeHint(self))
+        self.setFixedSize(QtWidgets.QWidget.sizeHint(self))
 
 
-class ConnectDialog(QtGui.QDialog, RetranslateMixin):
+class ConnectDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(ConnectDialog, self).__init__(parent)
         widgets.load('connect.ui', self)
-        self.setFixedSize(QtGui.QWidget.sizeHint(self))
+        self.setFixedSize(QtWidgets.QWidget.sizeHint(self))
diff --git a/src/bitmessageqt/foldertree.py b/src/bitmessageqt/foldertree.py
index 11227fc..56931bf 100644
--- a/src/bitmessageqt/foldertree.py
+++ b/src/bitmessageqt/foldertree.py
@@ -1,10 +1,10 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
 from string import find, rfind, rstrip, lstrip
 
 from tr import _translate
 from bmconfigparser import BMConfigParser
-from helper_sql import *
-from utils import *
+from helper_sql import sqlQuery, sqlExecute
+from utils import avatarize
 from settingsmixin import SettingsMixin
 
 # for pylupdate
@@ -22,7 +22,7 @@ class AccountMixin(object):
     SUBSCRIPTION = 4
     BROADCAST = 5
 
-    def accountColor (self):
+    def accountColor(self):
         if not self.isEnabled:
             return QtGui.QColor(128, 128, 128)
         elif self.type == self.CHAN:
@@ -30,19 +30,19 @@ class AccountMixin(object):
         elif self.type in [self.MAILINGLIST, self.SUBSCRIPTION]:
             return QtGui.QColor(137, 04, 177)
         else:
-            return QtGui.QApplication.palette().text().color()
-            
-    def folderColor (self):
+            return QtWidgets.QApplication.palette().text().color()
+
+    def folderColor(self):
         if not self.parent().isEnabled:
             return QtGui.QColor(128, 128, 128)
         else:
-            return QtGui.QApplication.palette().text().color()
-            
+            return QtWidgets.QApplication.palette().text().color()
+
     def accountBrush(self):
         brush = QtGui.QBrush(self.accountColor())
         brush.setStyle(QtCore.Qt.NoBrush)
         return brush
-        
+
     def folderBrush(self):
         brush = QtGui.QBrush(self.folderColor())
         brush.setStyle(QtCore.Qt.NoBrush)
@@ -53,12 +53,12 @@ class AccountMixin(object):
             self.address = None
         else:
             self.address = str(address)
-    
+
     def setUnreadCount(self, cnt):
         if hasattr(self, "unreadCount") and self.unreadCount == int(cnt):
             return
         self.unreadCount = int(cnt)
-        if isinstance(self, QtGui.QTreeWidgetItem):
+        if isinstance(self, QtWidgets.QTreeWidgetItem):
             self.emitDataChanged()
 
     def setEnabled(self, enabled):
@@ -69,7 +69,7 @@ class AccountMixin(object):
             for i in range(self.childCount()):
                 if isinstance(self.child(i), Ui_FolderWidget):
                     self.child(i).setEnabled(enabled)
-        if isinstance(self, QtGui.QTreeWidgetItem):
+        if isinstance(self, QtWidgets.QTreeWidgetItem):
             self.emitDataChanged()
 
     def setType(self):
@@ -82,41 +82,52 @@ class AccountMixin(object):
         elif BMConfigParser().safeGetBoolean(self.address, 'mailinglist'):
             self.type = self.MAILINGLIST
         elif sqlQuery(
-            '''select label from subscriptions where address=?''', self.address):
+            '''select label from subscriptions where address=?''',
+            self.address
+        ):
             self.type = AccountMixin.SUBSCRIPTION
         else:
             self.type = self.NORMAL
-            
+
     def defaultLabel(self):
         queryreturn = None
         retval = None
-        if self.type in (AccountMixin.NORMAL, AccountMixin.CHAN, AccountMixin.MAILINGLIST):
+        if self.type in (
+            AccountMixin.NORMAL, AccountMixin.CHAN,
+            AccountMixin.MAILINGLIST
+        ):
             try:
-                retval = unicode(BMConfigParser().get(self.address, 'label'), 'utf-8')
-            except Exception as e:
+                retval = unicode(
+                    BMConfigParser().get(self.address, 'label'), 'utf-8')
+            except Exception:
                 queryreturn = sqlQuery(
-                    '''select label from addressbook where address=?''', self.address)
+                    '''select label from addressbook where address=?''',
+                    self.address
+                )
         elif self.type == AccountMixin.SUBSCRIPTION:
             queryreturn = sqlQuery(
-                '''select label from subscriptions where address=?''', self.address)
+                '''select label from subscriptions where address=?''',
+                self.address
+            )
         if queryreturn is not None:
             if queryreturn != []:
                 for row in queryreturn:
                     retval, = row
                     retval = unicode(retval, 'utf-8')
         elif self.address is None or self.type == AccountMixin.ALL:
-            return unicode(
-                str(_translate("MainWindow", "All accounts")), 'utf-8')
+            return _translate("MainWindow", "All accounts")
         if retval is None:
             return unicode(self.address, 'utf-8')
         else:
             return retval
 
 
-class Ui_FolderWidget(QtGui.QTreeWidgetItem, AccountMixin):
+class Ui_FolderWidget(QtWidgets.QTreeWidgetItem, AccountMixin):
     folderWeight = {"inbox": 1, "new": 2, "sent": 3, "trash": 4}
-    def __init__(self, parent, pos = 0, address = "", folderName = "", unreadCount = 0):
-        super(QtGui.QTreeWidgetItem, self).__init__()
+
+    def __init__(
+            self, parent, pos=0, address="", folderName="", unreadCount=0):
+        super(Ui_FolderWidget, self).__init__()
         self.setAddress(address)
         self.setFolderName(folderName)
         self.setUnreadCount(unreadCount)
@@ -129,7 +140,7 @@ class Ui_FolderWidget(QtGui.QTreeWidgetItem, AccountMixin):
         if column == 0:
             if role == QtCore.Qt.DisplayRole:
                 return _translate("MainWindow", self.folderName) + (
-                    " (" + str(self.unreadCount) + ")"
+                    " (%s)" % (self.unreadCount,)
                     if self.unreadCount > 0 else ""
                 )
             elif role in (QtCore.Qt.EditRole, QtCore.Qt.ToolTipRole):
@@ -154,22 +165,23 @@ class Ui_FolderWidget(QtGui.QTreeWidgetItem, AccountMixin):
             else:
                 y = 99
             reverse = False
-            if self.treeWidget().header().sortIndicatorOrder() == QtCore.Qt.DescendingOrder:
+            if self.treeWidget().header().sortIndicatorOrder() == \
+                    QtCore.Qt.DescendingOrder:
                 reverse = True
             if x == y:
                 return self.folderName < other.folderName
             else:
                 return (x >= y if reverse else x < y)
 
-        return super(QtGui.QTreeWidgetItem, self).__lt__(other)
-    
+        return super(Ui_FolderWidget, self).__lt__(other)
 
-class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
-    def __init__(self, parent, pos = 0, address = None, unreadCount = 0, enabled = True):
-        super(QtGui.QTreeWidgetItem, self).__init__()
+
+class Ui_AddressWidget(QtWidgets.QTreeWidgetItem, AccountMixin, SettingsMixin):
+    def __init__(
+            self, parent, pos=0, address=None, unreadCount=0, enabled=True):
+        super(Ui_AddressWidget, self).__init__()
         parent.insertTopLevelItem(pos, self)
         # only set default when creating
-        #super(QtGui.QTreeWidgetItem, self).setExpanded(BMConfigParser().getboolean(self.address, 'enabled'))
         self.setAddress(address)
         self.setEnabled(enabled)
         self.setUnreadCount(unreadCount)
@@ -177,8 +189,7 @@ class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
 
     def _getLabel(self):
         if self.address is None:
-            return unicode(_translate(
-                "MainWindow", "All accounts").toUtf8(), 'utf-8', 'ignore')
+            return _translate("MainWindow", "All accounts")
         else:
             try:
                 return unicode(
@@ -187,14 +198,14 @@ class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
             except:
                 return unicode(self.address, 'utf-8')
 
-    def _getAddressBracket(self, unreadCount = False):
+    def _getAddressBracket(self, unreadCount=False):
         ret = ""
         if unreadCount:
             ret += " (" + str(self.unreadCount) + ")"
         if self.address is not None:
             ret += " (" + self.address + ")"
         return ret
-        
+
     def data(self, column, role):
         if column == 0:
             if role == QtCore.Qt.DisplayRole:
@@ -204,7 +215,7 @@ class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
                     return self._getLabel() + self._getAddressBracket(False)
             elif role == QtCore.Qt.EditRole:
                 return self._getLabel()
-            elif role == QtCore.Qt.ToolTipRole:    
+            elif role == QtCore.Qt.ToolTipRole:
                 return self._getLabel() + self._getAddressBracket(False)
             elif role == QtCore.Qt.DecorationRole:
                 if self.address is None:
@@ -218,23 +229,22 @@ class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
             elif role == QtCore.Qt.ForegroundRole:
                 return self.accountBrush()
         return super(Ui_AddressWidget, self).data(column, role)
-        
+
     def setData(self, column, role, value):
-        if role == QtCore.Qt.EditRole and self.type != AccountMixin.SUBSCRIPTION:
-            if isinstance(value, QtCore.QVariant):
-                BMConfigParser().set(str(self.address), 'label', str(value.toString().toUtf8()))
-            else:
-                BMConfigParser().set(str(self.address), 'label', str(value))
+        if role == QtCore.Qt.EditRole \
+                and self.type != AccountMixin.SUBSCRIPTION:
+            BMConfigParser().set(
+                str(self.address), 'label', value.encode('utf-8'))
             BMConfigParser().save()
         return super(Ui_AddressWidget, self).setData(column, role, value)
-        
+
     def setAddress(self, address):
         super(Ui_AddressWidget, self).setAddress(address)
         self.setData(0, QtCore.Qt.UserRole, self.address)
-    
+
     def setExpanded(self, expand):
         super(Ui_AddressWidget, self).setExpanded(expand)
-    
+
     def _getSortRank(self):
         ret = self.type
         if not self.isEnabled:
@@ -245,60 +255,61 @@ class Ui_AddressWidget(QtGui.QTreeWidgetItem, AccountMixin, SettingsMixin):
     def __lt__(self, other):
         if (isinstance(other, Ui_AddressWidget)):
             reverse = False
-            if self.treeWidget().header().sortIndicatorOrder() == QtCore.Qt.DescendingOrder:
+            if self.treeWidget().header().sortIndicatorOrder() == \
+                    QtCore.Qt.DescendingOrder:
                 reverse = True
             if self._getSortRank() == other._getSortRank():
                 x = self._getLabel().lower()
                 y = other._getLabel().lower()
                 return x < y
-            return (not reverse if self._getSortRank() < other._getSortRank() else reverse)
+            return(
+                not reverse if self._getSortRank() < other._getSortRank()
+                else reverse
+            )
+
+        return super(Ui_AddressWidget, self).__lt__(other)
 
-        return super(QtGui.QTreeWidgetItem, self).__lt__(other)
 
-        
 class Ui_SubscriptionWidget(Ui_AddressWidget, AccountMixin):
-    def __init__(self, parent, pos = 0, address = "", unreadCount = 0, label = "", enabled = True):
-        super(QtGui.QTreeWidgetItem, self).__init__()
+    def __init__(
+            self, parent, pos=0, address="", unreadCount=0, label="",
+            enabled=True):
+        super(Ui_SubscriptionWidget, self).__init__(parent)
         parent.insertTopLevelItem(pos, self)
         # only set default when creating
-        #super(QtGui.QTreeWidgetItem, self).setExpanded(BMConfigParser().getboolean(self.address, 'enabled'))
         self.setAddress(address)
         self.setEnabled(enabled)
         self.setType()
         self.setUnreadCount(unreadCount)
-    
+
     def _getLabel(self):
         queryreturn = sqlQuery(
-            '''select label from subscriptions where address=?''', self.address)
+            '''select label from subscriptions where address=?''',
+            self.address)
         if queryreturn != []:
             for row in queryreturn:
                 retval, = row
             return unicode(retval, 'utf-8', 'ignore')
         return unicode(self.address, 'utf-8')
-        
+
     def setType(self):
-        super(Ui_SubscriptionWidget, self).setType() # sets it editable
-        self.type = AccountMixin.SUBSCRIPTION # overrides type
-        
+        super(Ui_SubscriptionWidget, self).setType()  # sets it editable
+        self.type = AccountMixin.SUBSCRIPTION  # overrides type
+
     def setData(self, column, role, value):
         if role == QtCore.Qt.EditRole:
-            from debug import logger
-            if isinstance(value, QtCore.QVariant):
-                label = str(value.toString().toUtf8()).decode('utf-8', 'ignore')
-            else:
-                label = unicode(value, 'utf-8', 'ignore')
             sqlExecute(
                 '''UPDATE subscriptions SET label=? WHERE address=?''',
-                label, self.address)
+                value, self.address)
         return super(Ui_SubscriptionWidget, self).setData(column, role, value)
 
 
-class MessageList_AddressWidget(QtGui.QTableWidgetItem, AccountMixin, SettingsMixin):
-    def __init__(self, parent, address = None, label = None, unread = False):
-        super(QtGui.QTableWidgetItem, self).__init__()
-        #parent.insertTopLevelItem(pos, self)
+class MessageList_AddressWidget(
+        QtWidgets.QTableWidgetItem, AccountMixin, SettingsMixin):
+    def __init__(self, parent, address=None, label=None, unread=False):
+        super(MessageList_AddressWidget, self).__init__()
+        # parent.insertTopLevelItem(pos, self)
         # only set default when creating
-        #super(QtGui.QTreeWidgetItem, self).setExpanded(BMConfigParser().getboolean(self.address, 'enabled'))
         self.isEnabled = True
         self.setAddress(address)
         self.setLabel(label)
@@ -307,23 +318,33 @@ class MessageList_AddressWidget(QtGui.QTableWidgetItem, AccountMixin, SettingsMi
         self.setType()
         parent.append(self)
 
-    def setLabel(self, label = None):
+    def setLabel(self, label=None):
         newLabel = self.address
         if label is None:
             queryreturn = None
-            if self.type in (AccountMixin.NORMAL, AccountMixin.CHAN, AccountMixin.MAILINGLIST):
+            if self.type in (
+                AccountMixin.NORMAL, AccountMixin.CHAN,
+                AccountMixin.MAILINGLIST
+            ):
                 try:
-                    newLabel = unicode(BMConfigParser().get(self.address, 'label'), 'utf-8', 'ignore')
+                    newLabel = unicode(
+                        BMConfigParser().get(self.address, 'label'),
+                        'utf-8', 'ignore'
+                    )
                 except:
                     queryreturn = sqlQuery(
-                    '''select label from addressbook where address=?''', self.address)
+                        '''select label from addressbook where address=?''',
+                        self.address
+                    )
             elif self.type == AccountMixin.SUBSCRIPTION:
                 queryreturn = sqlQuery(
-                    '''select label from subscriptions where address=?''', self.address)
+                    '''select label from subscriptions where address=?''',
+                    self.address
+                )
             if queryreturn is not None:
                 if queryreturn != []:
                     for row in queryreturn:
-                        newLabel = unicode(row[0], 'utf-8', 'ignore')
+                        newLabel = unicode(row[0], 'utf-8')
         else:
             newLabel = label
         if hasattr(self, 'label') and newLabel == self.label:
@@ -341,7 +362,8 @@ class MessageList_AddressWidget(QtGui.QTableWidgetItem, AccountMixin, SettingsMi
         elif role == QtCore.Qt.ToolTipRole:
             return self.label + " (" + self.address + ")"
         elif role == QtCore.Qt.DecorationRole:
-            if BMConfigParser().safeGetBoolean('bitmessagesettings', 'useidenticons'):
+            if BMConfigParser().safeGetBoolean(
+                    'bitmessagesettings', 'useidenticons'):
                 if self.address is None:
                     return avatarize(self.label)
                 else:
@@ -355,7 +377,7 @@ class MessageList_AddressWidget(QtGui.QTableWidgetItem, AccountMixin, SettingsMi
         elif role == QtCore.Qt.UserRole:
             return self.address
         return super(MessageList_AddressWidget, self).data(role)
-        
+
     def setData(self, role, value):
         if role == QtCore.Qt.EditRole:
             self.setLabel()
@@ -365,15 +387,14 @@ class MessageList_AddressWidget(QtGui.QTableWidgetItem, AccountMixin, SettingsMi
     def __lt__(self, other):
         if (isinstance(other, MessageList_AddressWidget)):
             return self.label.lower() < other.label.lower()
-        return super(QtGui.QTableWidgetItem, self).__lt__(other)
+        return super(MessageList_AddressWidget, self).__lt__(other)
 
 
-class MessageList_SubjectWidget(QtGui.QTableWidgetItem, SettingsMixin):
-    def __init__(self, parent, subject = None, label = None, unread = False):
-        super(QtGui.QTableWidgetItem, self).__init__()
-        #parent.insertTopLevelItem(pos, self)
+class MessageList_SubjectWidget(QtWidgets.QTableWidgetItem, SettingsMixin):
+    def __init__(self, parent, subject=None, label=None, unread=False):
+        super(MessageList_SubjectWidget, self).__init__()
+        # parent.insertTopLevelItem(pos, self)
         # only set default when creating
-        #super(QtGui.QTreeWidgetItem, self).setExpanded(BMConfigParser().getboolean(self.address, 'enabled'))
         self.setSubject(subject)
         self.setLabel(label)
         self.setUnread(unread)
@@ -382,7 +403,7 @@ class MessageList_SubjectWidget(QtGui.QTableWidgetItem, SettingsMixin):
 
     def setLabel(self, label):
         self.label = label
-        
+
     def setSubject(self, subject):
         self.subject = subject
 
@@ -403,7 +424,7 @@ class MessageList_SubjectWidget(QtGui.QTableWidgetItem, SettingsMixin):
         elif role == QtCore.Qt.UserRole:
             return self.subject
         return super(MessageList_SubjectWidget, self).data(role)
-        
+
     def setData(self, role, value):
         return super(MessageList_SubjectWidget, self).setData(role, value)
 
@@ -411,12 +432,12 @@ class MessageList_SubjectWidget(QtGui.QTableWidgetItem, SettingsMixin):
     def __lt__(self, other):
         if (isinstance(other, MessageList_SubjectWidget)):
             return self.label.lower() < other.label.lower()
-        return super(QtGui.QTableWidgetItem, self).__lt__(other)
+        return super(MessageList_SubjectWidget, self).__lt__(other)
 
 
-class Ui_AddressBookWidgetItem(QtGui.QTableWidgetItem, AccountMixin):
-    def __init__ (self, text, type = AccountMixin.NORMAL):
-        super(QtGui.QTableWidgetItem, self).__init__(text)
+class Ui_AddressBookWidgetItem(QtWidgets.QTableWidgetItem, AccountMixin):
+    def __init__(self, text, type=AccountMixin.NORMAL):
+        super(Ui_AddressBookWidgetItem, self).__init__(text)
         self.label = text
         self.type = type
         self.setEnabled(True)
@@ -429,7 +450,8 @@ class Ui_AddressBookWidgetItem(QtGui.QTableWidgetItem, AccountMixin):
         elif role == QtCore.Qt.ToolTipRole:
             return self.label + " (" + self.address + ")"
         elif role == QtCore.Qt.DecorationRole:
-            if BMConfigParser().safeGetBoolean('bitmessagesettings', 'useidenticons'):
+            if BMConfigParser().safeGetBoolean(
+                    'bitmessagesettings', 'useidenticons'):
                 if self.address is None:
                     return avatarize(self.label)
                 else:
@@ -445,25 +467,29 @@ class Ui_AddressBookWidgetItem(QtGui.QTableWidgetItem, AccountMixin):
 
     def setData(self, role, value):
         if role == QtCore.Qt.EditRole:
-            if isinstance(value, QtCore.QVariant):
-                self.label = str(value.toString().toUtf8())
-            else:
-                self.label = str(value)
-            if self.type in (AccountMixin.NORMAL, AccountMixin.MAILINGLIST, AccountMixin.CHAN):
+            self.label = value.encode('utf-8')
+            if self.type in (
+                    AccountMixin.NORMAL, AccountMixin.MAILINGLIST,
+                    AccountMixin.CHAN):
                 try:
-                    a = BMConfigParser().get(self.address, 'label')
+                    BMConfigParser().get(self.address, 'label')
                     BMConfigParser().set(self.address, 'label', self.label)
                     BMConfigParser().save()
                 except:
-                    sqlExecute('''UPDATE addressbook set label=? WHERE address=?''', self.label, self.address)
+                    sqlExecute(
+                        '''UPDATE addressbook set label=? WHERE address=?''',
+                        self.label, self.address
+                    )
             elif self.type == AccountMixin.SUBSCRIPTION:
-                from debug import logger
-                sqlExecute('''UPDATE subscriptions set label=? WHERE address=?''', self.label, self.address)
+                sqlExecute(
+                    '''UPDATE subscriptions set label=? WHERE address=?''',
+                    self.label, self.address
+                )
             else:
                 pass
-        return super(Ui_AddressBookWidgetItem, self).setData(role, value)    
+        return super(Ui_AddressBookWidgetItem, self).setData(role, value)
 
-    def __lt__ (self, other):
+    def __lt__(self, other):
         if (isinstance(other, Ui_AddressBookWidgetItem)):
             reverse = False
             if self.tableWidget().horizontalHeader().sortIndicatorOrder() == QtCore.Qt.DescendingOrder:
@@ -472,12 +498,12 @@ class Ui_AddressBookWidgetItem(QtGui.QTableWidgetItem, AccountMixin):
                 return self.label.lower() < other.label.lower()
             else:
                 return (not reverse if self.type < other.type else reverse)
-        return super(QtGui.QTableWidgetItem, self).__lt__(other)
+        return super(Ui_AddressBookWidgetItem, self).__lt__(other)
 
 
 class Ui_AddressBookWidgetItemLabel(Ui_AddressBookWidgetItem):
-    def __init__ (self, address, label, type):
-        Ui_AddressBookWidgetItem.__init__(self, label, type)
+    def __init__(self, address, label, type):
+        super(Ui_AddressBookWidgetItemLabel, self).__init__(label, type)
         self.address = address
         self.label = label
 
@@ -487,33 +513,33 @@ class Ui_AddressBookWidgetItemLabel(Ui_AddressBookWidgetItem):
 
 
 class Ui_AddressBookWidgetItemAddress(Ui_AddressBookWidgetItem):
-    def __init__ (self, address, label, type):
-        Ui_AddressBookWidgetItem.__init__(self, address, type)
+    def __init__(self, address, label, type):
+        super(Ui_AddressBookWidgetItemAddress, self).__init__(address, type)
         self.address = address
         self.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
-        
-class AddressBookCompleter(QtGui.QCompleter):
+
+
+class AddressBookCompleter(QtWidgets.QCompleter):
     def __init__(self):
-        super(QtGui.QCompleter, self).__init__()
+        super(AddressBookCompleter, self).__init__()
         self.cursorPos = -1
-    
+
     def onCursorPositionChanged(self, oldPos, newPos):
         if oldPos != self.cursorPos:
             self.cursorPos = -1
-        
+
     def splitPath(self, path):
         stringList = []
-        text = unicode(path.toUtf8(), encoding="UTF-8")
-        splitIndex = rfind(text[0:self.widget().cursorPosition()], ";") + 1
-        str = text[splitIndex:self.widget().cursorPosition()]
+        splitIndex = rfind(path[0:self.widget().cursorPosition()], ";") + 1
+        str = path[splitIndex:self.widget().cursorPosition()]
         str = rstrip(lstrip(str))
         stringList.append(str)
         return stringList
-        
+
     def pathFromIndex(self, index):
-        autoString = unicode(index.data(QtCore.Qt.EditRole).toString().toUtf8(), encoding="UTF-8")
-        text = unicode(self.widget().text().toUtf8(), encoding="UTF-8")
-        
+        autoString = index.data(QtCore.Qt.EditRole).toString()
+        text = self.widget().text()
+
         # If cursor position was saved, restore it, else save it
         if self.cursorPos != -1:
             self.widget().setCursorPosition(self.cursorPos)
@@ -522,14 +548,16 @@ class AddressBookCompleter(QtGui.QCompleter):
 
         # Get current prosition
         curIndex = self.widget().cursorPosition()
-        
-        # prev_delimiter_index should actually point at final white space AFTER the delimiter
+
+        # prev_delimiter_index should actually point at final white space
+        # AFTER the delimiter
         # Get index of last delimiter before current position
         prevDelimiterIndex = rfind(text[0:curIndex], ";")
         while text[prevDelimiterIndex + 1] == " ":
             prevDelimiterIndex += 1
-            
-        # Get index of first delimiter after current position (or EOL if no delimiter after cursor)
+
+        # Get index of first delimiter after current position
+        # (or EOL if no delimiter after cursor)
         nextDelimiterIndex = find(text, ";", curIndex)
         if nextDelimiterIndex == -1:
             nextDelimiterIndex = len(text)
@@ -538,9 +566,9 @@ class AddressBookCompleter(QtGui.QCompleter):
         part1 = text[0:prevDelimiterIndex + 1]
 
         # Get string value from before auto finished string is selected
-        pre = text[prevDelimiterIndex + 1:curIndex - 1];
+        pre = text[prevDelimiterIndex + 1:curIndex - 1]
 
         # Get part of string that occurs AFTER cursor
         part2 = text[nextDelimiterIndex:]
 
-        return part1 + autoString + part2;
+        return part1 + autoString + part2
diff --git a/src/bitmessageqt/languagebox.py b/src/bitmessageqt/languagebox.py
index 552e035..1b8d494 100644
--- a/src/bitmessageqt/languagebox.py
+++ b/src/bitmessageqt/languagebox.py
@@ -1,37 +1,50 @@
 import glob
 import os
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtWidgets
+from tr import _translate
 
 from bmconfigparser import BMConfigParser
 import paths
 
-class LanguageBox(QtGui.QComboBox):
-    languageName = {"system": "System Settings", "eo": "Esperanto", "en_pirate": "Pirate English"}
-    def __init__(self, parent = None):
-        super(QtGui.QComboBox, self).__init__(parent)
+
+class LanguageBox(QtWidgets.QComboBox):
+    languageName = {
+        "system": "System Settings",
+        "eo": "Esperanto",
+        "en_pirate": "Pirate English"
+    }
+
+    def __init__(self, parent=None):
+        super(LanguageBox, self).__init__(parent)
         self.populate()
 
     def populate(self):
         self.languages = []
         self.clear()
-        localesPath = os.path.join (paths.codePath(), 'translations')
-        configuredLocale = "system"
+        localesPath = os.path.join(paths.codePath(), 'translations')
         try:
-            configuredLocale = BMConfigParser().get('bitmessagesettings', 'userlocale', "system")
+            configuredLocale = BMConfigParser().get(
+                'bitmessagesettings', 'userlocale', "system")
         except:
-            pass
-        self.addItem(QtGui.QApplication.translate("settingsDialog", "System Settings", "system"), "system")
+            configuredLocale = "system"
+        self.addItem(
+            _translate("settingsDialog", "System Settings", "system"),
+            "system"
+        )
         self.setCurrentIndex(0)
-        self.setInsertPolicy(QtGui.QComboBox.InsertAlphabetically)
-        for translationFile in sorted(glob.glob(os.path.join(localesPath, "bitmessage_*.qm"))):
-            localeShort = os.path.split(translationFile)[1].split("_", 1)[1][:-3]
-            locale = QtCore.QLocale(QtCore.QString(localeShort))
+        self.setInsertPolicy(QtWidgets.QComboBox.InsertAlphabetically)
+        for translationFile in sorted(
+            glob.glob(os.path.join(localesPath, "bitmessage_*.qm"))
+        ):
+            localeShort = \
+                os.path.split(translationFile)[1].split("_", 1)[1][:-3]
             if localeShort in LanguageBox.languageName:
-                self.addItem(LanguageBox.languageName[localeShort], localeShort)
-            elif locale.nativeLanguageName() == "":
-                self.addItem(localeShort, localeShort)
+                self.addItem(
+                    LanguageBox.languageName[localeShort], localeShort)
             else:
-                self.addItem(locale.nativeLanguageName(), localeShort)
+                locale = QtCore.QLocale(localeShort)
+                self.addItem(
+                    locale.nativeLanguageName() or localeShort, localeShort)
         for i in range(self.count()):
             if self.itemData(i) == configuredLocale:
                 self.setCurrentIndex(i)
diff --git a/src/bitmessageqt/messagecompose.py b/src/bitmessageqt/messagecompose.py
index f7d5dac..a47f411 100644
--- a/src/bitmessageqt/messagecompose.py
+++ b/src/bitmessageqt/messagecompose.py
@@ -1,20 +1,28 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtWidgets
+from tr import _translate
 
-class MessageCompose(QtGui.QTextEdit):
-    
-    def __init__(self, parent = 0):
+
+class MessageCompose(QtWidgets.QTextEdit):
+
+    def __init__(self, parent=None):
         super(MessageCompose, self).__init__(parent)
-        self.setAcceptRichText(False) # we'll deal with this later when we have a new message format
+        # we'll deal with this later when we have a new message format
+        self.setAcceptRichText(False)
         self.defaultFontPointSize = self.currentFont().pointSize()
-    
+
     def wheelEvent(self, event):
-        if (QtGui.QApplication.queryKeyboardModifiers() & QtCore.Qt.ControlModifier) == QtCore.Qt.ControlModifier and event.orientation() == QtCore.Qt.Vertical:
+        if (
+                (QtWidgets.QApplication.queryKeyboardModifiers()
+                 & QtCore.Qt.ControlModifier) == QtCore.Qt.ControlModifier
+                and event.orientation() == QtCore.Qt.Vertical
+        ):
             if event.delta() > 0:
                 self.zoomIn(1)
             else:
                 self.zoomOut(1)
             zoom = self.currentFont().pointSize() * 100 / self.defaultFontPointSize
-            QtGui.QApplication.activeWindow().statusBar().showMessage(QtGui.QApplication.translate("MainWindow", "Zoom level %1%").arg(str(zoom)))
+            QtWidgets.QApplication.activeWindow().statusbar.showMessage(
+                _translate("MainWindow", "Zoom level {0}%").format(zoom))
         else:
             # in QTextEdit, super does not zoom, only scroll
             super(MessageCompose, self).wheelEvent(event)
diff --git a/src/bitmessageqt/messageview.py b/src/bitmessageqt/messageview.py
index 4d2e768..3a1bc7c 100644
--- a/src/bitmessageqt/messageview.py
+++ b/src/bitmessageqt/messageview.py
@@ -1,17 +1,16 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
+from tr import _translate
 
-import multiprocessing
-import Queue
-from urlparse import urlparse
-from safehtmlparser import *
+from safehtmlparser import SafeHTMLParser
 
-class MessageView(QtGui.QTextBrowser):
+
+class MessageView(QtWidgets.QTextBrowser):
     MODE_PLAIN = 0
     MODE_HTML = 1
-    
-    def __init__(self, parent = 0):
+
+    def __init__(self, parent=None):
         super(MessageView, self).__init__(parent)
-        self.mode = MessageView.MODE_PLAIN 
+        self.mode = MessageView.MODE_PLAIN
         self.html = None
         self.setOpenExternalLinks(False)
         self.setOpenLinks(False)
@@ -27,10 +26,14 @@ class MessageView(QtGui.QTextBrowser):
     def resizeEvent(self, event):
         super(MessageView, self).resizeEvent(event)
         self.setWrappingWidth(event.size().width())
-    
+
     def mousePressEvent(self, event):
-        #text = textCursor.block().text()
-        if event.button() == QtCore.Qt.LeftButton and self.html and self.html.has_html and self.cursorForPosition(event.pos()).block().blockNumber() == 0:
+        # text = textCursor.block().text()
+        if (
+            event.button() == QtCore.Qt.LeftButton and self.html
+            and self.html.has_html
+            and self.cursorForPosition(event.pos()).block().blockNumber() == 0
+        ):
             if self.mode == MessageView.MODE_PLAIN:
                 self.showHTML()
             else:
@@ -41,19 +44,24 @@ class MessageView(QtGui.QTextBrowser):
     def wheelEvent(self, event):
         # super will actually automatically take care of zooming
         super(MessageView, self).wheelEvent(event)
-        if (QtGui.QApplication.queryKeyboardModifiers() & QtCore.Qt.ControlModifier) == QtCore.Qt.ControlModifier and event.orientation() == QtCore.Qt.Vertical:
+        if (
+                (QtWidgets.QApplication.queryKeyboardModifiers()
+                 & QtCore.Qt.ControlModifier) == QtCore.Qt.ControlModifier
+                and event.orientation() == QtCore.Qt.Vertical
+        ):
             zoom = self.currentFont().pointSize() * 100 / self.defaultFontPointSize
-            QtGui.QApplication.activeWindow().statusBar().showMessage(QtGui.QApplication.translate("MainWindow", "Zoom level %1%").arg(str(zoom)))
+            QtWidgets.QApplication.activeWindow().statusbar.showMessage(
+                _translate("MainWindow", "Zoom level {0}%").format(zoom))
 
     def setWrappingWidth(self, width=None):
-        self.setLineWrapMode(QtGui.QTextEdit.FixedPixelWidth)
+        self.setLineWrapMode(QtWidgets.QTextEdit.FixedPixelWidth)
         if width is None:
             width = self.width()
         self.setLineWrapColumnOrWidth(width)
 
     def confirmURL(self, link):
         if link.scheme() == "mailto":
-            window = QtGui.QApplication.activeWindow()
+            window = QtWidgets.QApplication.activeWindow()
             window.ui.lineEditTo.setText(link.path())
             if link.hasQueryItem("subject"):
                 window.ui.lineEditSubject.setText(
@@ -68,27 +76,24 @@ class MessageView(QtGui.QTextBrowser):
             )
             window.ui.textEditMessage.setFocus()
             return
-        reply = QtGui.QMessageBox.warning(self,
-            QtGui.QApplication.translate("MessageView", "Follow external link"),
-            QtGui.QApplication.translate("MessageView", "The link \"%1\" will open in a browser. It may be a security risk, it could de-anonymise you or download malicious data. Are you sure?").arg(unicode(link.toString())),
-            QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
-        if reply == QtGui.QMessageBox.Yes:
+        reply = QtWidgets.QMessageBox.warning(
+            self, _translate("MessageView", "Follow external link"),
+            _translate(
+                "MessageView",
+                "The link \"{0}\" will open in a browser. It may be"
+                " a security risk, it could de-anonymise you or download"
+                " malicious data. Are you sure?"
+            ).format(link.toString()),
+            QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)
+        if reply == QtWidgets.QMessageBox.Yes:
             QtGui.QDesktopServices.openUrl(link)
 
-    def loadResource (self, restype, name):
-        if restype == QtGui.QTextDocument.ImageResource and name.scheme() == "bmmsg":
+    def loadResource(self, restype, name):
+        if restype == QtGui.QTextDocument.ImageResource \
+                and name.scheme() == "bmmsg":
             pass
-#            QImage correctImage;
-#            lookup the correct QImage from a cache
-#            return QVariant::fromValue(correctImage);
-#        elif restype == QtGui.QTextDocument.HtmlResource:
-#        elif restype == QtGui.QTextDocument.ImageResource:
-#        elif restype == QtGui.QTextDocument.StyleSheetResource:
-#        elif restype == QtGui.QTextDocument.UserResource:
         else:
             pass
-#            by default, this will interpret it as a local file
-#            QtGui.QTextBrowser.loadResource(restype, name)
 
     def lazyRender(self):
         if self.rendering:
@@ -96,7 +101,11 @@ class MessageView(QtGui.QTextBrowser):
         self.rendering = True
         position = self.verticalScrollBar().value()
         cursor = QtGui.QTextCursor(self.document())
-        while self.outpos < len(self.out) and self.verticalScrollBar().value() >= self.document().size().height() - 2 * self.size().height():
+        while (
+            self.outpos < len(self.out) and
+            self.verticalScrollBar().value() >=
+            self.document().size().height() - 2 * self.size().height()
+        ):
             startpos = self.outpos
             self.outpos += 10240
             # find next end of tag
@@ -104,16 +113,20 @@ class MessageView(QtGui.QTextBrowser):
                 pos = self.out.find(">", self.outpos)
                 if pos > self.outpos:
                     self.outpos = pos + 1
-            cursor.movePosition(QtGui.QTextCursor.End, QtGui.QTextCursor.MoveAnchor)
-            cursor.insertHtml(QtCore.QString(self.out[startpos:self.outpos]))
+            cursor.movePosition(
+                QtGui.QTextCursor.End, QtGui.QTextCursor.MoveAnchor)
+            cursor.insertHtml(self.out[startpos:self.outpos])
         self.verticalScrollBar().setValue(position)
         self.rendering = False
-    
+
     def showPlain(self):
         self.mode = MessageView.MODE_PLAIN
         out = self.html.raw
         if self.html.has_html:
-            out = "<div align=\"center\" style=\"text-decoration: underline;\"><b>" + unicode(QtGui.QApplication.translate("MessageView", "HTML detected, click here to display")) + "</b></div><br/>" + out
+            out = "<div align=\"center\" style=\"text-decoration: underline;\"><b>" \
+              + _translate(
+                "MessageView", "HTML detected, click here to display") \
+              + "</b></div><br/>" + out
         self.out = out
         self.outpos = 0
         self.setHtml("")
@@ -122,7 +135,10 @@ class MessageView(QtGui.QTextBrowser):
     def showHTML(self):
         self.mode = MessageView.MODE_HTML
         out = self.html.sanitised
-        out = "<div align=\"center\" style=\"text-decoration: underline;\"><b>" + unicode(QtGui.QApplication.translate("MessageView", "Click here to disable HTML")) + "</b></div><br/>" + out
+        out = \
+            "<div align=\"center\" style=\"text-decoration: underline;\"><b>" \
+            + _translate("MessageView", "Click here to disable HTML") \
+            + "</b></div><br/>" + out
         self.out = out
         self.outpos = 0
         self.setHtml("")
@@ -130,8 +146,6 @@ class MessageView(QtGui.QTextBrowser):
 
     def setContent(self, data):
         self.html = SafeHTMLParser()
-        self.html.reset()
-        self.html.reset_safe()
         self.html.allow_picture = True
         self.html.feed(data)
         self.html.close()
diff --git a/src/bitmessageqt/migrationwizard.py b/src/bitmessageqt/migrationwizard.py
index 6e80f1d..ec7899a 100644
--- a/src/bitmessageqt/migrationwizard.py
+++ b/src/bitmessageqt/migrationwizard.py
@@ -1,42 +1,45 @@
-#!/usr/bin/env python2.7
-from PyQt4 import QtCore, QtGui
+from qtpy import QtGui, QtWidgets
 
-class MigrationWizardIntroPage(QtGui.QWizardPage):
+
+class MigrationWizardIntroPage(QtWidgets.QWizardPage):
     def __init__(self):
-        super(QtGui.QWizardPage, self).__init__()
+        super(MigrationWizardIntroPage, self).__init__()
         self.setTitle("Migrating configuration")
 
-        label = QtGui.QLabel("This wizard will help you to migrate your configuration. "
+        label = QtWidgets.QLabel("This wizard will help you to migrate your configuration. "
             "You can still keep using PyBitMessage once you migrate, the changes are backwards compatible.")
         label.setWordWrap(True)
 
-        layout = QtGui.QVBoxLayout()
+        layout = QtWidgets.QVBoxLayout()
         layout.addWidget(label)
         self.setLayout(layout)
-        
+
     def nextId(self):
         return 1
-    
 
-class MigrationWizardAddressesPage(QtGui.QWizardPage):
+
+class MigrationWizardAddressesPage(QtWidgets.QWizardPage):
     def __init__(self, addresses):
-        super(QtGui.QWizardPage, self).__init__()
+        super(MigrationWizardAddressesPage, self).__init__()
         self.setTitle("Addresses")
 
-        label = QtGui.QLabel("Please select addresses that you are already using with mailchuck. ")
+        label = QtWidgets.QLabel(
+            "Please select addresses that you are already using"
+            " with mailchuck. "
+        )
         label.setWordWrap(True)
 
         layout = QtGui.QVBoxLayout()
         layout.addWidget(label)
         self.setLayout(layout)
-        
+
     def nextId(self):
         return 10
-    
 
-class MigrationWizardGPUPage(QtGui.QWizardPage):
+
+class MigrationWizardGPUPage(QtWidgets.QWizardPage):
     def __init__(self):
-        super(QtGui.QWizardPage, self).__init__()
+        super(MigrationWizardGPUPage, self).__init__()
         self.setTitle("GPU")
 
         label = QtGui.QLabel("Are you using a GPU? ")
@@ -45,30 +48,30 @@ class MigrationWizardGPUPage(QtGui.QWizardPage):
         layout = QtGui.QVBoxLayout()
         layout.addWidget(label)
         self.setLayout(layout)
-        
+
     def nextId(self):
         return 10
-    
 
-class MigrationWizardConclusionPage(QtGui.QWizardPage):
+
+class MigrationWizardConclusionPage(QtWidgets.QWizardPage):
     def __init__(self):
-        super(QtGui.QWizardPage, self).__init__()
+        super(MigrationWizardConclusionPage, self).__init__()
         self.setTitle("All done!")
 
-        label = QtGui.QLabel("You successfully migrated.")
+        label = QtWidgets.QLabel("You successfully migrated.")
         label.setWordWrap(True)
 
-        layout = QtGui.QVBoxLayout()
+        layout = QtWidgets.QVBoxLayout()
         layout.addWidget(label)
         self.setLayout(layout)
 
 
-class Ui_MigrationWizard(QtGui.QWizard):
+class Ui_MigrationWizard(QtWidgets.QWizard):
     def __init__(self, addresses):
-        super(QtGui.QWizard, self).__init__()
+        super(Ui_MigrationWizard, self).__init__()
 
         self.pages = {}
-        
+
         page = MigrationWizardIntroPage()
         self.setPage(0, page)
         self.setStartId(0)
@@ -81,4 +84,4 @@ class Ui_MigrationWizard(QtGui.QWizard):
 
         self.setWindowTitle("Migration from PyBitMessage wizard")
         self.adjustSize()
-        self.show()
\ No newline at end of file
+        self.show()
diff --git a/src/bitmessageqt/networkstatus.py b/src/bitmessageqt/networkstatus.py
index 06b1e0c..90ae169 100644
--- a/src/bitmessageqt/networkstatus.py
+++ b/src/bitmessageqt/networkstatus.py
@@ -1,9 +1,9 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
 import time
 import shared
 
 from tr import _translate
-from inventory import Inventory, PendingDownloadQueue, PendingUpload
+from inventory import Inventory
 import knownnodes
 import l10n
 import network.stats
@@ -14,36 +14,37 @@ import widgets
 from network.connectionpool import BMConnectionPool
 
 
-class NetworkStatus(QtGui.QWidget, RetranslateMixin):
+class NetworkStatus(QtWidgets.QWidget, RetranslateMixin):
     def __init__(self, parent=None):
         super(NetworkStatus, self).__init__(parent)
         widgets.load('networkstatus.ui', self)
 
         header = self.tableWidgetConnectionCount.horizontalHeader()
-        header.setResizeMode(QtGui.QHeaderView.ResizeToContents)
+        header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
+        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
 
         # Somehow this value was 5 when I tested
         if header.sortIndicatorSection() > 4:
             header.setSortIndicator(0, QtCore.Qt.AscendingOrder)
 
         self.startup = time.localtime()
-        self.labelStartupTime.setText(_translate("networkstatus", "Since startup on %1").arg(
-            l10n.formatTimestamp(self.startup)))
-        
+        self.labelStartupTime.setText(
+            _translate("networkstatus", "Since startup on {0}").format(
+                l10n.formatTimestamp(self.startup))
+        )
+
         self.UISignalThread = UISignaler.get()
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateNumberOfMessagesProcessed()"), self.updateNumberOfMessagesProcessed)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateNumberOfPubkeysProcessed()"), self.updateNumberOfPubkeysProcessed)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateNumberOfBroadcastsProcessed()"), self.updateNumberOfBroadcastsProcessed)
-        QtCore.QObject.connect(self.UISignalThread, QtCore.SIGNAL(
-            "updateNetworkStatusTab(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), self.updateNetworkStatusTab)
+        self.UISignalThread.updateNumberOfMessagesProcessed.connect(
+            self.updateNumberOfMessagesProcessed)
+        self.UISignalThread.updateNumberOfPubkeysProcessed.connect(
+            self.updateNumberOfPubkeysProcessed)
+        self.UISignalThread.updateNumberOfBroadcastsProcessed.connect(
+            self.updateNumberOfBroadcastsProcessed)
+        self.UISignalThread.updateNetworkStatusTab.connect(
+            self.updateNetworkStatusTab)
 
         self.timer = QtCore.QTimer()
-
-        QtCore.QObject.connect(
-            self.timer, QtCore.SIGNAL("timeout()"), self.runEveryTwoSeconds)
+        self.timer.timeout.connect(self.runEveryTwoSeconds)
 
     def startUpdate(self):
         Inventory().numberOfInventoryLookupsPerformed = 0
@@ -54,7 +55,10 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
         self.timer.stop()
 
     def formatBytes(self, num):
-        for x in [_translate("networkstatus", "byte(s)", None, QtCore.QCoreApplication.CodecForTr, num), "kB", "MB", "GB"]:
+        for x in [
+                _translate("networkstatus", "byte(s)", None, num),
+                "kB", "MB", "GB"
+        ]:
             if num < 1000.0:
                 return "%3.0f %s" % (num, x)
             num /= 1000.0
@@ -63,24 +67,31 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
     def formatByteRate(self, num):
         num /= 1000
         return "%4.0f kB" % num
-        
+
     def updateNumberOfObjectsToBeSynced(self):
-        self.labelSyncStatus.setText(_translate("networkstatus", "Object(s) to be synced: %n", None, QtCore.QCoreApplication.CodecForTr, network.stats.pendingDownload() + network.stats.pendingUpload()))
+        self.labelSyncStatus.setText(
+            _translate(
+                "networkstatus", "Object(s) to be synced: %n", None,
+                network.stats.pendingDownload() + network.stats.pendingUpload()
+        ))
 
     def updateNumberOfMessagesProcessed(self):
         self.updateNumberOfObjectsToBeSynced()
         self.labelMessageCount.setText(_translate(
-            "networkstatus", "Processed %n person-to-person message(s).", None, QtCore.QCoreApplication.CodecForTr, shared.numberOfMessagesProcessed))
+            "networkstatus", "Processed %n person-to-person message(s).",
+            None, shared.numberOfMessagesProcessed))
 
     def updateNumberOfBroadcastsProcessed(self):
         self.updateNumberOfObjectsToBeSynced()
         self.labelBroadcastCount.setText(_translate(
-            "networkstatus", "Processed %n broadcast message(s).", None, QtCore.QCoreApplication.CodecForTr, shared.numberOfBroadcastsProcessed))
+            "networkstatus", "Processed %n broadcast message(s).", None,
+            shared.numberOfBroadcastsProcessed))
 
     def updateNumberOfPubkeysProcessed(self):
         self.updateNumberOfObjectsToBeSynced()
         self.labelPubkeyCount.setText(_translate(
-            "networkstatus", "Processed %n public key(s).", None, QtCore.QCoreApplication.CodecForTr, shared.numberOfPubkeysProcessed))
+            "networkstatus", "Processed %n public key(s).", None,
+            shared.numberOfPubkeysProcessed))
 
     def updateNumberOfBytes(self):
         """
@@ -88,9 +99,16 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
         sent and received by 2.
         """
         self.labelBytesRecvCount.setText(_translate(
-            "networkstatus", "Down: %1/s  Total: %2").arg(self.formatByteRate(network.stats.downloadSpeed()), self.formatBytes(network.stats.receivedBytes())))
+            "networkstatus", "Down: {0}/s  Total: {1}"
+            ).format(
+                self.formatByteRate(network.stats.downloadSpeed()),
+                self.formatBytes(network.stats.receivedBytes())
+        ))
         self.labelBytesSentCount.setText(_translate(
-            "networkstatus", "Up: %1/s  Total: %2").arg(self.formatByteRate(network.stats.uploadSpeed()), self.formatBytes(network.stats.sentBytes())))
+            "networkstatus", "Up: {0}/s  Total: {1}").format(
+                self.formatByteRate(network.stats.uploadSpeed()),
+                self.formatBytes(network.stats.sentBytes())
+        ))
 
     def updateNetworkStatusTab(self, outbound, add, destination):
         if outbound:
@@ -114,16 +132,16 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
         if add:
             self.tableWidgetConnectionCount.insertRow(0)
             self.tableWidgetConnectionCount.setItem(0, 0,
-                QtGui.QTableWidgetItem("%s:%i" % (destination.host, destination.port))
+                QtWidgets.QTableWidgetItem("%s:%i" % (destination.host, destination.port))
                 )
             self.tableWidgetConnectionCount.setItem(0, 2,
-                QtGui.QTableWidgetItem("%s" % (c.userAgent))
+                QtWidgets.QTableWidgetItem("%s" % (c.userAgent))
                 )
             self.tableWidgetConnectionCount.setItem(0, 3,
-                QtGui.QTableWidgetItem("%s" % (c.tlsVersion))
+                QtWidgets.QTableWidgetItem("%s" % (c.tlsVersion))
                 )
             self.tableWidgetConnectionCount.setItem(0, 4,
-                QtGui.QTableWidgetItem("%s" % (",".join(map(str,c.streams))))
+                QtWidgets.QTableWidgetItem("%s" % (",".join(map(str,c.streams))))
                 )
             try:
                 # FIXME hard coded stream no
@@ -131,7 +149,7 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
             except KeyError:
                 rating = "-"
             self.tableWidgetConnectionCount.setItem(0, 1,
-                QtGui.QTableWidgetItem("%s" % (rating))
+                QtWidgets.QTableWidgetItem("%s" % (rating))
                 )
             if outbound:
                 brush = QtGui.QBrush(QtGui.QColor("yellow"), QtCore.Qt.SolidPattern)
@@ -143,15 +161,17 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
             self.tableWidgetConnectionCount.item(0, 1).setData(QtCore.Qt.UserRole, outbound)
         else:
             for i in range(self.tableWidgetConnectionCount.rowCount()):
-                if self.tableWidgetConnectionCount.item(i, 0).data(QtCore.Qt.UserRole).toPyObject() != destination:
+                if self.tableWidgetConnectionCount.item(i, 0).data(QtCore.Qt.UserRole) != destination:
                     continue
-                if self.tableWidgetConnectionCount.item(i, 1).data(QtCore.Qt.UserRole).toPyObject() == outbound:
+                if self.tableWidgetConnectionCount.item(i, 1).data(QtCore.Qt.UserRole) == outbound:
                     self.tableWidgetConnectionCount.removeRow(i)
                     break
         self.tableWidgetConnectionCount.setUpdatesEnabled(True)
         self.tableWidgetConnectionCount.setSortingEnabled(True)
         self.labelTotalConnections.setText(_translate(
-            "networkstatus", "Total Connections: %1").arg(str(self.tableWidgetConnectionCount.rowCount())))
+            "networkstatus", "Total Connections: {0}").format(
+                self.tableWidgetConnectionCount.rowCount()
+        ))
        # FYI: The 'singlelistener' thread sets the icon color to green when it receives an incoming connection, meaning that the user's firewall is configured correctly.
         if self.tableWidgetConnectionCount.rowCount() and shared.statusIconColor == 'red':
             self.window().setStatusIcon('yellow')
@@ -161,12 +181,16 @@ class NetworkStatus(QtGui.QWidget, RetranslateMixin):
     # timer driven
     def runEveryTwoSeconds(self):
         self.labelLookupsPerSecond.setText(_translate(
-            "networkstatus", "Inventory lookups per second: %1").arg(str(Inventory().numberOfInventoryLookupsPerformed/2)))
+            "networkstatus", "Inventory lookups per second: {0}").format(
+                Inventory().numberOfInventoryLookupsPerformed/2
+        ))
         Inventory().numberOfInventoryLookupsPerformed = 0
         self.updateNumberOfBytes()
         self.updateNumberOfObjectsToBeSynced()
 
     def retranslateUi(self):
         super(NetworkStatus, self).retranslateUi()
-        self.labelStartupTime.setText(_translate("networkstatus", "Since startup on %1").arg(
-            l10n.formatTimestamp(self.startup)))
+        self.labelStartupTime.setText(
+            _translate("networkstatus", "Since startup on {0}").format(
+                l10n.formatTimestamp(self.startup)
+            ))
diff --git a/src/bitmessageqt/networkstatus.ui b/src/bitmessageqt/networkstatus.ui
index e0c01b5..14aeca6 100644
--- a/src/bitmessageqt/networkstatus.ui
+++ b/src/bitmessageqt/networkstatus.ui
@@ -296,7 +296,7 @@
   <customwidget>
    <class>STableWidget</class>
    <extends>QTableWidget</extends>
-   <header>bitmessageqt/settingsmixin.h</header>
+   <header>bitmessageqt.settingsmixin</header>
   </customwidget>
  </customwidgets>
  <resources>
diff --git a/src/bitmessageqt/newaddressdialog.ui b/src/bitmessageqt/newaddressdialog.ui
index a9eda5c..0f8c33d 100644
--- a/src/bitmessageqt/newaddressdialog.ui
+++ b/src/bitmessageqt/newaddressdialog.ui
@@ -375,7 +375,7 @@ The 'Random Number' option is selected by default but deterministic addresses ha
    <sender>radioButtonDeterministicAddress</sender>
    <signal>toggled(bool)</signal>
    <receiver>groupBoxDeterministic</receiver>
-   <slot>setShown(bool)</slot>
+   <slot>setVisible(bool)</slot>
    <hints>
     <hint type="sourcelabel">
      <x>92</x>
@@ -391,7 +391,7 @@ The 'Random Number' option is selected by default but deterministic addresses ha
    <sender>radioButtonRandomAddress</sender>
    <signal>toggled(bool)</signal>
    <receiver>groupBox</receiver>
-   <slot>setShown(bool)</slot>
+   <slot>setVisible(bool)</slot>
    <hints>
     <hint type="sourcelabel">
      <x>72</x>
diff --git a/src/bitmessageqt/newchandialog.py b/src/bitmessageqt/newchandialog.py
index ed683b1..c31baa0 100644
--- a/src/bitmessageqt/newchandialog.py
+++ b/src/bitmessageqt/newchandialog.py
@@ -1,24 +1,31 @@
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtWidgets
 
 from addresses import addBMIfNotPresent
 from addressvalidator import AddressValidator, PassPhraseValidator
-from queues import apiAddressGeneratorReturnQueue, addressGeneratorQueue, UISignalQueue
+from queues import (
+    apiAddressGeneratorReturnQueue, addressGeneratorQueue, UISignalQueue)
 from retranslateui import RetranslateMixin
 from tr import _translate
 from utils import str_chan
 import widgets
 
-class NewChanDialog(QtGui.QDialog, RetranslateMixin):
+
+class NewChanDialog(QtWidgets.QDialog, RetranslateMixin):
     def __init__(self, parent=None):
         super(NewChanDialog, self).__init__(parent)
         widgets.load('newchandialog.ui', self)
         self.parent = parent
-        self.chanAddress.setValidator(AddressValidator(self.chanAddress, self.chanPassPhrase, self.validatorFeedback, self.buttonBox, False))
-        self.chanPassPhrase.setValidator(PassPhraseValidator(self.chanPassPhrase, self.chanAddress, self.validatorFeedback, self.buttonBox, False))
+        self.chanAddress.setValidator(AddressValidator(
+            self.chanAddress, self.chanPassPhrase,
+            self.validatorFeedback,
+            self.buttonBox.button(QtWidgets.QDialogButtonBox.Ok), False))
+        self.chanPassPhrase.setValidator(PassPhraseValidator(
+            self.chanPassPhrase, self.chanAddress, self.validatorFeedback,
+            self.buttonBox.button(QtWidgets.QDialogButtonBox.Ok), False))
 
         self.timer = QtCore.QTimer()
-        QtCore.QObject.connect(self.timer, QtCore.SIGNAL("timeout()"), self.delayedUpdateStatus)
-        self.timer.start(500) # milliseconds
+        self.timer.timeout.connect(self.delayedUpdateStatus)
+        self.timer.start(500)  # milliseconds
         self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
         self.show()
 
@@ -29,23 +36,47 @@ class NewChanDialog(QtGui.QDialog, RetranslateMixin):
         self.timer.stop()
         self.hide()
         apiAddressGeneratorReturnQueue.queue.clear()
-        if self.chanAddress.text().toUtf8() == "":
-            addressGeneratorQueue.put(('createChan', 4, 1, str_chan + ' ' + str(self.chanPassPhrase.text().toUtf8()), self.chanPassPhrase.text().toUtf8(), True))
+        if self.chanAddress.text() == "":
+            addressGeneratorQueue.put((
+                'createChan', 4, 1,
+                str_chan + ' ' + str(self.chanPassPhrase.text()),
+                self.chanPassPhrase.text().encode('utf-8'), True
+            ))
         else:
-            addressGeneratorQueue.put(('joinChan', addBMIfNotPresent(self.chanAddress.text().toUtf8()), str_chan + ' ' + str(self.chanPassPhrase.text().toUtf8()), self.chanPassPhrase.text().toUtf8(), True))
+            addressGeneratorQueue.put((
+                'joinChan', addBMIfNotPresent(self.chanAddress.text()),
+                str_chan + ' ' + str(self.chanPassPhrase.text()),
+                self.chanPassPhrase.text().encode('utf-8'), True
+            ))
         addressGeneratorReturnValue = apiAddressGeneratorReturnQueue.get(True)
-        if len(addressGeneratorReturnValue) > 0 and addressGeneratorReturnValue[0] != 'chan name does not match address':
-            UISignalQueue.put(('updateStatusBar', _translate("newchandialog", "Successfully created / joined chan %1").arg(unicode(self.chanPassPhrase.text()))))
+        if (len(addressGeneratorReturnValue) > 0
+            and addressGeneratorReturnValue[0] !=
+                'chan name does not match address'):
+            UISignalQueue.put((
+                'updateStatusBar',
+                _translate(
+                    "newchandialog",
+                    "Successfully created / joined chan {0}"
+                ).format(self.chanPassPhrase.text())
+            ))
             self.parent.ui.tabWidget.setCurrentIndex(
                 self.parent.ui.tabWidget.indexOf(self.parent.ui.chans)
             )
-            self.done(QtGui.QDialog.Accepted)
+            self.done(QtWidgets.QDialog.Accepted)
         else:
-            UISignalQueue.put(('updateStatusBar', _translate("newchandialog", "Chan creation / joining failed")))
-            self.done(QtGui.QDialog.Rejected)
+            UISignalQueue.put((
+                'updateStatusBar',
+                _translate(
+                    "newchandialog", "Chan creation / joining failed")
+            ))
+            self.done(QtWidgets.QDialog.Rejected)
 
     def reject(self):
         self.timer.stop()
         self.hide()
-        UISignalQueue.put(('updateStatusBar', _translate("newchandialog", "Chan creation / joining cancelled")))
-        self.done(QtGui.QDialog.Rejected)
+        UISignalQueue.put((
+            'updateStatusBar',
+            _translate(
+                "newchandialog", "Chan creation / joining cancelled")
+        ))
+        self.done(QtWidgets.QDialog.Rejected)
diff --git a/src/bitmessageqt/retranslateui.py b/src/bitmessageqt/retranslateui.py
index e9d5bb3..706c3e8 100644
--- a/src/bitmessageqt/retranslateui.py
+++ b/src/bitmessageqt/retranslateui.py
@@ -1,18 +1,20 @@
-from os import path
-from PyQt4 import QtGui
-from debug import logger
+from qtpy import QtWidgets
+
 import widgets
 
+
 class RetranslateMixin(object):
     def retranslateUi(self):
-        defaults = QtGui.QWidget()
+        defaults = QtWidgets.QWidget()
         widgets.load(self.__class__.__name__.lower() + '.ui', defaults)
         for attr, value in defaults.__dict__.iteritems():
             setTextMethod = getattr(value, "setText", None)
             if callable(setTextMethod):
                 getattr(self, attr).setText(getattr(defaults, attr).text())
-            elif isinstance(value, QtGui.QTableWidget):
-                for i in range (value.columnCount()):
-                    getattr(self, attr).horizontalHeaderItem(i).setText(getattr(defaults, attr).horizontalHeaderItem(i).text())
-                for i in range (value.rowCount()):
-                    getattr(self, attr).verticalHeaderItem(i).setText(getattr(defaults, attr).verticalHeaderItem(i).text())
+            elif isinstance(value, QtWidgets.QTableWidget):
+                for i in range(value.columnCount()):
+                    getattr(self, attr).horizontalHeaderItem(i).setText(
+                        getattr(defaults, attr).horizontalHeaderItem(i).text())
+                for i in range(value.rowCount()):
+                    getattr(self, attr).verticalHeaderItem(i).setText(
+                        getattr(defaults, attr).verticalHeaderItem(i).text())
diff --git a/src/bitmessageqt/safehtmlparser.py b/src/bitmessageqt/safehtmlparser.py
index d1d7910..54cb342 100644
--- a/src/bitmessageqt/safehtmlparser.py
+++ b/src/bitmessageqt/safehtmlparser.py
@@ -1,31 +1,38 @@
 from HTMLParser import HTMLParser
 import inspect
 import re
-from urllib import quote, quote_plus
+from urllib import quote_plus
 from urlparse import urlparse
 
+
 class SafeHTMLParser(HTMLParser):
     # from html5lib.sanitiser
-    acceptable_elements = ['a', 'abbr', 'acronym', 'address', 'area',
-                           'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',
-                           'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',
-                           'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',
-                           'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',
-                           'figcaption', 'figure', 'footer', 'font', 'header', 'h1',
-                           'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins',
-                           'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',
-                           'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',
-                           'p', 'pre', 'progress', 'q', 's', 'samp', 'section', 'select',
-                           'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong',
-                           'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',
-                           'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video']
-    replaces_pre = [["&", "&amp;"], ["\"", "&quot;"], ["<", "&lt;"], [">", "&gt;"]]
-    replaces_post = [["\n", "<br/>"], ["\t", "&nbsp;&nbsp;&nbsp;&nbsp;"], ["  ", "&nbsp; "], ["  ", "&nbsp; "], ["<br/> ", "<br/>&nbsp;"]]
-    src_schemes = [ "data" ]
+    acceptable_elements = [
+        'a', 'abbr', 'acronym', 'address', 'area',
+        'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',
+        'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',
+        'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',
+        'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',
+        'figcaption', 'figure', 'footer', 'font', 'header', 'h1',
+        'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins',
+        'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',
+        'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',
+        'p', 'pre', 'progress', 'q', 's', 'samp', 'section', 'select',
+        'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong',
+        'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',
+        'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video'
+    ]
+    replaces_pre = [
+        ["&", "&amp;"], ["\"", "&quot;"], ["<", "&lt;"], [">", "&gt;"]]
+    replaces_post = [
+        ["\n", "<br/>"], ["\t", "&nbsp;&nbsp;&nbsp;&nbsp;"], ["  ", "&nbsp; "],
+        ["  ", "&nbsp; "], ["<br/> ", "<br/>&nbsp;"]]
+    src_schemes = ["data"]
     #uriregex1 = re.compile(r'(?i)\b((?:(https?|ftp|bitcoin):(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?]))')
     uriregex1 = re.compile(r'((https?|ftp|bitcoin):(?:/{1,3}|[a-z0-9%])(?:[a-zA-Z]|[0-9]|[$-_@.&+#]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)')
     uriregex2 = re.compile(r'<a href="([^"]+)&amp;')
-    emailregex = re.compile(r'\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\b')
+    emailregex = re.compile(
+        r'\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\b')
 
     @staticmethod
     def replace_pre(text):
@@ -43,8 +50,9 @@ class SafeHTMLParser(HTMLParser):
 
     def __init__(self, *args, **kwargs):
         HTMLParser.__init__(self, *args, **kwargs)
+        self.reset()
         self.reset_safe()
-        
+
     def reset_safe(self):
         self.elements = set()
         self.raw = u""
@@ -53,8 +61,8 @@ class SafeHTMLParser(HTMLParser):
         self.allow_picture = False
         self.allow_external_src = False
 
-    def add_if_acceptable(self, tag, attrs = None):
-        if tag not in SafeHTMLParser.acceptable_elements:
+    def add_if_acceptable(self, tag, attrs=None):
+        if tag not in self.acceptable_elements:
             return
         self.sanitised += "<"
         if inspect.stack()[1][3] == "handle_endtag":
@@ -66,7 +74,7 @@ class SafeHTMLParser(HTMLParser):
                     val = ""
                 elif attr == "src" and not self.allow_external_src:
                     url = urlparse(val)
-                    if url.scheme not in SafeHTMLParser.src_schemes:
+                    if url.scheme not in self.src_schemes:
                         val = ""
                 self.sanitised += " " + quote_plus(attr)
                 if not (val is None):
@@ -74,45 +82,40 @@ class SafeHTMLParser(HTMLParser):
         if inspect.stack()[1][3] == "handle_startendtag":
             self.sanitised += "/"
         self.sanitised += ">"
-    
+
     def handle_starttag(self, tag, attrs):
-        if tag in SafeHTMLParser.acceptable_elements:
+        if tag in self.acceptable_elements:
             self.has_html = True
         self.add_if_acceptable(tag, attrs)
 
     def handle_endtag(self, tag):
         self.add_if_acceptable(tag)
-        
+
     def handle_startendtag(self, tag, attrs):
-        if tag in SafeHTMLParser.acceptable_elements:
+        if tag in self.acceptable_elements:
             self.has_html = True
         self.add_if_acceptable(tag, attrs)
-    
+
     def handle_data(self, data):
+        # print("got data of type %r: %r" % (type(data), data))
         self.sanitised += data
-        
+
     def handle_charref(self, name):
         self.sanitised += "&#" + name + ";"
-    
+
     def handle_entityref(self, name):
         self.sanitised += "&" + name + ";"
 
     def feed(self, data):
-        try:
-            data = unicode(data, 'utf-8')
-        except UnicodeDecodeError:
-            data = unicode(data, 'utf-8', errors='replace')
         HTMLParser.feed(self, data)
         tmp = SafeHTMLParser.replace_pre(data)
-        tmp = SafeHTMLParser.uriregex1.sub(
-            r'<a href="\1">\1</a>',
-            tmp)
-        tmp = SafeHTMLParser.uriregex2.sub(r'<a href="\1&', tmp)
-        tmp = SafeHTMLParser.emailregex.sub(r'<a href="mailto:\1">\1</a>', tmp)
+        tmp = self.uriregex1.sub(r'<a href="\1">\1</a>', tmp)
+        tmp = self.uriregex2.sub(r'<a href="\1&', tmp)
+        tmp = self.emailregex.sub(r'<a href="mailto:\1">\1</a>', tmp)
         tmp = SafeHTMLParser.replace_post(tmp)
         self.raw += tmp
 
-    def is_html(self, text = None, allow_picture = False):
+    def is_html(self, text=None, allow_picture=False):
         if text:
             self.reset()
             self.reset_safe()
diff --git a/src/bitmessageqt/settings.py b/src/bitmessageqt/settings.py
index 4342fd0..37eb3fb 100644
--- a/src/bitmessageqt/settings.py
+++ b/src/bitmessageqt/settings.py
@@ -1,441 +1,426 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'settings.ui'
-#
-# Created: Thu Dec 25 23:21:20 2014
-#      by: PyQt4 UI code generator 4.10.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
+from qtpy import QtCore, QtGui, QtWidgets
 from languagebox import LanguageBox
 from sys import platform
 
-try:
-    _fromUtf8 = QtCore.QString.fromUtf8
-except AttributeError:
-    def _fromUtf8(s):
-        return s
+from tr import _translate
 
-try:
-    _encoding = QtGui.QApplication.UnicodeUTF8
-    def _translate(context, text, disambig):
-        return QtGui.QApplication.translate(context, text, disambig, _encoding)
-except AttributeError:
-    def _translate(context, text, disambig):
-        return QtGui.QApplication.translate(context, text, disambig)
 
 class Ui_settingsDialog(object):
     def setupUi(self, settingsDialog):
-        settingsDialog.setObjectName(_fromUtf8("settingsDialog"))
+        settingsDialog.setObjectName("settingsDialog")
         settingsDialog.resize(521, 413)
-        self.gridLayout = QtGui.QGridLayout(settingsDialog)
-        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
-        self.buttonBox = QtGui.QDialogButtonBox(settingsDialog)
+        self.gridLayout = QtWidgets.QGridLayout(settingsDialog)
+        self.gridLayout.setObjectName("gridLayout")
+        self.buttonBox = QtWidgets.QDialogButtonBox(settingsDialog)
         self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
+        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
         self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)
-        self.tabWidgetSettings = QtGui.QTabWidget(settingsDialog)
-        self.tabWidgetSettings.setObjectName(_fromUtf8("tabWidgetSettings"))
-        self.tabUserInterface = QtGui.QWidget()
+        self.tabWidgetSettings = QtWidgets.QTabWidget(settingsDialog)
+        self.tabWidgetSettings.setObjectName("tabWidgetSettings")
+        self.tabUserInterface = QtWidgets.QWidget()
         self.tabUserInterface.setEnabled(True)
-        self.tabUserInterface.setObjectName(_fromUtf8("tabUserInterface"))
-        self.formLayout = QtGui.QFormLayout(self.tabUserInterface)
-        self.formLayout.setObjectName(_fromUtf8("formLayout"))
-        self.checkBoxStartOnLogon = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxStartOnLogon.setObjectName(_fromUtf8("checkBoxStartOnLogon"))
-        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.checkBoxStartOnLogon)
-        self.groupBoxTray = QtGui.QGroupBox(self.tabUserInterface)
-        self.groupBoxTray.setObjectName(_fromUtf8("groupBoxTray"))
-        self.formLayoutTray = QtGui.QFormLayout(self.groupBoxTray)
-        self.formLayoutTray.setObjectName(_fromUtf8("formLayoutTray"))
-        self.checkBoxStartInTray = QtGui.QCheckBox(self.groupBoxTray)
-        self.checkBoxStartInTray.setObjectName(_fromUtf8("checkBoxStartInTray"))
-        self.formLayoutTray.setWidget(0, QtGui.QFormLayout.SpanningRole, self.checkBoxStartInTray)
-        self.checkBoxMinimizeToTray = QtGui.QCheckBox(self.groupBoxTray)
+        self.tabUserInterface.setObjectName("tabUserInterface")
+        self.formLayout = QtWidgets.QFormLayout(self.tabUserInterface)
+        self.formLayout.setObjectName("formLayout")
+        self.checkBoxStartOnLogon = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxStartOnLogon.setObjectName("checkBoxStartOnLogon")
+        self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.checkBoxStartOnLogon)
+        self.groupBoxTray = QtWidgets.QGroupBox(self.tabUserInterface)
+        self.groupBoxTray.setObjectName("groupBoxTray")
+        self.formLayoutTray = QtWidgets.QFormLayout(self.groupBoxTray)
+        self.formLayoutTray.setObjectName("formLayoutTray")
+        self.checkBoxStartInTray = QtWidgets.QCheckBox(self.groupBoxTray)
+        self.checkBoxStartInTray.setObjectName("checkBoxStartInTray")
+        self.formLayoutTray.setWidget(0, QtWidgets.QFormLayout.SpanningRole, self.checkBoxStartInTray)
+        self.checkBoxMinimizeToTray = QtWidgets.QCheckBox(self.groupBoxTray)
         self.checkBoxMinimizeToTray.setChecked(True)
-        self.checkBoxMinimizeToTray.setObjectName(_fromUtf8("checkBoxMinimizeToTray"))
-        self.formLayoutTray.setWidget(1, QtGui.QFormLayout.LabelRole, self.checkBoxMinimizeToTray)
-        self.checkBoxTrayOnClose = QtGui.QCheckBox(self.groupBoxTray)
+        self.checkBoxMinimizeToTray.setObjectName("checkBoxMinimizeToTray")
+        self.formLayoutTray.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.checkBoxMinimizeToTray)
+        self.checkBoxTrayOnClose = QtWidgets.QCheckBox(self.groupBoxTray)
         self.checkBoxTrayOnClose.setChecked(True)
-        self.checkBoxTrayOnClose.setObjectName(_fromUtf8("checkBoxTrayOnClose"))
-        self.formLayoutTray.setWidget(2, QtGui.QFormLayout.LabelRole, self.checkBoxTrayOnClose)
-        self.formLayout.setWidget(1, QtGui.QFormLayout.SpanningRole, self.groupBoxTray)
-        self.checkBoxHideTrayConnectionNotifications = QtGui.QCheckBox(self.tabUserInterface)
+        self.checkBoxTrayOnClose.setObjectName("checkBoxTrayOnClose")
+        self.formLayoutTray.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.checkBoxTrayOnClose)
+        self.formLayout.setWidget(1, QtWidgets.QFormLayout.SpanningRole, self.groupBoxTray)
+        self.checkBoxHideTrayConnectionNotifications = QtWidgets.QCheckBox(self.tabUserInterface)
         self.checkBoxHideTrayConnectionNotifications.setChecked(False)
-        self.checkBoxHideTrayConnectionNotifications.setObjectName(_fromUtf8("checkBoxHideTrayConnectionNotifications"))
-        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.checkBoxHideTrayConnectionNotifications)
-        self.checkBoxShowTrayNotifications = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxShowTrayNotifications.setObjectName(_fromUtf8("checkBoxShowTrayNotifications"))
-        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.checkBoxShowTrayNotifications)
-        self.checkBoxPortableMode = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxPortableMode.setObjectName(_fromUtf8("checkBoxPortableMode"))
-        self.formLayout.setWidget(4, QtGui.QFormLayout.LabelRole, self.checkBoxPortableMode)
-        self.PortableModeDescription = QtGui.QLabel(self.tabUserInterface)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
+        self.checkBoxHideTrayConnectionNotifications.setObjectName("checkBoxHideTrayConnectionNotifications")
+        self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.checkBoxHideTrayConnectionNotifications)
+        self.checkBoxShowTrayNotifications = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxShowTrayNotifications.setObjectName("checkBoxShowTrayNotifications")
+        self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.checkBoxShowTrayNotifications)
+        self.checkBoxPortableMode = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxPortableMode.setObjectName("checkBoxPortableMode")
+        self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.checkBoxPortableMode)
+        self.PortableModeDescription = QtWidgets.QLabel(self.tabUserInterface)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.PortableModeDescription.sizePolicy().hasHeightForWidth())
         self.PortableModeDescription.setSizePolicy(sizePolicy)
         self.PortableModeDescription.setWordWrap(True)
-        self.PortableModeDescription.setObjectName(_fromUtf8("PortableModeDescription"))
-        self.formLayout.setWidget(5, QtGui.QFormLayout.SpanningRole, self.PortableModeDescription)
-        self.checkBoxWillinglySendToMobile = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxWillinglySendToMobile.setObjectName(_fromUtf8("checkBoxWillinglySendToMobile"))
-        self.formLayout.setWidget(6, QtGui.QFormLayout.SpanningRole, self.checkBoxWillinglySendToMobile)
-        self.checkBoxUseIdenticons = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxUseIdenticons.setObjectName(_fromUtf8("checkBoxUseIdenticons"))
-        self.formLayout.setWidget(7, QtGui.QFormLayout.LabelRole, self.checkBoxUseIdenticons)
-        self.checkBoxReplyBelow = QtGui.QCheckBox(self.tabUserInterface)
-        self.checkBoxReplyBelow.setObjectName(_fromUtf8("checkBoxReplyBelow"))
-        self.formLayout.setWidget(8, QtGui.QFormLayout.LabelRole, self.checkBoxReplyBelow)
-        self.groupBox = QtGui.QGroupBox(self.tabUserInterface)
-        self.groupBox.setObjectName(_fromUtf8("groupBox"))
-        self.formLayout_2 = QtGui.QFormLayout(self.groupBox)
-        self.formLayout_2.setObjectName(_fromUtf8("formLayout_2"))
+        self.PortableModeDescription.setObjectName("PortableModeDescription")
+        self.formLayout.setWidget(5, QtWidgets.QFormLayout.SpanningRole, self.PortableModeDescription)
+        self.checkBoxWillinglySendToMobile = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxWillinglySendToMobile.setObjectName("checkBoxWillinglySendToMobile")
+        self.formLayout.setWidget(6, QtWidgets.QFormLayout.SpanningRole, self.checkBoxWillinglySendToMobile)
+        self.checkBoxUseIdenticons = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxUseIdenticons.setObjectName("checkBoxUseIdenticons")
+        self.formLayout.setWidget(7, QtWidgets.QFormLayout.LabelRole, self.checkBoxUseIdenticons)
+        self.checkBoxReplyBelow = QtWidgets.QCheckBox(self.tabUserInterface)
+        self.checkBoxReplyBelow.setObjectName("checkBoxReplyBelow")
+        self.formLayout.setWidget(8, QtWidgets.QFormLayout.LabelRole, self.checkBoxReplyBelow)
+        self.groupBox = QtWidgets.QGroupBox(self.tabUserInterface)
+        self.groupBox.setObjectName("groupBox")
+        self.formLayout_2 = QtWidgets.QFormLayout(self.groupBox)
+        self.formLayout_2.setObjectName("formLayout_2")
         self.languageComboBox = LanguageBox(self.groupBox)
         self.languageComboBox.setMinimumSize(QtCore.QSize(100, 0))
-        self.languageComboBox.setObjectName(_fromUtf8("languageComboBox"))
-        self.formLayout_2.setWidget(0, QtGui.QFormLayout.LabelRole, self.languageComboBox)
-        self.formLayout.setWidget(9, QtGui.QFormLayout.FieldRole, self.groupBox)
-        self.tabWidgetSettings.addTab(self.tabUserInterface, _fromUtf8(""))
-        self.tabNetworkSettings = QtGui.QWidget()
-        self.tabNetworkSettings.setObjectName(_fromUtf8("tabNetworkSettings"))
-        self.gridLayout_4 = QtGui.QGridLayout(self.tabNetworkSettings)
-        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
-        self.groupBox1 = QtGui.QGroupBox(self.tabNetworkSettings)
-        self.groupBox1.setObjectName(_fromUtf8("groupBox1"))
-        self.gridLayout_3 = QtGui.QGridLayout(self.groupBox1)
-        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
-        #spacerItem = QtGui.QSpacerItem(125, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.languageComboBox.setObjectName("languageComboBox")
+        self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.languageComboBox)
+        self.formLayout.setWidget(9, QtWidgets.QFormLayout.FieldRole, self.groupBox)
+        self.tabWidgetSettings.addTab(self.tabUserInterface, "")
+        self.tabNetworkSettings = QtWidgets.QWidget()
+        self.tabNetworkSettings.setObjectName("tabNetworkSettings")
+        self.gridLayout_4 = QtWidgets.QGridLayout(self.tabNetworkSettings)
+        self.gridLayout_4.setObjectName("gridLayout_4")
+        self.groupBox1 = QtWidgets.QGroupBox(self.tabNetworkSettings)
+        self.groupBox1.setObjectName("groupBox1")
+        self.gridLayout_3 = QtWidgets.QGridLayout(self.groupBox1)
+        self.gridLayout_3.setObjectName("gridLayout_3")
+        #spacerItem = QtWidgets.QSpacerItem(125, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         #self.gridLayout_3.addItem(spacerItem, 0, 0, 1, 1)
-        self.label = QtGui.QLabel(self.groupBox1)
-        self.label.setObjectName(_fromUtf8("label"))
+        self.label = QtWidgets.QLabel(self.groupBox1)
+        self.label.setObjectName("label")
         self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1, QtCore.Qt.AlignRight)
-        self.lineEditTCPPort = QtGui.QLineEdit(self.groupBox1)
+        self.lineEditTCPPort = QtWidgets.QLineEdit(self.groupBox1)
         self.lineEditTCPPort.setMaximumSize(QtCore.QSize(70, 16777215))
-        self.lineEditTCPPort.setObjectName(_fromUtf8("lineEditTCPPort"))
+        self.lineEditTCPPort.setObjectName("lineEditTCPPort")
         self.gridLayout_3.addWidget(self.lineEditTCPPort, 0, 1, 1, 1, QtCore.Qt.AlignLeft)
-        self.labelUPnP = QtGui.QLabel(self.groupBox1)
-        self.labelUPnP.setObjectName(_fromUtf8("labelUPnP"))
+        self.labelUPnP = QtWidgets.QLabel(self.groupBox1)
+        self.labelUPnP.setObjectName("labelUPnP")
         self.gridLayout_3.addWidget(self.labelUPnP, 0, 2, 1, 1, QtCore.Qt.AlignRight)
-        self.checkBoxUPnP = QtGui.QCheckBox(self.groupBox1)
-        self.checkBoxUPnP.setObjectName(_fromUtf8("checkBoxUPnP"))
+        self.checkBoxUPnP = QtWidgets.QCheckBox(self.groupBox1)
+        self.checkBoxUPnP.setObjectName("checkBoxUPnP")
         self.gridLayout_3.addWidget(self.checkBoxUPnP, 0, 3, 1, 1, QtCore.Qt.AlignLeft)
         self.gridLayout_4.addWidget(self.groupBox1, 0, 0, 1, 1)
-        self.groupBox_3 = QtGui.QGroupBox(self.tabNetworkSettings)
-        self.groupBox_3.setObjectName(_fromUtf8("groupBox_3"))
-        self.gridLayout_9 = QtGui.QGridLayout(self.groupBox_3)
-        self.gridLayout_9.setObjectName(_fromUtf8("gridLayout_9"))
-        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.groupBox_3 = QtWidgets.QGroupBox(self.tabNetworkSettings)
+        self.groupBox_3.setObjectName("groupBox_3")
+        self.gridLayout_9 = QtWidgets.QGridLayout(self.groupBox_3)
+        self.gridLayout_9.setObjectName("gridLayout_9")
+        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_9.addItem(spacerItem1, 0, 0, 2, 1)
-        self.label_24 = QtGui.QLabel(self.groupBox_3)
-        self.label_24.setObjectName(_fromUtf8("label_24"))
+        self.label_24 = QtWidgets.QLabel(self.groupBox_3)
+        self.label_24.setObjectName("label_24")
         self.gridLayout_9.addWidget(self.label_24, 0, 1, 1, 1)
-        self.lineEditMaxDownloadRate = QtGui.QLineEdit(self.groupBox_3)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditMaxDownloadRate = QtWidgets.QLineEdit(self.groupBox_3)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditMaxDownloadRate.sizePolicy().hasHeightForWidth())
         self.lineEditMaxDownloadRate.setSizePolicy(sizePolicy)
         self.lineEditMaxDownloadRate.setMaximumSize(QtCore.QSize(60, 16777215))
-        self.lineEditMaxDownloadRate.setObjectName(_fromUtf8("lineEditMaxDownloadRate"))
+        self.lineEditMaxDownloadRate.setObjectName("lineEditMaxDownloadRate")
         self.gridLayout_9.addWidget(self.lineEditMaxDownloadRate, 0, 2, 1, 1)
-        self.label_25 = QtGui.QLabel(self.groupBox_3)
-        self.label_25.setObjectName(_fromUtf8("label_25"))
+        self.label_25 = QtWidgets.QLabel(self.groupBox_3)
+        self.label_25.setObjectName("label_25")
         self.gridLayout_9.addWidget(self.label_25, 1, 1, 1, 1)
-        self.lineEditMaxUploadRate = QtGui.QLineEdit(self.groupBox_3)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditMaxUploadRate = QtWidgets.QLineEdit(self.groupBox_3)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditMaxUploadRate.sizePolicy().hasHeightForWidth())
         self.lineEditMaxUploadRate.setSizePolicy(sizePolicy)
         self.lineEditMaxUploadRate.setMaximumSize(QtCore.QSize(60, 16777215))
-        self.lineEditMaxUploadRate.setObjectName(_fromUtf8("lineEditMaxUploadRate"))
+        self.lineEditMaxUploadRate.setObjectName("lineEditMaxUploadRate")
         self.gridLayout_9.addWidget(self.lineEditMaxUploadRate, 1, 2, 1, 1)
-        self.label_26 = QtGui.QLabel(self.groupBox_3)
-        self.label_26.setObjectName(_fromUtf8("label_26"))
+        self.label_26 = QtWidgets.QLabel(self.groupBox_3)
+        self.label_26.setObjectName("label_26")
         self.gridLayout_9.addWidget(self.label_26, 2, 1, 1, 1)
-        self.lineEditMaxOutboundConnections = QtGui.QLineEdit(self.groupBox_3)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditMaxOutboundConnections = QtWidgets.QLineEdit(self.groupBox_3)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditMaxOutboundConnections.sizePolicy().hasHeightForWidth())
         self.lineEditMaxOutboundConnections.setSizePolicy(sizePolicy)
         self.lineEditMaxOutboundConnections.setMaximumSize(QtCore.QSize(60, 16777215))
-        self.lineEditMaxOutboundConnections.setObjectName(_fromUtf8("lineEditMaxOutboundConnections"))
+        self.lineEditMaxOutboundConnections.setObjectName("lineEditMaxOutboundConnections")
         self.lineEditMaxOutboundConnections.setValidator(QtGui.QIntValidator(0, 8, self.lineEditMaxOutboundConnections))
         self.gridLayout_9.addWidget(self.lineEditMaxOutboundConnections, 2, 2, 1, 1)
         self.gridLayout_4.addWidget(self.groupBox_3, 2, 0, 1, 1)
-        self.groupBox_2 = QtGui.QGroupBox(self.tabNetworkSettings)
-        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
-        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox_2)
-        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
-        self.label_2 = QtGui.QLabel(self.groupBox_2)
-        self.label_2.setObjectName(_fromUtf8("label_2"))
+        self.groupBox_2 = QtWidgets.QGroupBox(self.tabNetworkSettings)
+        self.groupBox_2.setObjectName("groupBox_2")
+        self.gridLayout_2 = QtWidgets.QGridLayout(self.groupBox_2)
+        self.gridLayout_2.setObjectName("gridLayout_2")
+        self.label_2 = QtWidgets.QLabel(self.groupBox_2)
+        self.label_2.setObjectName("label_2")
         self.gridLayout_2.addWidget(self.label_2, 0, 0, 1, 1)
-        self.label_3 = QtGui.QLabel(self.groupBox_2)
-        self.label_3.setObjectName(_fromUtf8("label_3"))
+        self.label_3 = QtWidgets.QLabel(self.groupBox_2)
+        self.label_3.setObjectName("label_3")
         self.gridLayout_2.addWidget(self.label_3, 1, 1, 1, 1)
-        self.lineEditSocksHostname = QtGui.QLineEdit(self.groupBox_2)
-        self.lineEditSocksHostname.setObjectName(_fromUtf8("lineEditSocksHostname"))
-        self.lineEditSocksHostname.setPlaceholderText(_fromUtf8("127.0.0.1"))
+        self.lineEditSocksHostname = QtWidgets.QLineEdit(self.groupBox_2)
+        self.lineEditSocksHostname.setObjectName("lineEditSocksHostname")
+        self.lineEditSocksHostname.setPlaceholderText("127.0.0.1")
         self.gridLayout_2.addWidget(self.lineEditSocksHostname, 1, 2, 1, 2)
-        self.label_4 = QtGui.QLabel(self.groupBox_2)
-        self.label_4.setObjectName(_fromUtf8("label_4"))
+        self.label_4 = QtWidgets.QLabel(self.groupBox_2)
+        self.label_4.setObjectName("label_4")
         self.gridLayout_2.addWidget(self.label_4, 1, 4, 1, 1)
-        self.lineEditSocksPort = QtGui.QLineEdit(self.groupBox_2)
-        self.lineEditSocksPort.setObjectName(_fromUtf8("lineEditSocksPort"))
+        self.lineEditSocksPort = QtWidgets.QLineEdit(self.groupBox_2)
+        self.lineEditSocksPort.setObjectName("lineEditSocksPort")
         if platform in ['darwin', 'win32', 'win64']:
-            self.lineEditSocksPort.setPlaceholderText(_fromUtf8("9150"))
+            self.lineEditSocksPort.setPlaceholderText("9150")
         else:
-            self.lineEditSocksPort.setPlaceholderText(_fromUtf8("9050"))
+            self.lineEditSocksPort.setPlaceholderText("9050")
         self.gridLayout_2.addWidget(self.lineEditSocksPort, 1, 5, 1, 1)
-        self.checkBoxAuthentication = QtGui.QCheckBox(self.groupBox_2)
-        self.checkBoxAuthentication.setObjectName(_fromUtf8("checkBoxAuthentication"))
+        self.checkBoxAuthentication = QtWidgets.QCheckBox(self.groupBox_2)
+        self.checkBoxAuthentication.setObjectName("checkBoxAuthentication")
         self.gridLayout_2.addWidget(self.checkBoxAuthentication, 2, 1, 1, 1)
-        self.label_5 = QtGui.QLabel(self.groupBox_2)
-        self.label_5.setObjectName(_fromUtf8("label_5"))
+        self.label_5 = QtWidgets.QLabel(self.groupBox_2)
+        self.label_5.setObjectName("label_5")
         self.gridLayout_2.addWidget(self.label_5, 2, 2, 1, 1)
-        self.lineEditSocksUsername = QtGui.QLineEdit(self.groupBox_2)
+        self.lineEditSocksUsername = QtWidgets.QLineEdit(self.groupBox_2)
         self.lineEditSocksUsername.setEnabled(False)
-        self.lineEditSocksUsername.setObjectName(_fromUtf8("lineEditSocksUsername"))
+        self.lineEditSocksUsername.setObjectName("lineEditSocksUsername")
         self.gridLayout_2.addWidget(self.lineEditSocksUsername, 2, 3, 1, 1)
-        self.label_6 = QtGui.QLabel(self.groupBox_2)
-        self.label_6.setObjectName(_fromUtf8("label_6"))
+        self.label_6 = QtWidgets.QLabel(self.groupBox_2)
+        self.label_6.setObjectName("label_6")
         self.gridLayout_2.addWidget(self.label_6, 2, 4, 1, 1)
-        self.lineEditSocksPassword = QtGui.QLineEdit(self.groupBox_2)
+        self.lineEditSocksPassword = QtWidgets.QLineEdit(self.groupBox_2)
         self.lineEditSocksPassword.setEnabled(False)
         self.lineEditSocksPassword.setInputMethodHints(QtCore.Qt.ImhHiddenText|QtCore.Qt.ImhNoAutoUppercase|QtCore.Qt.ImhNoPredictiveText)
-        self.lineEditSocksPassword.setEchoMode(QtGui.QLineEdit.Password)
-        self.lineEditSocksPassword.setObjectName(_fromUtf8("lineEditSocksPassword"))
+        self.lineEditSocksPassword.setEchoMode(QtWidgets.QLineEdit.Password)
+        self.lineEditSocksPassword.setObjectName("lineEditSocksPassword")
         self.gridLayout_2.addWidget(self.lineEditSocksPassword, 2, 5, 1, 1)
-        self.checkBoxSocksListen = QtGui.QCheckBox(self.groupBox_2)
-        self.checkBoxSocksListen.setObjectName(_fromUtf8("checkBoxSocksListen"))
+        self.checkBoxSocksListen = QtWidgets.QCheckBox(self.groupBox_2)
+        self.checkBoxSocksListen.setObjectName("checkBoxSocksListen")
         self.gridLayout_2.addWidget(self.checkBoxSocksListen, 3, 1, 1, 4)
-        self.comboBoxProxyType = QtGui.QComboBox(self.groupBox_2)
-        self.comboBoxProxyType.setObjectName(_fromUtf8("comboBoxProxyType"))
-        self.comboBoxProxyType.addItem(_fromUtf8(""))
-        self.comboBoxProxyType.addItem(_fromUtf8(""))
-        self.comboBoxProxyType.addItem(_fromUtf8(""))
+        self.comboBoxProxyType = QtWidgets.QComboBox(self.groupBox_2)
+        self.comboBoxProxyType.setObjectName("comboBoxProxyType")
+        self.comboBoxProxyType.addItem("")
+        self.comboBoxProxyType.addItem("")
+        self.comboBoxProxyType.addItem("")
         self.gridLayout_2.addWidget(self.comboBoxProxyType, 0, 1, 1, 1)
         self.gridLayout_4.addWidget(self.groupBox_2, 1, 0, 1, 1)
-        spacerItem2 = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
+        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
         self.gridLayout_4.addItem(spacerItem2, 3, 0, 1, 1)
-        self.tabWidgetSettings.addTab(self.tabNetworkSettings, _fromUtf8(""))
-        self.tabDemandedDifficulty = QtGui.QWidget()
-        self.tabDemandedDifficulty.setObjectName(_fromUtf8("tabDemandedDifficulty"))
-        self.gridLayout_6 = QtGui.QGridLayout(self.tabDemandedDifficulty)
-        self.gridLayout_6.setObjectName(_fromUtf8("gridLayout_6"))
-        self.label_9 = QtGui.QLabel(self.tabDemandedDifficulty)
+        self.tabWidgetSettings.addTab(self.tabNetworkSettings, "")
+        self.tabDemandedDifficulty = QtWidgets.QWidget()
+        self.tabDemandedDifficulty.setObjectName("tabDemandedDifficulty")
+        self.gridLayout_6 = QtWidgets.QGridLayout(self.tabDemandedDifficulty)
+        self.gridLayout_6.setObjectName("gridLayout_6")
+        self.label_9 = QtWidgets.QLabel(self.tabDemandedDifficulty)
         self.label_9.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_9.setObjectName(_fromUtf8("label_9"))
+        self.label_9.setObjectName("label_9")
         self.gridLayout_6.addWidget(self.label_9, 1, 1, 1, 1)
-        self.label_10 = QtGui.QLabel(self.tabDemandedDifficulty)
+        self.label_10 = QtWidgets.QLabel(self.tabDemandedDifficulty)
         self.label_10.setWordWrap(True)
-        self.label_10.setObjectName(_fromUtf8("label_10"))
+        self.label_10.setObjectName("label_10")
         self.gridLayout_6.addWidget(self.label_10, 2, 0, 1, 3)
-        self.label_11 = QtGui.QLabel(self.tabDemandedDifficulty)
+        self.label_11 = QtWidgets.QLabel(self.tabDemandedDifficulty)
         self.label_11.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_11.setObjectName(_fromUtf8("label_11"))
+        self.label_11.setObjectName("label_11")
         self.gridLayout_6.addWidget(self.label_11, 3, 1, 1, 1)
-        self.label_8 = QtGui.QLabel(self.tabDemandedDifficulty)
+        self.label_8 = QtWidgets.QLabel(self.tabDemandedDifficulty)
         self.label_8.setWordWrap(True)
-        self.label_8.setObjectName(_fromUtf8("label_8"))
+        self.label_8.setObjectName("label_8")
         self.gridLayout_6.addWidget(self.label_8, 0, 0, 1, 3)
-        spacerItem3 = QtGui.QSpacerItem(203, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem3 = QtWidgets.QSpacerItem(203, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_6.addItem(spacerItem3, 1, 0, 1, 1)
-        self.label_12 = QtGui.QLabel(self.tabDemandedDifficulty)
+        self.label_12 = QtWidgets.QLabel(self.tabDemandedDifficulty)
         self.label_12.setWordWrap(True)
-        self.label_12.setObjectName(_fromUtf8("label_12"))
+        self.label_12.setObjectName("label_12")
         self.gridLayout_6.addWidget(self.label_12, 4, 0, 1, 3)
-        self.lineEditSmallMessageDifficulty = QtGui.QLineEdit(self.tabDemandedDifficulty)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditSmallMessageDifficulty = QtWidgets.QLineEdit(self.tabDemandedDifficulty)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditSmallMessageDifficulty.sizePolicy().hasHeightForWidth())
         self.lineEditSmallMessageDifficulty.setSizePolicy(sizePolicy)
         self.lineEditSmallMessageDifficulty.setMaximumSize(QtCore.QSize(70, 16777215))
-        self.lineEditSmallMessageDifficulty.setObjectName(_fromUtf8("lineEditSmallMessageDifficulty"))
+        self.lineEditSmallMessageDifficulty.setObjectName("lineEditSmallMessageDifficulty")
         self.gridLayout_6.addWidget(self.lineEditSmallMessageDifficulty, 3, 2, 1, 1)
-        self.lineEditTotalDifficulty = QtGui.QLineEdit(self.tabDemandedDifficulty)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditTotalDifficulty = QtWidgets.QLineEdit(self.tabDemandedDifficulty)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditTotalDifficulty.sizePolicy().hasHeightForWidth())
         self.lineEditTotalDifficulty.setSizePolicy(sizePolicy)
         self.lineEditTotalDifficulty.setMaximumSize(QtCore.QSize(70, 16777215))
-        self.lineEditTotalDifficulty.setObjectName(_fromUtf8("lineEditTotalDifficulty"))
+        self.lineEditTotalDifficulty.setObjectName("lineEditTotalDifficulty")
         self.gridLayout_6.addWidget(self.lineEditTotalDifficulty, 1, 2, 1, 1)
-        spacerItem4 = QtGui.QSpacerItem(203, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem4 = QtWidgets.QSpacerItem(203, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_6.addItem(spacerItem4, 3, 0, 1, 1)
-        spacerItem5 = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
+        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
         self.gridLayout_6.addItem(spacerItem5, 5, 0, 1, 1)
-        self.tabWidgetSettings.addTab(self.tabDemandedDifficulty, _fromUtf8(""))
-        self.tabMaxAcceptableDifficulty = QtGui.QWidget()
-        self.tabMaxAcceptableDifficulty.setObjectName(_fromUtf8("tabMaxAcceptableDifficulty"))
-        self.gridLayout_7 = QtGui.QGridLayout(self.tabMaxAcceptableDifficulty)
-        self.gridLayout_7.setObjectName(_fromUtf8("gridLayout_7"))
-        self.label_15 = QtGui.QLabel(self.tabMaxAcceptableDifficulty)
+        self.tabWidgetSettings.addTab(self.tabDemandedDifficulty, "")
+        self.tabMaxAcceptableDifficulty = QtWidgets.QWidget()
+        self.tabMaxAcceptableDifficulty.setObjectName("tabMaxAcceptableDifficulty")
+        self.gridLayout_7 = QtWidgets.QGridLayout(self.tabMaxAcceptableDifficulty)
+        self.gridLayout_7.setObjectName("gridLayout_7")
+        self.label_15 = QtWidgets.QLabel(self.tabMaxAcceptableDifficulty)
         self.label_15.setWordWrap(True)
-        self.label_15.setObjectName(_fromUtf8("label_15"))
+        self.label_15.setObjectName("label_15")
         self.gridLayout_7.addWidget(self.label_15, 0, 0, 1, 3)
-        spacerItem6 = QtGui.QSpacerItem(102, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem6 = QtWidgets.QSpacerItem(102, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_7.addItem(spacerItem6, 1, 0, 1, 1)
-        self.label_13 = QtGui.QLabel(self.tabMaxAcceptableDifficulty)
+        self.label_13 = QtWidgets.QLabel(self.tabMaxAcceptableDifficulty)
         self.label_13.setLayoutDirection(QtCore.Qt.LeftToRight)
         self.label_13.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_13.setObjectName(_fromUtf8("label_13"))
+        self.label_13.setObjectName("label_13")
         self.gridLayout_7.addWidget(self.label_13, 1, 1, 1, 1)
-        self.lineEditMaxAcceptableTotalDifficulty = QtGui.QLineEdit(self.tabMaxAcceptableDifficulty)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditMaxAcceptableTotalDifficulty = QtWidgets.QLineEdit(self.tabMaxAcceptableDifficulty)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditMaxAcceptableTotalDifficulty.sizePolicy().hasHeightForWidth())
         self.lineEditMaxAcceptableTotalDifficulty.setSizePolicy(sizePolicy)
         self.lineEditMaxAcceptableTotalDifficulty.setMaximumSize(QtCore.QSize(70, 16777215))
-        self.lineEditMaxAcceptableTotalDifficulty.setObjectName(_fromUtf8("lineEditMaxAcceptableTotalDifficulty"))
+        self.lineEditMaxAcceptableTotalDifficulty.setObjectName("lineEditMaxAcceptableTotalDifficulty")
         self.gridLayout_7.addWidget(self.lineEditMaxAcceptableTotalDifficulty, 1, 2, 1, 1)
-        spacerItem7 = QtGui.QSpacerItem(102, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem7 = QtWidgets.QSpacerItem(102, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_7.addItem(spacerItem7, 2, 0, 1, 1)
-        self.label_14 = QtGui.QLabel(self.tabMaxAcceptableDifficulty)
+        self.label_14 = QtWidgets.QLabel(self.tabMaxAcceptableDifficulty)
         self.label_14.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_14.setObjectName(_fromUtf8("label_14"))
+        self.label_14.setObjectName("label_14")
         self.gridLayout_7.addWidget(self.label_14, 2, 1, 1, 1)
-        self.lineEditMaxAcceptableSmallMessageDifficulty = QtGui.QLineEdit(self.tabMaxAcceptableDifficulty)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
+        self.lineEditMaxAcceptableSmallMessageDifficulty = QtWidgets.QLineEdit(self.tabMaxAcceptableDifficulty)
+        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
         sizePolicy.setHorizontalStretch(0)
         sizePolicy.setVerticalStretch(0)
         sizePolicy.setHeightForWidth(self.lineEditMaxAcceptableSmallMessageDifficulty.sizePolicy().hasHeightForWidth())
         self.lineEditMaxAcceptableSmallMessageDifficulty.setSizePolicy(sizePolicy)
         self.lineEditMaxAcceptableSmallMessageDifficulty.setMaximumSize(QtCore.QSize(70, 16777215))
-        self.lineEditMaxAcceptableSmallMessageDifficulty.setObjectName(_fromUtf8("lineEditMaxAcceptableSmallMessageDifficulty"))
+        self.lineEditMaxAcceptableSmallMessageDifficulty.setObjectName("lineEditMaxAcceptableSmallMessageDifficulty")
         self.gridLayout_7.addWidget(self.lineEditMaxAcceptableSmallMessageDifficulty, 2, 2, 1, 1)
-        spacerItem8 = QtGui.QSpacerItem(20, 147, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
+        spacerItem8 = QtWidgets.QSpacerItem(20, 147, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
         self.gridLayout_7.addItem(spacerItem8, 3, 1, 1, 1)
-        self.labelOpenCL = QtGui.QLabel(self.tabMaxAcceptableDifficulty)
-        self.labelOpenCL.setObjectName(_fromUtf8("labelOpenCL"))
+        self.labelOpenCL = QtWidgets.QLabel(self.tabMaxAcceptableDifficulty)
+        self.labelOpenCL.setObjectName("labelOpenCL")
         self.gridLayout_7.addWidget(self.labelOpenCL, 4, 0, 1, 1)
-        self.comboBoxOpenCL = QtGui.QComboBox(self.tabMaxAcceptableDifficulty)
-        self.comboBoxOpenCL.setObjectName = (_fromUtf8("comboBoxOpenCL"))
+        self.comboBoxOpenCL = QtWidgets.QComboBox(self.tabMaxAcceptableDifficulty)
+        self.comboBoxOpenCL.setObjectName = ("comboBoxOpenCL")
         self.gridLayout_7.addWidget(self.comboBoxOpenCL, 4, 1, 1, 1)
-        self.tabWidgetSettings.addTab(self.tabMaxAcceptableDifficulty, _fromUtf8(""))
-        self.tabNamecoin = QtGui.QWidget()
-        self.tabNamecoin.setObjectName(_fromUtf8("tabNamecoin"))
-        self.gridLayout_8 = QtGui.QGridLayout(self.tabNamecoin)
-        self.gridLayout_8.setObjectName(_fromUtf8("gridLayout_8"))
-        spacerItem9 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.tabWidgetSettings.addTab(self.tabMaxAcceptableDifficulty, "")
+        self.tabNamecoin = QtWidgets.QWidget()
+        self.tabNamecoin.setObjectName("tabNamecoin")
+        self.gridLayout_8 = QtWidgets.QGridLayout(self.tabNamecoin)
+        self.gridLayout_8.setObjectName("gridLayout_8")
+        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_8.addItem(spacerItem9, 2, 0, 1, 1)
-        self.label_16 = QtGui.QLabel(self.tabNamecoin)
+        self.label_16 = QtWidgets.QLabel(self.tabNamecoin)
         self.label_16.setWordWrap(True)
-        self.label_16.setObjectName(_fromUtf8("label_16"))
+        self.label_16.setObjectName("label_16")
         self.gridLayout_8.addWidget(self.label_16, 0, 0, 1, 3)
-        self.label_17 = QtGui.QLabel(self.tabNamecoin)
+        self.label_17 = QtWidgets.QLabel(self.tabNamecoin)
         self.label_17.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_17.setObjectName(_fromUtf8("label_17"))
+        self.label_17.setObjectName("label_17")
         self.gridLayout_8.addWidget(self.label_17, 2, 1, 1, 1)
-        self.lineEditNamecoinHost = QtGui.QLineEdit(self.tabNamecoin)
-        self.lineEditNamecoinHost.setObjectName(_fromUtf8("lineEditNamecoinHost"))
+        self.lineEditNamecoinHost = QtWidgets.QLineEdit(self.tabNamecoin)
+        self.lineEditNamecoinHost.setObjectName("lineEditNamecoinHost")
         self.gridLayout_8.addWidget(self.lineEditNamecoinHost, 2, 2, 1, 1)
-        spacerItem10 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_8.addItem(spacerItem10, 3, 0, 1, 1)
-        spacerItem11 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_8.addItem(spacerItem11, 4, 0, 1, 1)
-        self.label_18 = QtGui.QLabel(self.tabNamecoin)
+        self.label_18 = QtWidgets.QLabel(self.tabNamecoin)
         self.label_18.setEnabled(True)
         self.label_18.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_18.setObjectName(_fromUtf8("label_18"))
+        self.label_18.setObjectName("label_18")
         self.gridLayout_8.addWidget(self.label_18, 3, 1, 1, 1)
-        self.lineEditNamecoinPort = QtGui.QLineEdit(self.tabNamecoin)
-        self.lineEditNamecoinPort.setObjectName(_fromUtf8("lineEditNamecoinPort"))
+        self.lineEditNamecoinPort = QtWidgets.QLineEdit(self.tabNamecoin)
+        self.lineEditNamecoinPort.setObjectName("lineEditNamecoinPort")
         self.gridLayout_8.addWidget(self.lineEditNamecoinPort, 3, 2, 1, 1)
-        spacerItem12 = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
+        spacerItem12 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
         self.gridLayout_8.addItem(spacerItem12, 8, 1, 1, 1)
-        self.labelNamecoinUser = QtGui.QLabel(self.tabNamecoin)
+        self.labelNamecoinUser = QtWidgets.QLabel(self.tabNamecoin)
         self.labelNamecoinUser.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.labelNamecoinUser.setObjectName(_fromUtf8("labelNamecoinUser"))
+        self.labelNamecoinUser.setObjectName("labelNamecoinUser")
         self.gridLayout_8.addWidget(self.labelNamecoinUser, 4, 1, 1, 1)
-        self.lineEditNamecoinUser = QtGui.QLineEdit(self.tabNamecoin)
-        self.lineEditNamecoinUser.setObjectName(_fromUtf8("lineEditNamecoinUser"))
+        self.lineEditNamecoinUser = QtWidgets.QLineEdit(self.tabNamecoin)
+        self.lineEditNamecoinUser.setObjectName("lineEditNamecoinUser")
         self.gridLayout_8.addWidget(self.lineEditNamecoinUser, 4, 2, 1, 1)
-        spacerItem13 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem13 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_8.addItem(spacerItem13, 5, 0, 1, 1)
-        self.labelNamecoinPassword = QtGui.QLabel(self.tabNamecoin)
+        self.labelNamecoinPassword = QtWidgets.QLabel(self.tabNamecoin)
         self.labelNamecoinPassword.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.labelNamecoinPassword.setObjectName(_fromUtf8("labelNamecoinPassword"))
+        self.labelNamecoinPassword.setObjectName("labelNamecoinPassword")
         self.gridLayout_8.addWidget(self.labelNamecoinPassword, 5, 1, 1, 1)
-        self.lineEditNamecoinPassword = QtGui.QLineEdit(self.tabNamecoin)
+        self.lineEditNamecoinPassword = QtWidgets.QLineEdit(self.tabNamecoin)
         self.lineEditNamecoinPassword.setInputMethodHints(QtCore.Qt.ImhHiddenText|QtCore.Qt.ImhNoAutoUppercase|QtCore.Qt.ImhNoPredictiveText)
-        self.lineEditNamecoinPassword.setEchoMode(QtGui.QLineEdit.Password)
-        self.lineEditNamecoinPassword.setObjectName(_fromUtf8("lineEditNamecoinPassword"))
+        self.lineEditNamecoinPassword.setEchoMode(QtWidgets.QLineEdit.Password)
+        self.lineEditNamecoinPassword.setObjectName("lineEditNamecoinPassword")
         self.gridLayout_8.addWidget(self.lineEditNamecoinPassword, 5, 2, 1, 1)
-        self.labelNamecoinTestResult = QtGui.QLabel(self.tabNamecoin)
-        self.labelNamecoinTestResult.setText(_fromUtf8(""))
-        self.labelNamecoinTestResult.setObjectName(_fromUtf8("labelNamecoinTestResult"))
+        self.labelNamecoinTestResult = QtWidgets.QLabel(self.tabNamecoin)
+        self.labelNamecoinTestResult.setText("")
+        self.labelNamecoinTestResult.setObjectName("labelNamecoinTestResult")
         self.gridLayout_8.addWidget(self.labelNamecoinTestResult, 7, 0, 1, 2)
-        self.pushButtonNamecoinTest = QtGui.QPushButton(self.tabNamecoin)
-        self.pushButtonNamecoinTest.setObjectName(_fromUtf8("pushButtonNamecoinTest"))
+        self.pushButtonNamecoinTest = QtWidgets.QPushButton(self.tabNamecoin)
+        self.pushButtonNamecoinTest.setObjectName("pushButtonNamecoinTest")
         self.gridLayout_8.addWidget(self.pushButtonNamecoinTest, 7, 2, 1, 1)
-        self.horizontalLayout = QtGui.QHBoxLayout()
-        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
-        self.label_21 = QtGui.QLabel(self.tabNamecoin)
-        self.label_21.setObjectName(_fromUtf8("label_21"))
+        self.horizontalLayout = QtWidgets.QHBoxLayout()
+        self.horizontalLayout.setObjectName("horizontalLayout")
+        self.label_21 = QtWidgets.QLabel(self.tabNamecoin)
+        self.label_21.setObjectName("label_21")
         self.horizontalLayout.addWidget(self.label_21)
-        self.radioButtonNamecoinNamecoind = QtGui.QRadioButton(self.tabNamecoin)
-        self.radioButtonNamecoinNamecoind.setObjectName(_fromUtf8("radioButtonNamecoinNamecoind"))
+        self.radioButtonNamecoinNamecoind = QtWidgets.QRadioButton(self.tabNamecoin)
+        self.radioButtonNamecoinNamecoind.setObjectName("radioButtonNamecoinNamecoind")
         self.horizontalLayout.addWidget(self.radioButtonNamecoinNamecoind)
-        self.radioButtonNamecoinNmcontrol = QtGui.QRadioButton(self.tabNamecoin)
-        self.radioButtonNamecoinNmcontrol.setObjectName(_fromUtf8("radioButtonNamecoinNmcontrol"))
+        self.radioButtonNamecoinNmcontrol = QtWidgets.QRadioButton(self.tabNamecoin)
+        self.radioButtonNamecoinNmcontrol.setObjectName("radioButtonNamecoinNmcontrol")
         self.horizontalLayout.addWidget(self.radioButtonNamecoinNmcontrol)
         self.gridLayout_8.addLayout(self.horizontalLayout, 1, 0, 1, 3)
-        self.tabWidgetSettings.addTab(self.tabNamecoin, _fromUtf8(""))
-        self.tabResendsExpire = QtGui.QWidget()
-        self.tabResendsExpire.setObjectName(_fromUtf8("tabResendsExpire"))
-        self.gridLayout_5 = QtGui.QGridLayout(self.tabResendsExpire)
-        self.gridLayout_5.setObjectName(_fromUtf8("gridLayout_5"))
-        self.label_7 = QtGui.QLabel(self.tabResendsExpire)
+        self.tabWidgetSettings.addTab(self.tabNamecoin, "")
+        self.tabResendsExpire = QtWidgets.QWidget()
+        self.tabResendsExpire.setObjectName("tabResendsExpire")
+        self.gridLayout_5 = QtWidgets.QGridLayout(self.tabResendsExpire)
+        self.gridLayout_5.setObjectName("gridLayout_5")
+        self.label_7 = QtWidgets.QLabel(self.tabResendsExpire)
         self.label_7.setWordWrap(True)
-        self.label_7.setObjectName(_fromUtf8("label_7"))
+        self.label_7.setObjectName("label_7")
         self.gridLayout_5.addWidget(self.label_7, 0, 0, 1, 3)
-        spacerItem14 = QtGui.QSpacerItem(212, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        spacerItem14 = QtWidgets.QSpacerItem(212, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
         self.gridLayout_5.addItem(spacerItem14, 1, 0, 1, 1)
-        self.widget = QtGui.QWidget(self.tabResendsExpire)
+        self.widget = QtWidgets.QWidget(self.tabResendsExpire)
         self.widget.setMinimumSize(QtCore.QSize(231, 75))
-        self.widget.setObjectName(_fromUtf8("widget"))
-        self.label_19 = QtGui.QLabel(self.widget)
+        self.widget.setObjectName("widget")
+        self.label_19 = QtWidgets.QLabel(self.widget)
         self.label_19.setGeometry(QtCore.QRect(10, 20, 101, 20))
         self.label_19.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_19.setObjectName(_fromUtf8("label_19"))
-        self.label_20 = QtGui.QLabel(self.widget)
+        self.label_19.setObjectName("label_19")
+        self.label_20 = QtWidgets.QLabel(self.widget)
         self.label_20.setGeometry(QtCore.QRect(30, 40, 80, 16))
         self.label_20.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
-        self.label_20.setObjectName(_fromUtf8("label_20"))
-        self.lineEditDays = QtGui.QLineEdit(self.widget)
+        self.label_20.setObjectName("label_20")
+        self.lineEditDays = QtWidgets.QLineEdit(self.widget)
         self.lineEditDays.setGeometry(QtCore.QRect(113, 20, 51, 20))
-        self.lineEditDays.setObjectName(_fromUtf8("lineEditDays"))
-        self.lineEditMonths = QtGui.QLineEdit(self.widget)
+        self.lineEditDays.setObjectName("lineEditDays")
+        self.lineEditMonths = QtWidgets.QLineEdit(self.widget)
         self.lineEditMonths.setGeometry(QtCore.QRect(113, 40, 51, 20))
-        self.lineEditMonths.setObjectName(_fromUtf8("lineEditMonths"))
-        self.label_22 = QtGui.QLabel(self.widget)
+        self.lineEditMonths.setObjectName("lineEditMonths")
+        self.label_22 = QtWidgets.QLabel(self.widget)
         self.label_22.setGeometry(QtCore.QRect(169, 23, 61, 16))
-        self.label_22.setObjectName(_fromUtf8("label_22"))
-        self.label_23 = QtGui.QLabel(self.widget)
+        self.label_22.setObjectName("label_22")
+        self.label_23 = QtWidgets.QLabel(self.widget)
         self.label_23.setGeometry(QtCore.QRect(170, 41, 71, 16))
-        self.label_23.setObjectName(_fromUtf8("label_23"))
+        self.label_23.setObjectName("label_23")
         self.gridLayout_5.addWidget(self.widget, 1, 2, 1, 1)
-        spacerItem15 = QtGui.QSpacerItem(20, 129, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
+        spacerItem15 = QtWidgets.QSpacerItem(20, 129, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
         self.gridLayout_5.addItem(spacerItem15, 2, 1, 1, 1)
-        self.tabWidgetSettings.addTab(self.tabResendsExpire, _fromUtf8(""))
+        self.tabWidgetSettings.addTab(self.tabResendsExpire, "")
         self.gridLayout.addWidget(self.tabWidgetSettings, 0, 0, 1, 1)
 
         self.retranslateUi(settingsDialog)
         self.tabWidgetSettings.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), settingsDialog.accept)
-        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), settingsDialog.reject)
-        QtCore.QObject.connect(self.checkBoxAuthentication, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.lineEditSocksUsername.setEnabled)
-        QtCore.QObject.connect(self.checkBoxAuthentication, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.lineEditSocksPassword.setEnabled)
+
+        self.buttonBox.accepted.connect(settingsDialog.accept)
+        self.buttonBox.rejected.connect(settingsDialog.reject)
+        self.checkBoxAuthentication.toggled.connect(
+            self.lineEditSocksUsername.setEnabled)
+        self.checkBoxAuthentication.toggled.connect(
+            self.lineEditSocksPassword.setEnabled)
+
         QtCore.QMetaObject.connectSlotsByName(settingsDialog)
+
         settingsDialog.setTabOrder(self.tabWidgetSettings, self.checkBoxStartOnLogon)
         settingsDialog.setTabOrder(self.checkBoxStartOnLogon, self.checkBoxStartInTray)
         settingsDialog.setTabOrder(self.checkBoxStartInTray, self.checkBoxMinimizeToTray)
@@ -512,5 +497,3 @@ class Ui_settingsDialog(object):
         self.label_22.setText(_translate("settingsDialog", "days", None))
         self.label_23.setText(_translate("settingsDialog", "months.", None))
         self.tabWidgetSettings.setTabText(self.tabWidgetSettings.indexOf(self.tabResendsExpire), _translate("settingsDialog", "Resends Expire", None))
-
-import bitmessage_icons_rc
diff --git a/src/bitmessageqt/settingsmixin.py b/src/bitmessageqt/settingsmixin.py
index c534d1b..43b9cdd 100644
--- a/src/bitmessageqt/settingsmixin.py
+++ b/src/bitmessageqt/settingsmixin.py
@@ -1,34 +1,34 @@
-#!/usr/bin/python2.7
+from qtpy import QtCore, QtWidgets
 
-from PyQt4 import QtCore, QtGui
 
 class SettingsMixin(object):
     def warnIfNoObjectName(self):
         if self.objectName() == "":
             # TODO: logger
             pass
-    
+
     def writeState(self, source):
         self.warnIfNoObjectName()
         settings = QtCore.QSettings()
         settings.beginGroup(self.objectName())
         settings.setValue("state", source.saveState())
         settings.endGroup()
-    
+
     def writeGeometry(self, source):
         self.warnIfNoObjectName()
         settings = QtCore.QSettings()
         settings.beginGroup(self.objectName())
         settings.setValue("geometry", source.saveGeometry())
         settings.endGroup()
-        
+
     def readGeometry(self, target):
         self.warnIfNoObjectName()
         settings = QtCore.QSettings()
         try:
-            geom = settings.value("/".join([str(self.objectName()), "geometry"]))
-            target.restoreGeometry(geom.toByteArray() if hasattr(geom, 'toByteArray') else geom)
-        except Exception as e:
+            geom = settings.value(
+                "/".join([str(self.objectName()), "geometry"]))
+            target.restoreGeometry(geom)
+        except Exception:
             pass
 
     def readState(self, target):
@@ -36,44 +36,44 @@ class SettingsMixin(object):
         settings = QtCore.QSettings()
         try:
             state = settings.value("/".join([str(self.objectName()), "state"]))
-            target.restoreState(state.toByteArray() if hasattr(state, 'toByteArray') else state)
-        except Exception as e:
+            target.restoreState(state)
+        except Exception:
             pass
 
-            
-class SMainWindow(QtGui.QMainWindow, SettingsMixin):
+
+class SMainWindow(QtWidgets.QMainWindow, SettingsMixin):
     def loadSettings(self):
         self.readGeometry(self)
         self.readState(self)
-        
+
     def saveSettings(self):
         self.writeState(self)
         self.writeGeometry(self)
 
 
-class STableWidget(QtGui.QTableWidget, SettingsMixin):
+class STableWidget(QtWidgets.QTableWidget, SettingsMixin):
     def loadSettings(self):
         self.readState(self.horizontalHeader())
 
     def saveSettings(self):
         self.writeState(self.horizontalHeader())
 
-        
-class SSplitter(QtGui.QSplitter, SettingsMixin):
+
+class SSplitter(QtWidgets.QSplitter, SettingsMixin):
     def loadSettings(self):
         self.readState(self)
 
     def saveSettings(self):
         self.writeState(self)
-        
 
-class STreeWidget(QtGui.QTreeWidget, SettingsMixin):
+
+class STreeWidget(QtWidgets.QTreeWidget, SettingsMixin):
     def loadSettings(self):
-        #recurse children
-        #self.readState(self)
+        # recurse children
+        # self.readState(self)
         pass
 
     def saveSettings(self):
-        #recurse children
-        #self.writeState(self)
+        # recurse children
+        # self.writeState(self)
         pass
diff --git a/src/bitmessageqt/statusbar.py b/src/bitmessageqt/statusbar.py
index 65a5acf..477b0d6 100644
--- a/src/bitmessageqt/statusbar.py
+++ b/src/bitmessageqt/statusbar.py
@@ -1,8 +1,8 @@
-from PyQt4 import QtCore, QtGui
-from Queue import Queue
+from qtpy import QtWidgets
 from time import time
 
-class BMStatusBar(QtGui.QStatusBar):
+
+class BMStatusBar(QtWidgets.QStatusBar):
     duration = 10000
     deleteAfter = 60
 
diff --git a/src/bitmessageqt/support.py b/src/bitmessageqt/support.py
index 25c6113..c4ab0c5 100644
--- a/src/bitmessageqt/support.py
+++ b/src/bitmessageqt/support.py
@@ -1,17 +1,18 @@
 import ctypes
-from PyQt4 import QtCore, QtGui
 import ssl
 import sys
+import os
 import time
 
 import account
+from qtpy import QtCore
+from tr import _translate
 from bmconfigparser import BMConfigParser
-from debug import logger
 import defaults
 from foldertree import AccountMixin
-from helper_sql import *
+from helper_sql import sqlQuery, sqlExecute
 from l10n import getTranslationLanguage
-from openclpow import openclAvailable, openclEnabled
+from openclpow import openclEnabled
 import paths
 import proofofwork
 from pyelliptic.openssl import OpenSSL
@@ -23,8 +24,8 @@ from version import softwareVersion
 # this is BM support address going to Peter Surda
 OLD_SUPPORT_ADDRESS = 'BM-2cTkCtMYkrSPwFTpgcBrMrf5d8oZwvMZWK'
 SUPPORT_ADDRESS = 'BM-2cUdgkDDAahwPAU6oD2A7DnjqZz3hgY832'
-SUPPORT_LABEL = 'PyBitmessage support'
-SUPPORT_MY_LABEL = 'My new address'
+SUPPORT_LABEL = _translate("Support", "PyBitmessage support")
+SUPPORT_MY_LABEL = _translate("Support", "My new address")
 SUPPORT_SUBJECT = 'Support request'
 SUPPORT_MESSAGE = '''You can use this message to send a report to one of the PyBitmessage core developers regarding PyBitmessage or the mailchuck.com email service. If you are using PyBitmessage involuntarily, for example because your computer was infected with ransomware, this is not an appropriate venue for resolving such issues.
 
@@ -43,6 +44,7 @@ Operating system: {}
 Architecture: {}bit
 Python Version: {}
 OpenSSL Version: {}
+Qt API: {}
 Frozen: {}
 Portable mode: {}
 C PoW: {}
@@ -53,37 +55,56 @@ UPnP: {}
 Connected hosts: {}
 '''
 
+
 def checkAddressBook(myapp):
-    sqlExecute('''DELETE from addressbook WHERE address=?''', OLD_SUPPORT_ADDRESS)
-    queryreturn = sqlQuery('''SELECT * FROM addressbook WHERE address=?''', SUPPORT_ADDRESS)
+    sqlExecute(
+        '''DELETE from addressbook WHERE address=?''', OLD_SUPPORT_ADDRESS)
+    queryreturn = sqlQuery(
+        '''SELECT * FROM addressbook WHERE address=?''', SUPPORT_ADDRESS)
     if queryreturn == []:
-        sqlExecute('''INSERT INTO addressbook VALUES (?,?)''', str(QtGui.QApplication.translate("Support", SUPPORT_LABEL)), SUPPORT_ADDRESS)
+        sqlExecute(
+            '''INSERT INTO addressbook VALUES (?,?)''',
+            SUPPORT_LABEL, SUPPORT_ADDRESS
+        )
         myapp.rerenderAddressBook()
 
+
 def checkHasNormalAddress():
     for address in account.getSortedAccounts():
         acct = account.accountClass(address)
-        if acct.type == AccountMixin.NORMAL and BMConfigParser().safeGetBoolean(address, 'enabled'):
+        if acct.type == AccountMixin.NORMAL \
+                and BMConfigParser().safeGetBoolean(address, 'enabled'):
             return address
     return False
 
+
 def createAddressIfNeeded(myapp):
     if not checkHasNormalAddress():
-        queues.addressGeneratorQueue.put(('createRandomAddress', 4, 1, str(QtGui.QApplication.translate("Support", SUPPORT_MY_LABEL)), 1, "", False, defaults.networkDefaultProofOfWorkNonceTrialsPerByte, defaults.networkDefaultPayloadLengthExtraBytes))
+        queues.addressGeneratorQueue.put((
+            'createRandomAddress', 4, 1,
+            SUPPORT_MY_LABEL, 1, "", False,
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+            defaults.networkDefaultPayloadLengthExtraBytes
+        ))
     while state.shutdown == 0 and not checkHasNormalAddress():
         time.sleep(.2)
     myapp.rerenderComboBoxSendFrom()
     return checkHasNormalAddress()
 
+
 def createSupportMessage(myapp):
     checkAddressBook(myapp)
     address = createAddressIfNeeded(myapp)
     if state.shutdown:
         return
 
-    myapp.ui.lineEditSubject.setText(str(QtGui.QApplication.translate("Support", SUPPORT_SUBJECT)))
-    addrIndex = myapp.ui.comboBoxSendFrom.findData(address, QtCore.Qt.UserRole, QtCore.Qt.MatchFixedString | QtCore.Qt.MatchCaseSensitive)
-    if addrIndex == -1: # something is very wrong
+    myapp.ui.lineEditSubject.setText(SUPPORT_SUBJECT)
+    # addrIndex = myapp.ui.comboBoxSendFrom.findData(
+    #     address, QtCore.Qt.UserRole,
+    #     QtCore.Qt.MatchFixedString | QtCore.Qt.MatchCaseSensitive
+    # )
+    addrIndex = myapp.ui.comboBoxSendFrom.findData(address)
+    if addrIndex == -1:  # something is very wrong
         return
     myapp.ui.comboBoxSendFrom.setCurrentIndex(addrIndex)
     myapp.ui.lineEditTo.setText(SUPPORT_ADDRESS)
@@ -93,30 +114,28 @@ def createSupportMessage(myapp):
     if commit:
         version += " GIT " + commit
 
-    os = sys.platform
-    if os == "win32":
-        windowsversion = sys.getwindowsversion()
-        os = "Windows " + str(windowsversion[0]) + "." + str(windowsversion[1])
+    if sys.platform == "win32":
+        osname = "Windows %s.%s" % sys.getwindowsversion()
     else:
         try:
-            from os import uname
-            unixversion = uname()
-            os = unixversion[0] + " " + unixversion[2]
+            unixversion = os.uname()
+            osname = unixversion[0] + " " + unixversion[2]
         except:
             pass
     architecture = "32" if ctypes.sizeof(ctypes.c_voidp) == 4 else "64"
     pythonversion = sys.version
-    
+
     opensslversion = "%s (Python internal), %s (external for PyElliptic)" % (ssl.OPENSSL_VERSION, OpenSSL._version)
 
+    qtapi = os.environ['QT_API']
+
     frozen = "N/A"
     if paths.frozen:
         frozen = paths.frozen
-    portablemode = "True" if state.appdata == paths.lookupExeFolder() else "False"
+    portablemode = "True" \
+        if state.appdata == paths.lookupExeFolder() else "False"
     cpow = "True" if proofofwork.bmpow else "False"
-    #cpow = QtGui.QApplication.translate("Support", cpow)
     openclpow = str(BMConfigParser().safeGet('bitmessagesettings', 'opencl')) if openclEnabled() else "None"
-    #openclpow = QtGui.QApplication.translate("Support", openclpow)
     locale = getTranslationLanguage()
     try:
         socks = BMConfigParser().get('bitmessagesettings', 'socksproxytype')
@@ -128,7 +147,12 @@ def createSupportMessage(myapp):
         upnp = "N/A"
     connectedhosts = len(network.stats.connectedHostsList())
 
-    myapp.ui.textEditMessage.setText(str(QtGui.QApplication.translate("Support", SUPPORT_MESSAGE)).format(version, os, architecture, pythonversion, opensslversion, frozen, portablemode, cpow, openclpow, locale, socks, upnp, connectedhosts))
+    myapp.ui.textEditMessage.setText(
+        SUPPORT_MESSAGE.format(
+            version, osname, architecture, pythonversion, opensslversion,
+            qtapi, frozen, portablemode, cpow, openclpow, locale, socks,
+            upnp, connectedhosts
+        ))
 
     # single msg tab
     myapp.ui.tabWidgetSend.setCurrentIndex(
diff --git a/src/bitmessageqt/uisignaler.py b/src/bitmessageqt/uisignaler.py
index 055f909..e4a2311 100644
--- a/src/bitmessageqt/uisignaler.py
+++ b/src/bitmessageqt/uisignaler.py
@@ -1,15 +1,34 @@
-
-from PyQt4.QtCore import QThread, SIGNAL
+from qtpy import QtCore
 import sys
 
 import queues
+import state
 
 
-class UISignaler(QThread):
+class UISignaler(QtCore.QThread):
     _instance = None
 
-    def __init__(self, parent=None):
-        QThread.__init__(self, parent)
+    writeNewAddressToTable = QtCore.Signal(str, str, str)
+    updateStatusBar = QtCore.Signal(str)
+    updateSentItemStatusByToAddress = QtCore.Signal(object, str)
+    updateSentItemStatusByAckdata = QtCore.Signal(object, str)
+    displayNewInboxMessage = QtCore.Signal(object, str, object, object, str)
+    displayNewSentMessage = QtCore.Signal(
+        object, str, str, object, object, str)
+    updateNetworkStatusTab = QtCore.Signal(bool, bool, state.Peer)
+    updateNumberOfMessagesProcessed = QtCore.Signal()
+    updateNumberOfPubkeysProcessed = QtCore.Signal()
+    updateNumberOfBroadcastsProcessed = QtCore.Signal()
+    setStatusIcon = QtCore.Signal(str)
+    changedInboxUnread = QtCore.Signal(str)
+    rerenderMessagelistFromLabels = QtCore.Signal()
+    rerenderMessagelistToLabels = QtCore.Signal()
+    rerenderAddressBook = QtCore.Signal()
+    rerenderSubscriptions = QtCore.Signal()
+    rerenderBlackWhiteList = QtCore.Signal()
+    removeInboxRowByMsgid = QtCore.Signal(str)
+    newVersionAvailable = QtCore.Signal(str)
+    displayAlert = QtCore.Signal(str, str, bool)
 
     @classmethod
     def get(cls):
@@ -22,58 +41,59 @@ class UISignaler(QThread):
             command, data = queues.UISignalQueue.get()
             if command == 'writeNewAddressToTable':
                 label, address, streamNumber = data
-                self.emit(SIGNAL(
-                    "writeNewAddressToTable(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), label, address, str(streamNumber))
+                self.writeNewAddressToTable.emit(
+                    label, address, str(streamNumber))
             elif command == 'updateStatusBar':
-                self.emit(SIGNAL("updateStatusBar(PyQt_PyObject)"), data)
+                self.updateStatusBar.emit(data)
             elif command == 'updateSentItemStatusByToAddress':
                 toAddress, message = data
-                self.emit(SIGNAL(
-                    "updateSentItemStatusByToAddress(PyQt_PyObject,PyQt_PyObject)"), toAddress, message)
+                self.updateSentItemStatusByToAddress.emit(toAddress, message)
             elif command == 'updateSentItemStatusByAckdata':
                 ackData, message = data
-                self.emit(SIGNAL(
-                    "updateSentItemStatusByAckdata(PyQt_PyObject,PyQt_PyObject)"), ackData, message)
+                self.updateSentItemStatusByAckdata.emit(ackData, message)
             elif command == 'displayNewInboxMessage':
                 inventoryHash, toAddress, fromAddress, subject, body = data
-                self.emit(SIGNAL(
-                    "displayNewInboxMessage(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"),
-                    inventoryHash, toAddress, fromAddress, subject, body)
+
+                self.displayNewInboxMessage.emit(
+                    inventoryHash, toAddress, fromAddress,
+                    subject, body)
             elif command == 'displayNewSentMessage':
                 toAddress, fromLabel, fromAddress, subject, message, ackdata = data
-                self.emit(SIGNAL(
-                    "displayNewSentMessage(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"),
-                    toAddress, fromLabel, fromAddress, subject, message, ackdata)
+                self.displayNewSentMessage.emit(
+                    toAddress, fromLabel, fromAddress,
+                    unicode(subject, 'utf-8'), message, ackdata)
             elif command == 'updateNetworkStatusTab':
                 outbound, add, destination = data
-                self.emit(SIGNAL("updateNetworkStatusTab(PyQt_PyObject,PyQt_PyObject,PyQt_PyObject)"), outbound, add, destination)
+                self.updateNetworkStatusTab.emit(outbound, add, destination)
             elif command == 'updateNumberOfMessagesProcessed':
-                self.emit(SIGNAL("updateNumberOfMessagesProcessed()"))
+                self.updateNumberOfMessagesProcessed.emit()
             elif command == 'updateNumberOfPubkeysProcessed':
-                self.emit(SIGNAL("updateNumberOfPubkeysProcessed()"))
+                self.updateNumberOfPubkeysProcessed.emit()
             elif command == 'updateNumberOfBroadcastsProcessed':
-                self.emit(SIGNAL("updateNumberOfBroadcastsProcessed()"))
+                self.updateNumberOfBroadcastsProcessed.emit()
             elif command == 'setStatusIcon':
-                self.emit(SIGNAL("setStatusIcon(PyQt_PyObject)"), data)
+                self.setStatusIcon.emit(data)
             elif command == 'changedInboxUnread':
-                self.emit(SIGNAL("changedInboxUnread(PyQt_PyObject)"), data)
+                self.changedInboxUnread.emit(data)
             elif command == 'rerenderMessagelistFromLabels':
-                self.emit(SIGNAL("rerenderMessagelistFromLabels()"))
+                self.rerenderMessagelistFromLabels.emit()
             elif command == 'rerenderMessagelistToLabels':
-                self.emit(SIGNAL("rerenderMessagelistToLabels()"))
+                self.rerenderMessagelistToLabels.emit()
             elif command == 'rerenderAddressBook':
-                self.emit(SIGNAL("rerenderAddressBook()"))
+                self.rerenderAddressBook.emit()
             elif command == 'rerenderSubscriptions':
-                self.emit(SIGNAL("rerenderSubscriptions()"))
+                self.rerenderSubscriptions.emit()
             elif command == 'rerenderBlackWhiteList':
-                self.emit(SIGNAL("rerenderBlackWhiteList()"))
+                self.rerenderBlackWhiteList.emit()
             elif command == 'removeInboxRowByMsgid':
-                self.emit(SIGNAL("removeInboxRowByMsgid(PyQt_PyObject)"), data)
+                self.removeInboxRowByMsgid.emit(data)
             elif command == 'newVersionAvailable':
-                self.emit(SIGNAL("newVersionAvailable(PyQt_PyObject)"), data)
+                self.newVersionAvailable.emit(data)
             elif command == 'alert':
                 title, text, exitAfterUserClicksOk = data
-                self.emit(SIGNAL("displayAlert(PyQt_PyObject, PyQt_PyObject, PyQt_PyObject)"), title, text, exitAfterUserClicksOk)
+                self.displayAlert.emit(title, text, exitAfterUserClicksOk)
             else:
                 sys.stderr.write(
-                    'Command sent to UISignaler not recognized: %s\n' % command)
+                    'Command sent to UISignaler not recognized: %s\n'
+                    % command
+                )
diff --git a/src/bitmessageqt/utils.py b/src/bitmessageqt/utils.py
index 369d05e..f29ec8b 100644
--- a/src/bitmessageqt/utils.py
+++ b/src/bitmessageqt/utils.py
@@ -1,4 +1,4 @@
-from PyQt4 import QtGui
+from qtpy import QtGui
 import hashlib
 import os
 from addresses import addBMIfNotPresent
@@ -8,15 +8,17 @@ import state
 str_broadcast_subscribers = '[Broadcast subscribers]'
 str_chan = '[chan]'
 
+
 def identiconize(address):
     size = 48
-    
-    # If you include another identicon library, please generate an 
+
+    # If you include another identicon library, please generate an
     # example identicon with the following md5 hash:
     # 3fd4bf901b9d4ea1394f0fb358725b28
-    
+
     try:
-        identicon_lib = BMConfigParser().get('bitmessagesettings', 'identiconlib')
+        identicon_lib = BMConfigParser().get(
+            'bitmessagesettings', 'identiconlib')
     except:
         # default to qidenticon_two_x
         identicon_lib = 'qidenticon_two_x'
@@ -25,11 +27,11 @@ def identiconize(address):
     # It can be used as a pseudo-password to salt the generation of the identicons to decrease the risk
     # of attacks where someone creates an address to mimic someone else's identicon.
     identiconsuffix = BMConfigParser().get('bitmessagesettings', 'identiconsuffix')
-    
+
     if not BMConfigParser().getboolean('bitmessagesettings', 'useidenticons'):
         idcon = QtGui.QIcon()
         return idcon
-    
+
     if (identicon_lib[:len('qidenticon')] == 'qidenticon'):
         # print identicon_lib
         # originally by:
@@ -64,6 +66,7 @@ def identiconize(address):
         idcon.addPixmap(pix, QtGui.QIcon.Normal, QtGui.QIcon.Off)
         return idcon
 
+
 def avatarize(address):
     """
         loads a supported image for the given address' hash form 'avatars' folder
@@ -72,7 +75,6 @@ def avatarize(address):
     """
     idcon = QtGui.QIcon()
     hash = hashlib.md5(addBMIfNotPresent(address)).hexdigest()
-    str_broadcast_subscribers = '[Broadcast subscribers]'
     if address == str_broadcast_subscribers:
         # don't hash [Broadcast subscribers]
         hash = address
@@ -97,11 +99,11 @@ def avatarize(address):
         lower_default = state.appdata + 'avatars/' + 'default.' + ext.lower()
         upper_default = state.appdata + 'avatars/' + 'default.' + ext.upper()
         if os.path.isfile(lower_default):
-            default = lower_default
+            # default = lower_default
             idcon.addFile(lower_default)
             return idcon
         elif os.path.isfile(upper_default):
-            default = upper_default
+            # default = upper_default
             idcon.addFile(upper_default)
             return idcon
     # If no avatar is found
diff --git a/src/bitmessageqt/widgets.py b/src/bitmessageqt/widgets.py
index 8ef807f..58c8258 100644
--- a/src/bitmessageqt/widgets.py
+++ b/src/bitmessageqt/widgets.py
@@ -1,13 +1,17 @@
-from PyQt4 import uic
-import os.path
+from qtpy import uic
+import os
 import paths
-import sys
+
 
 def resource_path(resFile):
     baseDir = paths.codePath()
     for subDir in ["ui", "bitmessageqt"]:
-        if os.path.isdir(os.path.join(baseDir, subDir)) and os.path.isfile(os.path.join(baseDir, subDir, resFile)):
+        if (
+            os.path.isdir(os.path.join(baseDir, subDir))
+            and os.path.isfile(os.path.join(baseDir, subDir, resFile))
+        ):
             return os.path.join(baseDir, subDir, resFile)
 
+
 def load(resFile, widget):
     uic.loadUi(resource_path(resFile), widget)
diff --git a/src/bmconfigparser.py b/src/bmconfigparser.py
index 6a59895..09c11d7 100644
--- a/src/bmconfigparser.py
+++ b/src/bmconfigparser.py
@@ -1,7 +1,7 @@
 import ConfigParser
-import datetime
 import shutil
 import os
+from datetime import datetime
 
 from singleton import Singleton
 import state
@@ -34,6 +34,7 @@ BMConfigDefaults = {
     }
 }
 
+
 @Singleton
 class BMConfigParser(ConfigParser.SafeConfigParser):
     def set(self, section, option, value=None):
@@ -47,10 +48,13 @@ class BMConfigParser(ConfigParser.SafeConfigParser):
     def get(self, section, option, raw=False, variables=None):
         try:
             if section == "bitmessagesettings" and option == "timeformat":
-                return ConfigParser.ConfigParser.get(self, section, option, raw, variables)
-            return ConfigParser.ConfigParser.get(self, section, option, True, variables)
+                return ConfigParser.ConfigParser.get(
+                    self, section, option, raw, variables)
+            return ConfigParser.ConfigParser.get(
+                self, section, option, True, variables)
         except ConfigParser.InterpolationError:
-            return ConfigParser.ConfigParser.get(self, section, option, True, variables)
+            return ConfigParser.ConfigParser.get(
+                self, section, option, True, variables)
         except (ConfigParser.NoSectionError, ConfigParser.NoOptionError) as e:
             try:
                 return BMConfigDefaults[section][option]
@@ -60,51 +64,63 @@ class BMConfigParser(ConfigParser.SafeConfigParser):
     def safeGetBoolean(self, section, field):
         try:
             return self.getboolean(section, field)
-        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError, ValueError, AttributeError):
+        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError,
+                ValueError, AttributeError):
             return False
 
     def safeGetInt(self, section, field, default=0):
         try:
             return self.getint(section, field)
-        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError, ValueError, AttributeError):
+        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError,
+                ValueError, AttributeError):
             return default
 
-    def safeGet(self, section, option, default = None):
+    def safeGet(self, section, option, default=None):
         try:
             return self.get(section, option)
-        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError, ValueError, AttributeError):
+        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError,
+                ValueError, AttributeError):
             return default
 
     def items(self, section, raw=False, variables=None):
         return ConfigParser.ConfigParser.items(self, section, True, variables)
 
     def addresses(self):
-        return filter(lambda x: x.startswith('BM-'), BMConfigParser().sections())
+        return filter(
+            lambda x: x.startswith('BM-'), BMConfigParser().sections())
 
     def read(self, filenames):
         ConfigParser.ConfigParser.read(self, filenames)
         for section in self.sections():
             for option in self.options(section):
                 try:
-                    if not self.validate(section, option, ConfigParser.ConfigParser.get(self, section, option)):
+                    if not self.validate(
+                        section, option,
+                        ConfigParser.ConfigParser.get(self, section, option)
+                    ):
                         try:
                             newVal = BMConfigDefaults[section][option]
                         except KeyError:
                             continue
-                        ConfigParser.ConfigParser.set(self, section, option, newVal)
+                        ConfigParser.ConfigParser.set(
+                            self, section, option, newVal)
                 except ConfigParser.InterpolationError:
                     continue
 
     def save(self):
         fileName = os.path.join(state.appdata, 'keys.dat')
-        fileNameBak = fileName + "." + datetime.datetime.now().strftime("%Y%j%H%M%S%f") + '.bak'
-        # create a backup copy to prevent the accidental loss due to the disk write failure
+        fileNameBak = ".".join([
+            fileName, datetime.now().strftime("%Y%j%H%M%S%f"), 'bak'
+        ])
+        # create a backup copy to prevent the accidental loss due to
+        # the disk write failure
         try:
             shutil.copyfile(fileName, fileNameBak)
             # The backup succeeded.
             fileNameExisted = True
         except (IOError, Exception):
-            # The backup failed. This can happen if the file didn't exist before.
+            # The backup failed.
+            # This can happen if the file didn't exist before.
             fileNameExisted = False
         # write the file
         with open(fileName, 'wb') as configfile:
diff --git a/src/class_addressGenerator.py b/src/class_addressGenerator.py
index bd377c1..3e8fa7b 100644
--- a/src/class_addressGenerator.py
+++ b/src/class_addressGenerator.py
@@ -3,7 +3,6 @@ import threading
 import time
 import sys
 from pyelliptic.openssl import OpenSSL
-import ctypes
 import hashlib
 import highlevelcrypto
 from addresses import *
@@ -17,13 +16,14 @@ from binascii import hexlify
 import queues
 import state
 
+
 class addressGenerator(threading.Thread, StoppableThread):
 
     def __init__(self):
         # QThread.__init__(self, parent)
         threading.Thread.__init__(self, name="addressGenerator")
         self.initStop()
-        
+
     def stopThread(self):
         try:
             queues.addressGeneratorQueue.put(("stopThread", "data"))
@@ -38,7 +38,12 @@ class addressGenerator(threading.Thread, StoppableThread):
             payloadLengthExtraBytes = 0
             live = True
             if queueValue[0] == 'createChan':
-                command, addressVersionNumber, streamNumber, label, deterministicPassphrase, live = queueValue
+                try:
+                    command, addressVersionNumber, streamNumber, label, deterministicPassphrase, live = queueValue
+                except Exception:
+                    logger.warning(
+                        'Exception in addressGenerator.run:',
+                        exc_info=True)
                 eighteenByteRipe = False
                 numberOfAddressesToMake = 1
                 numberOfNullBytesDemandedOnFrontOfRipeHash = 1
@@ -58,7 +63,8 @@ class addressGenerator(threading.Thread, StoppableThread):
                     if eighteenByteRipe:
                         numberOfNullBytesDemandedOnFrontOfRipeHash = 2
                     else:
-                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1 # the default
+                        # the default
+                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif len(queueValue) == 9:
                 command, addressVersionNumber, streamNumber, label, numberOfAddressesToMake, deterministicPassphrase, eighteenByteRipe, nonceTrialsPerByte, payloadLengthExtraBytes = queueValue
                 try:
@@ -68,7 +74,8 @@ class addressGenerator(threading.Thread, StoppableThread):
                     if eighteenByteRipe:
                         numberOfNullBytesDemandedOnFrontOfRipeHash = 2
                     else:
-                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1 # the default
+                        # the default
+                        numberOfNullBytesDemandedOnFrontOfRipeHash = 1
             elif queueValue[0] == 'stopThread':
                 break
             else:
@@ -89,15 +96,20 @@ class addressGenerator(threading.Thread, StoppableThread):
                 payloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
             if command == 'createRandomAddress':
                 queues.UISignalQueue.put((
-                    'updateStatusBar', tr._translate("MainWindow", "Generating one new address")))
-                # This next section is a little bit strange. We're going to generate keys over and over until we
-                # find one that starts with either \x00 or \x00\x00. Then when we pack them into a Bitmessage address,
+                    'updateStatusBar',
+                    tr._translate("MainWindow", "Generating one new address")
+                ))
+                # This next section is a little bit strange. We're going
+                # to generate keys over and over until we
+                # find one that starts with either \x00 or \x00\x00.
+                # Then when we pack them into a Bitmessage address,
                 # we won't store the \x00 or \x00\x00 bytes thus making the
                 # address shorter.
                 startTime = time.time()
                 numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix = 0
                 potentialPrivSigningKey = OpenSSL.rand(32)
-                potentialPubSigningKey = highlevelcrypto.pointMult(potentialPrivSigningKey)
+                potentialPubSigningKey = highlevelcrypto.pointMult(
+                    potentialPrivSigningKey)
                 while True:
                     numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix += 1
                     potentialPrivEncryptionKey = OpenSSL.rand(32)
@@ -110,15 +122,27 @@ class addressGenerator(threading.Thread, StoppableThread):
                     ripe.update(sha.digest())
                     if ripe.digest()[:numberOfNullBytesDemandedOnFrontOfRipeHash] == '\x00' * numberOfNullBytesDemandedOnFrontOfRipeHash:
                         break
-                logger.info('Generated address with ripe digest: %s' % hexlify(ripe.digest()))
+                logger.info(
+                    'Generated address with ripe digest: %s',
+                    hexlify(ripe.digest())
+                )
                 try:
-                    logger.info('Address generator calculated %s addresses at %s addresses per second before finding one with the correct ripe-prefix.' % (numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix, numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime)))
+                    logger.info(
+                        'Address generator calculated %s addresses at'
+                        ' %s addresses per second before finding one'
+                        ' with the correct ripe-prefix.',
+                        numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix,
+                        numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime)
+                    )
                 except ZeroDivisionError:
-                    # The user must have a pretty fast computer. time.time() - startTime equaled zero.
+                    # The user must have a pretty fast computer.
+                    # time.time() - startTime equaled zero.
                     pass
-                address = encodeAddress(addressVersionNumber, streamNumber, ripe.digest())
+                address = encodeAddress(
+                    addressVersionNumber, streamNumber, ripe.digest())
 
-                # An excellent way for us to store our keys is in Wallet Import Format. Let us convert now.
+                # An excellent way for us to store our keys is in Wallet
+                # Import Format. Let us convert now.
                 # https://en.bitcoin.it/wiki/Wallet_import_format
                 privSigningKey = '\x80' + potentialPrivSigningKey
                 checksum = hashlib.sha256(hashlib.sha256(
@@ -151,7 +175,12 @@ class addressGenerator(threading.Thread, StoppableThread):
                 queues.apiAddressGeneratorReturnQueue.put(address)
 
                 queues.UISignalQueue.put((
-                    'updateStatusBar', tr._translate("MainWindow", "Done generating address. Doing work necessary to broadcast it...")))
+                    'updateStatusBar',
+                    tr._translate(
+                        "MainWindow",
+                        "Done generating address. Doing work necessary"
+                        " to broadcast it...")
+                ))
                 queues.UISignalQueue.put(('writeNewAddressToTable', (
                     label, address, streamNumber)))
                 shared.reloadMyAddressHashes()
@@ -162,17 +191,32 @@ class addressGenerator(threading.Thread, StoppableThread):
                     queues.workerQueue.put((
                         'sendOutOrStoreMyV4Pubkey', address))
 
-            elif command == 'createDeterministicAddresses' or command == 'getDeterministicAddress' or command == 'createChan' or command == 'joinChan':
+            elif command in (
+                'createDeterministicAddresses',
+                'getDeterministicAddress', 'createChan', 'joinChan'
+            ):
                 if len(deterministicPassphrase) == 0:
+                    logger.warning(
+                        'class_addressGenerator.run(),'
+                        ' deterministicPassphrase empty: %s',
+                        deterministicPassphrase)
                     sys.stderr.write(
-                        'WARNING: You are creating deterministic address(es) using a blank passphrase. Bitmessage will do it but it is rather stupid.')
+                        'WARNING: You are creating deterministic'
+                        ' address(es) using a blank passphrase.'
+                        ' Bitmessage will do it but it is rather stupid.'
+                    )
                 if command == 'createDeterministicAddresses':
                     queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow","Generating %1 new addresses.").arg(str(numberOfAddressesToMake))))
+                        'updateStatusBar',
+                        tr._translate(
+                            "MainWindow", "Generating {0} new addresses."
+                        ).format(str(numberOfAddressesToMake))
+                    ))
                 signingKeyNonce = 0
                 encryptionKeyNonce = 1
-                listOfNewAddressesToSendOutThroughTheAPI = [
-                ]  # We fill out this list no matter what although we only need it if we end up passing the info to the API.
+                # We fill out this list no matter what although we only
+                # need it if we end up passing the info to the API.
+                listOfNewAddressesToSendOutThroughTheAPI = []
 
                 for i in range(numberOfAddressesToMake):
                     # This next section is a little bit strange. We're going to generate keys over and over until we
@@ -201,17 +245,27 @@ class addressGenerator(threading.Thread, StoppableThread):
                         if ripe.digest()[:numberOfNullBytesDemandedOnFrontOfRipeHash] == '\x00' * numberOfNullBytesDemandedOnFrontOfRipeHash:
                             break
 
-                    
-                    logger.info('Generated address with ripe digest: %s' % hexlify(ripe.digest()))
+                    logger.info(
+                        'Generated address with ripe digest: %s',
+                        hexlify(ripe.digest())
+                    )
                     try:
-                        logger.info('Address generator calculated %s addresses at %s addresses per second before finding one with the correct ripe-prefix.' % (numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix, numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime)))
+                        logger.info(
+                            'Address generator calculated %s addresses'
+                            ' at %s addresses per second before finding'
+                            ' one with the correct ripe-prefix.',
+                            numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix,
+                            numberOfAddressesWeHadToMakeBeforeWeFoundOneWithTheCorrectRipePrefix / (time.time() - startTime))
                     except ZeroDivisionError:
-                        # The user must have a pretty fast computer. time.time() - startTime equaled zero.
+                        # The user must have a pretty fast computer.
+                        # time.time() - startTime equaled zero.
                         pass
-                    address = encodeAddress(addressVersionNumber, streamNumber, ripe.digest())
+                    address = encodeAddress(
+                        addressVersionNumber, streamNumber, ripe.digest())
 
                     saveAddressToDisk = True
-                    # If we are joining an existing chan, let us check to make sure it matches the provided Bitmessage address
+                    # If we are joining an existing chan, let us check to
+                    # make sure it matches the provided Bitmessage address
                     if command == 'joinChan':
                         if address != chanAddress:
                             listOfNewAddressesToSendOutThroughTheAPI.append('chan name does not match address')
@@ -220,7 +274,8 @@ class addressGenerator(threading.Thread, StoppableThread):
                         saveAddressToDisk = False
 
                     if saveAddressToDisk and live:
-                        # An excellent way for us to store our keys is in Wallet Import Format. Let us convert now.
+                        # An excellent way for us to store our keys is in
+                        # Wallet Import Format. Let us convert now.
                         # https://en.bitcoin.it/wiki/Wallet_import_format
                         privSigningKey = '\x80' + potentialPrivSigningKey
                         checksum = hashlib.sha256(hashlib.sha256(
@@ -235,19 +290,27 @@ class addressGenerator(threading.Thread, StoppableThread):
                         privEncryptionKeyWIF = arithmetic.changebase(
                             privEncryptionKey + checksum, 256, 58)
 
-                        
                         try:
                             BMConfigParser().add_section(address)
                             addressAlreadyExists = False
                         except:
                             addressAlreadyExists = True
-                            
+
                         if addressAlreadyExists:
-                            logger.info('%s already exists. Not adding it again.' % address)
+                            logger.info(
+                                '%s already exists. Not adding it again.',
+                                address
+                            )
                             queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow","%1 is already in 'Your Identities'. Not adding it again.").arg(address)))
+                                'updateStatusBar',
+                                tr._translate(
+                                    "MainWindow",
+                                    "{0} is already in 'Your Identities'."
+                                    " Not adding it again."
+                                ).format(address)
+                            ))
                         else:
-                            logger.debug('label: %s' % label)
+                            logger.debug('label: %s', label)
                             BMConfigParser().set(address, 'label', label)
                             BMConfigParser().set(address, 'enabled', 'true')
                             BMConfigParser().set(address, 'decoy', 'false')
@@ -263,8 +326,10 @@ class addressGenerator(threading.Thread, StoppableThread):
                                 address, 'privEncryptionKey', privEncryptionKeyWIF)
                             BMConfigParser().save()
 
-                            queues.UISignalQueue.put(('writeNewAddressToTable', (
-                                label, address, str(streamNumber))))
+                            queues.UISignalQueue.put((
+                                'writeNewAddressToTable',
+                                (label, address, str(streamNumber))
+                            ))
                             listOfNewAddressesToSendOutThroughTheAPI.append(
                                 address)
                             shared.myECCryptorObjects[ripe.digest()] = highlevelcrypto.makeCryptor(
@@ -281,7 +346,10 @@ class addressGenerator(threading.Thread, StoppableThread):
                                 queues.workerQueue.put((
                                     'sendOutOrStoreMyV4Pubkey', address))
                             queues.UISignalQueue.put((
-                                'updateStatusBar', tr._translate("MainWindow", "Done generating address")))
+                                'updateStatusBar',
+                                tr._translate(
+                                    "MainWindow", "Done generating address")
+                            ))
                     elif saveAddressToDisk and not live and not BMConfigParser().has_section(address):
                         listOfNewAddressesToSendOutThroughTheAPI.append(address)
 
diff --git a/src/class_objectProcessor.py b/src/class_objectProcessor.py
index 181ce30..ba98075 100644
--- a/src/class_objectProcessor.py
+++ b/src/class_objectProcessor.py
@@ -3,19 +3,16 @@ import threading
 import shared
 import hashlib
 import random
-from struct import unpack, pack
-import sys
+from struct import unpack
 import string
-from subprocess import call  # used when the API must execute an outside program
+# used when the API must execute an outside program
+from subprocess import call
 import traceback
 from binascii import hexlify
 
-from pyelliptic.openssl import OpenSSL
 import highlevelcrypto
 from addresses import *
 from bmconfigparser import BMConfigParser
-import helper_generic
-from helper_generic import addDataPadding
 import helper_bitcoin
 import helper_inbox
 import helper_msgcoding
@@ -29,6 +26,7 @@ import tr
 from debug import logger
 import l10n
 
+
 class objectProcessor(threading.Thread):
     """
     The objectProcessor thread, of which there is only one, receives network
@@ -105,15 +103,20 @@ class objectProcessor(threading.Thread):
         if data[readPosition:] in shared.ackdataForWhichImWatching:
             logger.info('This object is an acknowledgement bound for me.')
             del shared.ackdataForWhichImWatching[data[readPosition:]]
-            sqlExecute('UPDATE sent SET status=?, lastactiontime=? WHERE ackdata=?',
-                       'ackreceived',
-                       int(time.time()), 
-                       data[readPosition:])
-            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (data[readPosition:], tr._translate("MainWindow",'Acknowledgement of the message received %1').arg(l10n.formatTimestamp()))))
+            sqlExecute(
+                'UPDATE sent SET status=?, lastactiontime=? WHERE ackdata=?',
+                'ackreceived', int(time.time()), data[readPosition:])
+            queues.UISignalQueue.put((
+                'updateSentItemStatusByAckdata', (
+                    data[readPosition:], tr._translate(
+                        "MainWindow",
+                        "Acknowledgement of the message received {0}"
+                    ).format(l10n.formatTimestamp()))
+            ))
         else:
             logger.debug('This object is not an acknowledgement bound for me.')
 
-    
+
     def processgetpubkey(self, data):
         if len(data) > 200:
             logger.info('getpubkey is abnormally long. Sanity check failed. Ignoring object.')
diff --git a/src/class_outgoingSynSender.py b/src/class_outgoingSynSender.py
index 9b3eac1..6dd6320 100644
--- a/src/class_outgoingSynSender.py
+++ b/src/class_outgoingSynSender.py
@@ -3,10 +3,8 @@ import threading
 import time
 import random
 import shared
-import select
 import socks
 import socket
-import sys
 import tr
 
 from class_sendDataThread import *
@@ -17,9 +15,11 @@ import knownnodes
 import queues
 import state
 
+from debug import logger
+
+
 # For each stream to which we connect, several outgoingSynSender threads
 # will exist and will collectively create 8 connections with peers.
-
 class outgoingSynSender(threading.Thread, StoppableThread):
 
     def __init__(self):
@@ -207,16 +207,21 @@ class outgoingSynSender(threading.Thread, StoppableThread):
                 logger.debug(str(self) + ' connected to ' + str(peer) + ' during an outgoing attempt.')
             except socks.GeneralProxyError as err:
                 if err[0][0] in [7, 8, 9]:
-                    logger.error('Error communicating with proxy: %s', str(err))
+                    logger.error(
+                        'Error communicating with proxy: %s', err)
                     queues.UISignalQueue.put((
-                        'updateStatusBar',
-                        tr._translate(
-                            "MainWindow", "Problem communicating with proxy: %1. Please check your network settings.").arg(str(err[0][1]))
-                        ))
+                        'updateStatusBar', tr._translate(
+                            "MainWindow",
+                            "Problem communicating with proxy: {0}. Please"
+                            " check your network settings."
+                        ).format(err[0][1])
+                    ))
                     self.stop.wait(1)
                     continue
                 elif shared.verbose >= 2:
-                    logger.debug('Could NOT connect to ' + str(peer) + ' during outgoing attempt. ' + str(err))
+                    logger.debug(
+                        'Could NOT connect to %s during outgoing attempt. %s',
+                        peer, err)
 
                 deletedPeer = None
                 with knownnodes.knownNodesLock:
@@ -239,17 +244,21 @@ class outgoingSynSender(threading.Thread, StoppableThread):
             except socks.Socks5AuthError as err:
                 queues.UISignalQueue.put((
                     'updateStatusBar', tr._translate(
-                    "MainWindow", "SOCKS5 Authentication problem: %1. Please check your SOCKS5 settings.").arg(str(err))))
+                        "MainWindow",
+                        "SOCKS5 Authentication problem: {0}. Please check"
+                        " your SOCKS5 settings."
+                    ).format(err)
+                ))
             except socks.Socks5Error as err:
                 if err[0][0] in [3, 4, 5, 6]:
                     # this is a more bening "error": host unreachable, network unreachable, connection refused, TTL expired
-                    logger.debug('SOCKS5 error: %s', str(err))
+                    logger.debug('SOCKS5 error: %s', err)
                 else:
-                    logger.error('SOCKS5 error: %s', str(err))
+                    logger.error('SOCKS5 error: %s', err)
                 if err[0][0] == 4 or err[0][0] == 2:
                     state.networkProtocolAvailability[protocol.networkType(peer.host)] = False
             except socks.Socks4Error as err:
-                logger.error('Socks4Error: ' + str(err))
+                logger.error('Socks4Error: %s', err)
             except socket.error as err:
                 if BMConfigParser().get('bitmessagesettings', 'socksproxytype')[0:5] == 'SOCKS':
                     logger.error('Bitmessage MIGHT be having trouble connecting to the SOCKS server. ' + str(err))
@@ -278,6 +287,5 @@ class outgoingSynSender(threading.Thread, StoppableThread):
                     logger.debug('deleting ' + str(peer) + ' from knownnodes.knownNodes because it is more than 48 hours old and we could not connect to it.')
 
             except Exception as err:
-                import traceback
                 logger.exception('An exception has occurred in the outgoingSynSender thread that was not caught by other exception types:')
             self.stop.wait(0.1)
diff --git a/src/class_receiveDataThread.py b/src/class_receiveDataThread.py
index 4e86196..906cd08 100644
--- a/src/class_receiveDataThread.py
+++ b/src/class_receiveDataThread.py
@@ -1,7 +1,4 @@
-doTimingAttackMitigation = False
-
 import base64
-import datetime
 import errno
 import math
 import time
@@ -18,16 +15,11 @@ from struct import unpack, pack
 import sys
 import traceback
 from binascii import hexlify
-#import string
-#from subprocess import call  # used when the API must execute an outside program
-#from pyelliptic.openssl import OpenSSL
 
-#import highlevelcrypto
 from addresses import *
 from bmconfigparser import BMConfigParser
 from class_objectHashHolder import objectHashHolder
-from helper_generic import addDataPadding, isHostInPrivateIPRange
-from helper_sql import sqlQuery
+from helper_generic import isHostInPrivateIPRange
 import knownnodes
 from debug import logger
 import paths
@@ -37,11 +29,14 @@ import queues
 import state
 import throttle
 import tr
+import l10n
 from version import softwareVersion
 
+doTimingAttackMitigation = False
+
+
 # This thread is created either by the synSenderThread(for outgoing
 # connections) or the singleListenerThread(for incoming connections).
-
 class receiveDataThread(threading.Thread):
 
     def __init__(self):
@@ -167,7 +162,13 @@ class receiveDataThread(threading.Thread):
 
     def checkTimeOffsetNotification(self):
         if shared.timeOffsetWrongCount >= 4 and not self.connectionIsOrWasFullyEstablished:
-            queues.UISignalQueue.put(('updateStatusBar', tr._translate("MainWindow", "The time on your computer, %1, may be wrong. Please verify your settings.").arg(datetime.datetime.now().strftime("%H:%M:%S"))))
+            queues.UISignalQueue.put((
+                'updateStatusBar', tr._translate(
+                    "MainWindow",
+                    "The time on your computer, {0}, may be wrong. Please"
+                    " verify your settings."
+                ).format(l10n.formatTimestamp())
+            ))
 
     def processData(self):
         if len(self.data) < protocol.Header.size:  # if so little of the data has arrived that we can't even read the checksum then wait for more data.
diff --git a/src/class_singleWorker.py b/src/class_singleWorker.py
index 322bb20..4522597 100644
--- a/src/class_singleWorker.py
+++ b/src/class_singleWorker.py
@@ -3,20 +3,18 @@ from __future__ import division
 import threading
 import shared
 import time
-from time import strftime, localtime, gmtime
 import random
-from subprocess import call  # used when the API must execute an outside program
+# used when the API must execute an outside program
+from subprocess import call
 from addresses import *
 import highlevelcrypto
 import proofofwork
-import sys
 import tr
 from bmconfigparser import BMConfigParser
 from debug import logger
 import defaults
 from helper_sql import *
 import helper_inbox
-from helper_generic import addDataPadding
 import helper_msgcoding
 from helper_threading import *
 from inventory import Inventory, PendingUpload
@@ -29,13 +27,15 @@ from binascii import hexlify, unhexlify
 # This thread, of which there is only one, does the heavy lifting:
 # calculating POWs.
 
+
 def sizeof_fmt(num, suffix='h/s'):
-    for unit in ['','k','M','G','T','P','E','Z']:
+    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:
         if abs(num) < 1000.0:
             return "%3.1f%s%s" % (num, unit, suffix)
         num /= 1024.0
     return "%.1f%s%s" % (num, 'Yi', suffix)
 
+
 class singleWorker(threading.Thread, StoppableThread):
 
     def __init__(self):
@@ -514,7 +514,12 @@ class singleWorker(threading.Thread, StoppableThread):
             logger.info('sending inv (within sendBroadcast function) for object: ' + hexlify(inventoryHash))
             queues.invQueue.put((streamNumber, inventoryHash))
 
-            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Broadcast sent on %1").arg(l10n.formatTimestamp()))))
+            queues.UISignalQueue.put((
+                'updateSentItemStatusByAckdata', (
+                    ackdata, tr._translate(
+                        "MainWindow", "Broadcast sent on {0}"
+                    ).format(l10n.formatTimestamp()))
+            ))
 
             # Update the status of the message in the 'sent' table to have
             # a 'broadcastsent' status
@@ -524,7 +529,6 @@ class singleWorker(threading.Thread, StoppableThread):
                 'broadcastsent',
                 int(time.time()),
                 ackdata)
-        
 
     def sendMsg(self):
         # Reset just in case
@@ -667,9 +671,24 @@ class singleWorker(threading.Thread, StoppableThread):
                 # in the settings menu to allow it.
                 if shared.isBitSetWithinBitfield(behaviorBitfield,30): # if receiver is a mobile device who expects that their address RIPE is included unencrypted on the front of the message..
                     if not shared.BMConfigParser().safeGetBoolean('bitmessagesettings','willinglysendtomobile'): # if we are Not willing to include the receiver's RIPE hash on the message..
-                        logger.info('The receiver is a mobile user but the sender (you) has not selected that you are willing to send to mobiles. Aborting send.')
-                        queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: Destination is a mobile device who requests that the destination be included in the message but this is disallowed in your settings.  %1').arg(l10n.formatTimestamp()))))
-                        # if the human changes their setting and then sends another message or restarts their client, this one will send at that time.
+                        logger.info(
+                            'The receiver is a mobile user but the sender'
+                            ' (you) has not selected that you are willing'
+                            ' to send to mobiles. Aborting send.')
+                        queues.UISignalQueue.put((
+                            'updateSentItemStatusByAckdata', (
+                                ackdata, tr._translate(
+                                    "MainWindow",
+                                    "Problem: Destination is a mobile"
+                                    " device who requests that the"
+                                    " destination be included in the"
+                                    " message but this is disallowed in"
+                                    " your settings.  {0}"
+                                ).format(l10n.formatTimestamp()))
+                        ))
+                        # if the human changes their setting and then
+                        # sends another message or restarts their client,
+                        # this one will send at that time.
                         continue
                 readPosition += 4  # to bypass the bitfield of behaviors
                 # pubSigningKeyBase256 = pubkeyPayload[readPosition:readPosition+64] # We don't use this key for anything here.
@@ -695,30 +714,71 @@ class singleWorker(threading.Thread, StoppableThread):
                         requiredAverageProofOfWorkNonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
                     if requiredPayloadLengthExtraBytes < defaults.networkDefaultPayloadLengthExtraBytes:
                         requiredPayloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
-                    logger.debug('Using averageProofOfWorkNonceTrialsPerByte: %s and payloadLengthExtraBytes: %s.' % (requiredAverageProofOfWorkNonceTrialsPerByte, requiredPayloadLengthExtraBytes))
-                    queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Doing work necessary to send message.\nReceiver\'s required difficulty: %1 and %2").arg(str(float(
-                        requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte)).arg(str(float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)))))
+                    logger.debug(
+                        'Using averageProofOfWorkNonceTrialsPerByte: %s'
+                        ' and payloadLengthExtraBytes: %s.',
+                        requiredAverageProofOfWorkNonceTrialsPerByte,
+                        requiredPayloadLengthExtraBytes
+                    )
+                    queues.UISignalQueue.put((
+                        'updateSentItemStatusByAckdata', (
+                            ackdata, tr._translate(
+                                "MainWindow",
+                                "Doing work necessary to send message.\n"
+                                "Receiver\'s required difficulty: {0} and {1}"
+                            ).format(
+                                float(requiredAverageProofOfWorkNonceTrialsPerByte)
+                                / defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+                                float(requiredPayloadLengthExtraBytes)
+                                / defaults.networkDefaultPayloadLengthExtraBytes))
+                    ))
                     if status != 'forcepow':
                         if (requiredAverageProofOfWorkNonceTrialsPerByte > BMConfigParser().getint('bitmessagesettings', 'maxacceptablenoncetrialsperbyte') and BMConfigParser().getint('bitmessagesettings', 'maxacceptablenoncetrialsperbyte') != 0) or (requiredPayloadLengthExtraBytes > BMConfigParser().getint('bitmessagesettings', 'maxacceptablepayloadlengthextrabytes') and BMConfigParser().getint('bitmessagesettings', 'maxacceptablepayloadlengthextrabytes') != 0):
-                            # The demanded difficulty is more than we are willing
-                            # to do.
+                            # The demanded difficulty is more than
+                            # we are willing to do.
                             sqlExecute(
-                                '''UPDATE sent SET status='toodifficult' WHERE ackdata=? ''',
-                                ackdata)
-                            queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Problem: The work demanded by the recipient (%1 and %2) is more difficult than you are willing to do. %3").arg(str(float(requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte)).arg(str(float(
-                                requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)).arg(l10n.formatTimestamp()))))
+                                "UPDATE sent SET status='toodifficult'"
+                                " WHERE ackdata=?", ackdata)
+                            queues.UISignalQueue.put((
+                                'updateSentItemStatusByAckdata', (
+                                    ackdata, tr._translate(
+                                        "MainWindow",
+                                        "Problem: The work demanded by the"
+                                        " recipient ({0} and {1}) is more"
+                                        " difficult than you are willing"
+                                        " to do. {2}"
+                                    ).format(
+                                        float(requiredAverageProofOfWorkNonceTrialsPerByte)
+                                        / defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+                                        float(requiredPayloadLengthExtraBytes)
+                                        / defaults.networkDefaultPayloadLengthExtraBytes,
+                                        l10n.formatTimestamp()))
+                            ))
                             continue
             else: # if we are sending a message to ourselves or a chan..
                 logger.info('Sending a message.')
-                logger.debug('First 150 characters of message: ' + repr(message[:150]))
+                logger.debug(
+                    'First 150 characters of message: %r', message[:150])
                 behaviorBitfield = protocol.getBitfield(fromaddress)
 
                 try:
                     privEncryptionKeyBase58 = BMConfigParser().get(
                         toaddress, 'privencryptionkey')
                 except Exception as err:
-                    queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: You are trying to send a message to yourself or a chan but your encryption key could not be found in the keys.dat file. Could not encrypt message. %1').arg(l10n.formatTimestamp()))))
-                    logger.error('Error within sendMsg. Could not read the keys from the keys.dat file for our own address. %s\n' % err)
+                    queues.UISignalQueue.put((
+                        'updateSentItemStatusByAckdata', (
+                            ackdata, tr._translate(
+                                "MainWindow",
+                                "Problem: You are trying to send a message"
+                                " to yourself or a chan but your encryption"
+                                " key could not be found in the keys.dat"
+                                " file. Could not encrypt message. {0}"
+                            ).format(l10n.formatTimestamp()))
+                    ))
+                    logger.error(
+                        'Error within sendMsg. Could not read the keys'
+                        ' from the keys.dat file for our own address. %s\n',
+                         err)
                     continue
                 privEncryptionKeyHex = hexlify(shared.decodeWalletImportFormat(
                     privEncryptionKeyBase58))
@@ -726,8 +786,11 @@ class singleWorker(threading.Thread, StoppableThread):
                     privEncryptionKeyHex))[1:]
                 requiredAverageProofOfWorkNonceTrialsPerByte = defaults.networkDefaultProofOfWorkNonceTrialsPerByte
                 requiredPayloadLengthExtraBytes = defaults.networkDefaultPayloadLengthExtraBytes
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (
-                    ackdata, tr._translate("MainWindow", "Doing work necessary to send message."))))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                    ackdata, tr._translate(
+                        "MainWindow", "Doing work necessary to send message."))
+                ))
 
             # Now we can start to assemble our message.
             payload = encodeVarint(fromAddressVersionNumber)
@@ -799,35 +862,52 @@ class singleWorker(threading.Thread, StoppableThread):
 
             # We have assembled the data that will be encrypted.
             try:
-                encrypted = highlevelcrypto.encrypt(payload,"04"+hexlify(pubEncryptionKeyBase256))
+                encrypted = highlevelcrypto.encrypt(
+                    payload, "04" + hexlify(pubEncryptionKeyBase256))
             except:
-                sqlExecute('''UPDATE sent SET status='badkey' WHERE ackdata=?''', ackdata)
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata',(ackdata,tr._translate("MainWindow",'Problem: The recipient\'s encryption key is no good. Could not encrypt message. %1').arg(l10n.formatTimestamp()))))
+                sqlExecute(
+                    '''UPDATE sent SET status='badkey' WHERE ackdata=?''',
+                    ackdata)
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata, tr._translate(
+                            "MainWindow",
+                            "Problem: The recipient\'s encryption key is"
+                            " no good. Could not encrypt message. {0}"
+                        ).format(l10n.formatTimestamp()))))
                 continue
-            
+
             encryptedPayload = pack('>Q', embeddedTime)
             encryptedPayload += '\x00\x00\x00\x02' # object type: msg
             encryptedPayload += encodeVarint(1) # msg version
             encryptedPayload += encodeVarint(toStreamNumber) + encrypted
             target = 2 ** 64 / (requiredAverageProofOfWorkNonceTrialsPerByte*(len(encryptedPayload) + 8 + requiredPayloadLengthExtraBytes + ((TTL*(len(encryptedPayload)+8+requiredPayloadLengthExtraBytes))/(2 ** 16))))
-            logger.info('(For msg message) Doing proof of work. Total required difficulty: %f. Required small message difficulty: %f.', float(requiredAverageProofOfWorkNonceTrialsPerByte) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte, float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes)
+            logger.info(
+                '(For msg message) Doing proof of work. Total required'
+                ' difficulty: %f. Required small message difficulty: %f.',
+                float(requiredAverageProofOfWorkNonceTrialsPerByte)
+                / defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+                float(requiredPayloadLengthExtraBytes)
+                / defaults.networkDefaultPayloadLengthExtraBytes)
 
             powStartTime = time.time()
             initialHash = hashlib.sha512(encryptedPayload).digest()
             trialValue, nonce = proofofwork.run(target, initialHash)
-            logger.info('(For msg message) Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
+            logger.info(
+                '(For msg message) Found proof of work %s Nonce: %s',
+                trialValue, nonce)
             try:
                 logger.info('PoW took %.1f seconds, speed %s.', time.time() - powStartTime, sizeof_fmt(nonce / (time.time() - powStartTime)))
             except:
                 pass
 
             encryptedPayload = pack('>Q', nonce) + encryptedPayload
-            
+
             # Sanity check. The encryptedPayload size should never be larger than 256 KiB. There should
             # be checks elsewhere in the code to not let the user try to send a message this large
             # until we implement message continuation. 
             if len(encryptedPayload) > 2 ** 18: # 256 KiB
-                logger.critical('This msg object is too large to send. This should never happen. Object size: %s' % len(encryptedPayload))
+                logger.critical('This msg object is too large to send. This should never happen. Object size: %s', len(encryptedPayload))
                 continue
 
             inventoryHash = calculateInventoryHash(encryptedPayload)
@@ -836,11 +916,25 @@ class singleWorker(threading.Thread, StoppableThread):
                 objectType, toStreamNumber, encryptedPayload, embeddedTime, '')
             PendingUpload().add(inventoryHash)
             if BMConfigParser().has_section(toaddress) or not protocol.checkBitfield(behaviorBitfield, protocol.BITFIELD_DOESACK):
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Message sent. Sent at %1").arg(l10n.formatTimestamp()))))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata, tr._translate(
+                            "MainWindow", "Message sent. Sent at {0}"
+                        ).format(l10n.formatTimestamp()))
+                ))
             else:
                 # not sending to a chan or one of my addresses
-                queues.UISignalQueue.put(('updateSentItemStatusByAckdata', (ackdata, tr._translate("MainWindow", "Message sent. Waiting for acknowledgement. Sent on %1").arg(l10n.formatTimestamp()))))
-            logger.info('Broadcasting inv for my msg(within sendmsg function):' + hexlify(inventoryHash))
+                queues.UISignalQueue.put((
+                    'updateSentItemStatusByAckdata', (
+                        ackdata, tr._translate(
+                            "MainWindow",
+                            "Message sent. Waiting for acknowledgement."
+                            " Sent on {0}"
+                        ).format(l10n.formatTimestamp()))
+                ))
+            logger.info(
+                'Broadcasting inv for my msg(within sendmsg function): %s',
+                hexlify(inventoryHash))
             queues.invQueue.put((toStreamNumber, inventoryHash))
 
             # Update the sent message in the sent table with the necessary information.
@@ -955,19 +1049,30 @@ class singleWorker(threading.Thread, StoppableThread):
             toAddress)
 
         queues.UISignalQueue.put((
-            'updateStatusBar', tr._translate("MainWindow",'Broadcasting the public key request. This program will auto-retry if they are offline.')))
-        queues.UISignalQueue.put(('updateSentItemStatusByToAddress', (toAddress, tr._translate("MainWindow",'Sending public key request. Waiting for reply. Requested at %1').arg(l10n.formatTimestamp()))))
+            'updateStatusBar', tr._translate(
+                "MainWindow",
+                "Broadcasting the public key request. This program will"
+                " auto-retry if they are offline.")
+        ))
+        queues.UISignalQueue.put((
+            'updateSentItemStatusByToAddress', (
+                toAddress, tr._translate(
+                    "MainWindow",
+                    "Sending public key request. Waiting for reply."
+                    " Requested at {0}"
+                ).format(l10n.formatTimestamp()))
+        ))
 
     def generateFullAckMessage(self, ackdata, toStreamNumber, TTL):
-        
+
         # It might be perfectly fine to just use the same TTL for
         # the ackdata that we use for the message. But I would rather
-        # it be more difficult for attackers to associate ackData with 
+        # it be more difficult for attackers to associate ackData with
         # the associated msg object. However, users would want the TTL
         # of the acknowledgement to be about the same as they set
-        # for the message itself. So let's set the TTL of the 
-        # acknowledgement to be in one of three 'buckets': 1 hour, 7 
-        # days, or 28 days, whichever is relatively close to what the 
+        # for the message itself. So let's set the TTL of the
+        # acknowledgement to be in one of three 'buckets': 1 hour, 7
+        # days, or 28 days, whichever is relatively close to what the
         # user specified.
         if TTL < 24*60*60: # 1 day
             TTL = 24*60*60 # 1 day
@@ -975,21 +1080,28 @@ class singleWorker(threading.Thread, StoppableThread):
             TTL = 7*24*60*60 # 1 week
         else:
             TTL = 28*24*60*60 # 4 weeks
-        TTL = int(TTL + random.randrange(-300, 300)) # Add some randomness to the TTL
+        # Add some randomness to the TTL
+        TTL = int(TTL + random.randrange(-300, 300))
         embeddedTime = int(time.time() + TTL)
 
-        # type/version/stream already included 
+        # type/version/stream already included
         payload = pack('>Q', (embeddedTime)) + ackdata
 
         target = 2 ** 64 / (defaults.networkDefaultProofOfWorkNonceTrialsPerByte*(len(payload) + 8 + defaults.networkDefaultPayloadLengthExtraBytes + ((TTL*(len(payload)+8+defaults.networkDefaultPayloadLengthExtraBytes))/(2 ** 16))))
-        logger.info('(For ack message) Doing proof of work. TTL set to ' + str(TTL))
+        logger.info(
+            '(For ack message) Doing proof of work. TTL set to %s', TTL)
 
         powStartTime = time.time()
         initialHash = hashlib.sha512(payload).digest()
         trialValue, nonce = proofofwork.run(target, initialHash)
-        logger.info('(For ack message) Found proof of work ' + str(trialValue) + ' Nonce: ' + str(nonce))
+        logger.info(
+            '(For ack message) Found proof of work %s Nonce: %s',
+            trialValue, nonce)
         try:
-            logger.info('PoW took %.1f seconds, speed %s.', time.time() - powStartTime, sizeof_fmt(nonce / (time.time() - powStartTime)))
+            logger.info(
+                'PoW took %.1f seconds, speed %s.',
+                time.time() - powStartTime,
+                sizeof_fmt(nonce / (time.time() - powStartTime)))
         except:
             pass
 
diff --git a/src/debug.py b/src/debug.py
index 79c6e64..8a4c451 100644
--- a/src/debug.py
+++ b/src/debug.py
@@ -24,27 +24,37 @@ import helper_startup
 import state
 helper_startup.loadConfig()
 
-# Now can be overriden from a config file, which uses standard python logging.config.fileConfig interface
-# examples are here: https://bitmessage.org/forum/index.php/topic,4820.msg11163.html#msg11163
+# Now can be overriden from a config file, which uses standard python
+# logging.config.fileConfig interface examples are here:
+# https://bitmessage.org/forum/index.php/topic,4820.msg11163.html#msg11163
 log_level = 'WARNING'
 
+
 def log_uncaught_exceptions(ex_cls, ex, tb):
     logging.critical('Unhandled exception', exc_info=(ex_cls, ex, tb))
+    # logging.critical(
+    #     'Unhandled exception of type %s: %s,\ntraceback: %s', ex_cls, ex, tb)
+
 
 def configureLogging():
     have_logging = False
+    config_path = os.path.join(state.appdata, 'logging.dat')
     try:
-        logging.config.fileConfig(os.path.join (state.appdata, 'logging.dat'))
+        logging.config.fileConfig(config_path)
         have_logging = True
-        print "Loaded logger configuration from %s" % (os.path.join(state.appdata, 'logging.dat'))
+        print "Loaded logger configuration from %s" % config_path
     except:
-        if os.path.isfile(os.path.join(state.appdata, 'logging.dat')):
-            print "Failed to load logger configuration from %s, using default logging config" % (os.path.join(state.appdata, 'logging.dat'))
+        if os.path.isfile(config_path):
+            print(
+                "Failed to load logger configuration from %s,"
+                " using default logging config" % config_path
+            )
             print sys.exc_info()
         else:
-            # no need to confuse the user if the logger config is missing entirely
+            # no need to confuse the user if the logger config
+            # is missing entirely
             print "Using default logger configuration"
-    
+
     sys.excepthook = log_uncaught_exceptions
 
     if have_logging:
@@ -69,7 +79,7 @@ def configureLogging():
                 'formatter': 'default',
                 'level': log_level,
                 'filename': state.appdata + 'debug.log',
-                'maxBytes': 2097152, # 2 MiB
+                'maxBytes': 2097152,  # 2 MiB
                 'backupCount': 1,
                 'encoding': 'UTF-8',
             }
@@ -77,15 +87,15 @@ def configureLogging():
         'loggers': {
             'console_only': {
                 'handlers': ['console'],
-                'propagate' : 0
+                'propagate': 0
             },
             'file_only': {
                 'handlers': ['file'],
-                'propagate' : 0
+                'propagate': 0
             },
             'both': {
                 'handlers': ['console', 'file'],
-                'propagate' : 0
+                'propagate': 0
             },
         },
         'root': {
@@ -95,8 +105,9 @@ def configureLogging():
     })
     return True
 
+
 # TODO (xj9): Get from a config file.
-#logger = logging.getLogger('console_only')
+# logger = logging.getLogger('console_only')
 if configureLogging():
     if '-c' in sys.argv:
         logger = logging.getLogger('file_only')
@@ -105,6 +116,7 @@ if configureLogging():
 else:
     logger = logging.getLogger('default')
 
+
 def restartLoggingInUpdatedAppdataLocation():
     global logger
     for i in list(logger.handlers):
@@ -118,4 +130,3 @@ def restartLoggingInUpdatedAppdataLocation():
             logger = logging.getLogger('both')
     else:
         logger = logging.getLogger('default')
-
diff --git a/src/depends.py b/src/depends.py
index d66663b..14cd0d0 100755
--- a/src/depends.py
+++ b/src/depends.py
@@ -165,40 +165,42 @@ def check_curses():
     logger.info('dialog Utility Version' + unicode(dialog_util_version))
     return True
 
+
 def check_pyqt():
-    try:
-        import PyQt4.QtCore
-    except ImportError:
-        logger.error('The PyQt4 package is not available. PyBitmessage requires PyQt 4.8 or later and Qt 4.7 or later.')
-        if sys.platform.startswith('openbsd'):
-            logger.error('On OpenBSD, try running "pkg_add py-qt4" as root.')
-        elif sys.platform.startswith('freebsd'):
-            logger.error('On FreeBSD, try running "pkg install py27-qt4" as root.')
-        elif os.path.isfile("/etc/os-release"):
-            with open("/etc/os-release", 'rt') as osRelease:
-                for line in osRelease:
-                    if line.startswith("NAME="):
-                        if "fedora" in line.lower():
-                            logger.error('On Fedora, try running "dnf install PyQt4" as root.')
-                        elif "opensuse" in line.lower():
-                            logger.error('On openSUSE, try running "zypper install python-qt" as root.')
-                        elif "ubuntu" in line.lower():
-                            logger.error('On Ubuntu, try running "apt-get install python-qt4" as root.')
-                        elif "debian" in line.lower():
-                            logger.error('On Debian, try running "apt-get install python-qt4" as root.')
-                        else:
-                            logger.error('If your package manager does not have this package, try running "pip install PyQt4".')
-        return False
-    logger.info('PyQt Version: ' + PyQt4.QtCore.PYQT_VERSION_STR)
-    logger.info('Qt Version: ' + PyQt4.QtCore.QT_VERSION_STR)
-    passed = True
-    if PyQt4.QtCore.PYQT_VERSION < 0x40800:
-        logger.error('This version of PyQt is too old. PyBitmessage requries PyQt 4.8 or later.')
-        passed = False
-    if PyQt4.QtCore.QT_VERSION < 0x40700:
-        logger.error('This version of Qt is too old. PyBitmessage requries Qt 4.7 or later.')
-        passed = False
-    return passed
+    return True
+    # try:
+    #     import PyQt4.QtCore
+    # except ImportError:
+    #     logger.error('The PyQt4 package is not available. PyBitmessage requires PyQt 4.8 or later and Qt 4.7 or later.')
+    #     if sys.platform.startswith('openbsd'):
+    #         logger.error('On OpenBSD, try running "pkg_add py-qt4" as root.')
+    #     elif sys.platform.startswith('freebsd'):
+    #         logger.error('On FreeBSD, try running "pkg install py27-qt4" as root.')
+    #     elif os.path.isfile("/etc/os-release"):
+    #         with open("/etc/os-release", 'rt') as osRelease:
+    #             for line in osRelease:
+    #                 if line.startswith("NAME="):
+    #                     if "fedora" in line.lower():
+    #                         logger.error('On Fedora, try running "dnf install PyQt4" as root.')
+    #                     elif "opensuse" in line.lower():
+    #                         logger.error('On openSUSE, try running "zypper install python-qt" as root.')
+    #                     elif "ubuntu" in line.lower():
+    #                         logger.error('On Ubuntu, try running "apt-get install python-qt4" as root.')
+    #                     elif "debian" in line.lower():
+    #                         logger.error('On Debian, try running "apt-get install python-qt4" as root.')
+    #                     else:
+    #                         logger.error('If your package manager does not have this package, try running "pip install PyQt4".')
+    #     return False
+    # logger.info('PyQt Version: ' + PyQt4.QtCore.PYQT_VERSION_STR)
+    # logger.info('Qt Version: ' + PyQt4.QtCore.QT_VERSION_STR)
+    # passed = True
+    # if PyQt4.QtCore.PYQT_VERSION < 0x40800:
+    #     logger.error('This version of PyQt is too old. PyBitmessage requries PyQt 4.8 or later.')
+    #     passed = False
+    # if PyQt4.QtCore.QT_VERSION < 0x40700:
+    #     logger.error('This version of Qt is too old. PyBitmessage requries Qt 4.7 or later.')
+    #     passed = False
+    # return passed
 
 def check_msgpack():
     try:
diff --git a/src/helper_msgcoding.py b/src/helper_msgcoding.py
index f8bc95a..fbaf3a8 100644
--- a/src/helper_msgcoding.py
+++ b/src/helper_msgcoding.py
@@ -135,8 +135,10 @@ class MsgDecode(object):
         # Throw away any extra lines (headers) after the subject.
         if subject:
             subject = subject.splitlines()[0]
-        self.subject = subject
-        self.body = body
+        # Field types should be the same for all message types
+        self.subject = unicode(subject, 'utf-8', 'replace')
+        self.body = unicode(body, 'utf-8', 'replace')
+
 
 if __name__ == '__main__':
     import random
diff --git a/src/helper_search.py b/src/helper_search.py
index 2217974..7de9f1e 100644
--- a/src/helper_search.py
+++ b/src/helper_search.py
@@ -1,29 +1,19 @@
-#!/usr/bin/python2.7
+from helper_sql import sqlQuery
+from tr import _translate
 
-from helper_sql import *
 
-try:
-    from PyQt4 import QtCore, QtGui
-    haveQt = True
-except:
-    haveQt = False
-
-def search_translate (context, text):
-    if haveQt:
-        return QtGui.QApplication.translate(context, text)
-    else:
-        return text.lower()
-
-def search_sql(xAddress = "toaddress", account = None, folder = "inbox", where = None, what = None, unreadOnly = False):
+def search_sql(
+        xAddress="toaddress", account=None, folder="inbox", where=None,
+        what=None, unreadOnly=False):
     if what is not None and what != "":
         what = "%" + what + "%"
-        if where == search_translate("MainWindow", "To"):
+        if where == _translate("MainWindow", "To"):
             where = "toaddress"
-        elif where == search_translate("MainWindow", "From"):
+        elif where == _translate("MainWindow", "From"):
             where = "fromaddress"
-        elif where == search_translate("MainWindow", "Subject"):
+        elif where == _translate("MainWindow", "Subject"):
             where = "subject"
-        elif where == search_translate("MainWindow", "Message"):
+        elif where == _translate("MainWindow", "Message"):
             where = "message"
         else:
             where = "toaddress || fromaddress || subject || message"
@@ -68,18 +58,30 @@ def search_sql(xAddress = "toaddress", account = None, folder = "inbox", where =
         sqlStatementBase += " ORDER BY lastactiontime"
     return sqlQuery(sqlStatementBase, sqlArguments)
 
-def check_match(toAddress, fromAddress, subject, message, where = None, what = None):
+
+def check_match(
+        toAddress, fromAddress, subject, message, where=None, what=None):
     if what is not None and what != "":
-        if where in (search_translate("MainWindow", "To"), search_translate("MainWindow", "All")):
+        if where in (
+            _translate("MainWindow", "To"), _translate("MainWindow", "All")
+        ):
             if what.lower() not in toAddress.lower():
                 return False
-        elif where in (search_translate("MainWindow", "From"), search_translate("MainWindow", "All")):
+        elif where in (
+            _translate("MainWindow", "From"), _translate("MainWindow", "All")
+        ):
             if what.lower() not in fromAddress.lower():
                 return False
-        elif where in (search_translate("MainWindow", "Subject"), search_translate("MainWindow", "All")):
+        elif where in (
+            _translate("MainWindow", "Subject"),
+            _translate("MainWindow", "All")
+        ):
             if what.lower() not in subject.lower():
                 return False
-        elif where in (search_translate("MainWindow", "Message"), search_translate("MainWindow", "All")):
+        elif where in (
+            _translate("MainWindow", "Message"),
+            _translate("MainWindow", "All")
+        ):
             if what.lower() not in message.lower():
                 return False
     return True
diff --git a/src/namecoin.py b/src/namecoin.py
index 9b3c3c3..17c1f7d 100644
--- a/src/namecoin.py
+++ b/src/namecoin.py
@@ -28,7 +28,7 @@ import os
 
 from bmconfigparser import BMConfigParser
 import defaults
-import tr # translate
+import tr
 
 # FIXME: from debug import logger crashes PyBitmessage due to a circular
 # dependency. The debug module will also override/disable logging.getLogger()
@@ -37,6 +37,7 @@ import logging as logger
 
 configSection = "bitmessagesettings"
 
+
 # Error thrown when the RPC call returns an error.
 class RPCError (Exception):
     error = None
@@ -85,20 +86,25 @@ class namecoinConnection (object):
     # string.  If it doesn't contain a slash, id/ is prepended.  We return
     # the result as (Error, Address) pair, where the Error is an error
     # message to display or None in case of success.
-    def query (self, string):
-        slashPos = string.find ("/")
+    def query(self, string):
+        slashPos = string.find("/")
         if slashPos < 0:
             string = "id/" + string
 
         try:
             if self.nmctype == "namecoind":
-                res = self.callRPC ("name_show", [string])
+                res = self.callRPC("name_show", [string])
                 res = res["value"]
             elif self.nmctype == "nmcontrol":
-                res = self.callRPC ("data", ["getValue", string])
+                res = self.callRPC("data", ["getValue", string])
                 res = res["reply"]
-                if res == False:
-                    return (tr._translate("MainWindow",'The name %1 was not found.').arg(unicode(string)), None)
+                if res is False:
+                    return (
+                        tr._translate(
+                            "MainWindow", "The name {0} was not found."
+                        ).format(string),
+                        None
+                    )
             else:
                 assert False
         except RPCError as exc:
@@ -107,16 +113,29 @@ class namecoinConnection (object):
                 errmsg = exc.error["message"]
             else:
                 errmsg = exc.error
-            return (tr._translate("MainWindow",'The namecoin query failed (%1)').arg(unicode(errmsg)), None)
+            return (
+                tr._translate(
+                    "MainWindow", "The namecoin query failed ({0})"
+                ).format(errmsg),
+                None
+            )
         except Exception as exc:
             logger.exception("Namecoin query exception")
-            return (tr._translate("MainWindow",'The namecoin query failed.'), None)
+            return (
+                tr._translate("MainWindow", "The namecoin query failed."),
+                None
+            )
 
         try:
-            val = json.loads (res)
+            val = json.loads(res)
         except:
             logger.exception("Namecoin query json exception")
-            return (tr._translate("MainWindow",'The name %1 has no valid JSON data.').arg(unicode(string)), None)            
+            return (
+                tr._translate(
+                    "MainWindow", "The name {0} has no valid JSON data."
+                ).format(string),
+                None
+            )
 
         if "bitmessage" in val:
             if "name" in val:
@@ -124,7 +143,13 @@ class namecoinConnection (object):
             else:
                 ret = val["bitmessage"]
             return (None, ret)
-        return (tr._translate("MainWindow",'The name %1 has no associated Bitmessage address.').arg(unicode(string)), None) 
+        return (
+            tr._translate(
+                "MainWindow",
+                "The name {0} has no associated Bitmessage address."
+            ).format(string),
+            None
+        )
 
     # Test the connection settings.  This routine tries to query a "getinfo"
     # command, and builds either an error message or a success message with
@@ -146,7 +171,13 @@ class namecoinConnection (object):
                   versStr = "0.%d.%d" % (v1, v2)
                 else:
                   versStr = "0.%d.%d.%d" % (v1, v2, v3)
-                return ('success',  tr._translate("MainWindow",'Success!  Namecoind version %1 running.').arg(unicode(versStr)) )
+                return (
+                    'success',
+                    tr._translate(
+                        "MainWindow",
+                        "Success!  Namecoind version {0} running."
+                    ).format(versStr)
+                )
 
             elif self.nmctype == "nmcontrol":
                 res = self.callRPC ("data", ["status"])
diff --git a/src/network/tcp.py b/src/network/tcp.py
index 33c4b6c..03eaf08 100644
--- a/src/network/tcp.py
+++ b/src/network/tcp.py
@@ -1,39 +1,30 @@
-import base64
-from binascii import hexlify
-import hashlib
 import math
 import time
-from pprint import pprint
 import socket
-import struct
 import random
-import traceback
 
-from addresses import calculateInventoryHash
 from debug import logger
 from helper_random import randomBytes
 from inventory import Inventory
 import knownnodes
 from network.advanceddispatcher import AdvancedDispatcher
-from network.bmproto import BMProtoError, BMProtoInsufficientDataError, BMProtoExcessiveDataError, BMProto
-from network.bmobject import BMObject, BMObjectInsufficientPOWError, BMObjectInvalidDataError, BMObjectExpiredError, BMObjectUnwantedStreamError, BMObjectInvalidError, BMObjectAlreadyHaveError
+from network.bmproto import BMProto
 import network.connectionpool
 from network.dandelion import Dandelion
-from network.node import Node
 import network.asyncore_pollchoose as asyncore
-from network.proxy import Proxy, ProxyError, GeneralProxyError
 from network.objectracker import ObjectTracker
-from network.socks5 import Socks5Connection, Socks5Resolver, Socks5AuthError, Socks5Error
-from network.socks4a import Socks4aConnection, Socks4aResolver, Socks4aError
+from network.socks5 import Socks5Connection
+from network.socks4a import Socks4aConnection
 from network.tls import TLSDispatcher
 
 import addresses
 from bmconfigparser import BMConfigParser
-from queues import invQueue, objectProcessorQueue, portCheckerQueue, UISignalQueue, receiveDataQueue
+from queues import invQueue, UISignalQueue, receiveDataQueue
 import shared
 import state
 import protocol
 
+
 class TCPConnection(BMProto, TLSDispatcher):
     def __init__(self, address=None, sock=None):
         BMProto.__init__(self, address=address, sock=sock)
diff --git a/src/plugins/plugin.py b/src/plugins/plugin.py
index 6601ada..0e49c31 100644
--- a/src/plugins/plugin.py
+++ b/src/plugins/plugin.py
@@ -20,6 +20,7 @@ def get_plugins(group, point='', name=None, fallback=None):
             except (AttributeError,
                     ImportError,
                     ValueError,
+                    RuntimeError,  # PyQt for example
                     pkg_resources.DistributionNotFound,
                     pkg_resources.UnknownExtra):
                 continue
diff --git a/src/qidenticon.py b/src/qidenticon.py
index cc3af6b..a4ac0ed 100644
--- a/src/qidenticon.py
+++ b/src/qidenticon.py
@@ -49,16 +49,14 @@ Return a PIL Image class instance which have generated identicon image.
 ```size``` specifies `patch size`. Generated image size is 3 * ```size```.
 """
 
-# we probably don't need all of them, but i don't want to check now
-from PyQt4 import QtCore, QtGui
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
+from qtpy import QtCore, QtGui
 
 __all__ = ['render_identicon', 'IdenticonRendererBase']
 
+
 class IdenticonRendererBase(object):
     PATH_SET = []
-    
+
     def __init__(self, code):
         """
         @param code code for icon
@@ -66,53 +64,56 @@ class IdenticonRendererBase(object):
         if not isinstance(code, int):
             code = int(code)
         self.code = code
-    
+
     def render(self, size, twoColor, opacity, penwidth):
         """
         render identicon to QPicture
-        
+
         @param size identicon patchsize. (image size is 3 * [size])
         @return QPicture
         """
-        
+
         # decode the code
-        middle, corner, side, foreColor, secondColor, swap_cross = self.decode(self.code, twoColor)
+        middle, corner, side, foreColor, secondColor, swap_cross = \
+            self.decode(self.code, twoColor)
 
         # make image
-        image = QPixmap(QSize(size * 3 +penwidth, size * 3 +penwidth))
-        
+        image = QtGui.QPixmap(
+            QtCore.QSize(size * 3 + penwidth, size * 3 + penwidth))
+
         # fill background
-        backColor = QtGui.QColor(255,255,255,opacity)
+        backColor = QtGui.QColor(255, 255, 255, opacity)
         image.fill(backColor)
-        
+
         kwds = {
             'image': image,
             'size': size,
             'foreColor': foreColor if swap_cross else secondColor,
             'penwidth': penwidth,
             'backColor': backColor}
-            
+
         # middle patch
-        image = self.drawPatchQt((1, 1), middle[2], middle[1], middle[0], **kwds)
-        
+        image = self.drawPatchQt(
+            (1, 1), middle[2], middle[1], middle[0], **kwds)
+
         # side patch
         kwds['foreColor'] = foreColor
         kwds['type'] = side[0]
         for i in xrange(4):
             pos = [(1, 0), (2, 1), (1, 2), (0, 1)][i]
             image = self.drawPatchQt(pos, side[2] + 1 + i, side[1], **kwds)
-            
+
         # corner patch
         kwds['foreColor'] = secondColor
         kwds['type'] = corner[0]
         for i in xrange(4):
             pos = [(0, 0), (2, 0), (2, 2), (0, 2)][i]
             image = self.drawPatchQt(pos, corner[2] + 1 + i, corner[1], **kwds)
-        
+
         return image
-                
 
-    def drawPatchQt(self, pos, turn, invert, type, image, size, foreColor,
+    def drawPatchQt(
+            self, pos, turn, invert, type, image, size, foreColor,
             backColor, penwidth):
         """
         @param size patch size
@@ -123,97 +124,102 @@ class IdenticonRendererBase(object):
             invert = not invert
             path = [(0., 0.), (1., 0.), (1., 1.), (0., 1.), (0., 0.)]
 
-        
-        polygon = QPolygonF([QPointF(x*size,y*size) for x,y in path])
-        
+        polygon = QtGui.QPolygonF([
+            QtCore.QPointF(x*size, y*size) for x, y in path])
+
         rot = turn % 4
-        rect = [QPointF(0.,0.), QPointF(size, 0.), QPointF(size, size), QPointF(0., size)]
-        rotation = [0,90,180,270]
-        
-        nopen = QtGui.QPen(foreColor, Qt.NoPen)
-        foreBrush = QtGui.QBrush(foreColor, Qt.SolidPattern)
+        rect = [
+            QtCore.QPointF(0., 0.), QtCore.QPointF(size, 0.),
+            QtCore.QPointF(size, size), QtCore.QPointF(0., size)]
+        rotation = [0, 90, 180, 270]
+
+        nopen = QtGui.QPen(foreColor)
+        nopen.setStyle(QtCore.Qt.NoPen)
+        foreBrush = QtGui.QBrush(foreColor, QtCore.Qt.SolidPattern)
         if penwidth > 0:
             pen_color = QtGui.QColor(255, 255, 255)
-            pen = QtGui.QPen(pen_color, Qt.SolidPattern)
+            pen = QtGui.QPen(pen_color)
             pen.setWidth(penwidth)
-        
-        painter = QPainter()
+
+        painter = QtGui.QPainter()
         painter.begin(image)
         painter.setPen(nopen)
-        
-        painter.translate(pos[0]*size +penwidth/2, pos[1]*size +penwidth/2)
+
+        painter.translate(pos[0]*size + penwidth/2, pos[1]*size + penwidth/2)
         painter.translate(rect[rot])
         painter.rotate(rotation[rot])
-        
+
         if invert:
             # subtract the actual polygon from a rectangle to invert it
-            poly_rect = QPolygonF(rect)
+            poly_rect = QtGui.QPolygonF(rect)
             polygon = poly_rect.subtracted(polygon)
         painter.setBrush(foreBrush)
         if penwidth > 0:
             # draw the borders
             painter.setPen(pen)
-            painter.drawPolygon(polygon, Qt.WindingFill)
+            painter.drawPolygon(polygon, QtCore.Qt.WindingFill)
         # draw the fill
         painter.setPen(nopen)
-        painter.drawPolygon(polygon, Qt.WindingFill)
-        
+        painter.drawPolygon(polygon, QtCore.Qt.WindingFill)
+
         painter.end()
-        
+
         return image
 
-    ### virtual functions
+    # virtual functions
     def decode(self, code):
         raise NotImplementedError
-        
+
+
 class DonRenderer(IdenticonRendererBase):
     """
     Don Park's implementation of identicon
     see : http://www.docuverse.com/blog/donpark/2007/01/19/identicon-updated-and-source-released
     """
-    
+
     PATH_SET = [
-        #[0] full square:
+        # [0] full square:
         [(0, 0), (4, 0), (4, 4), (0, 4)],
-        #[1] right-angled triangle pointing top-left:
+        # [1] right-angled triangle pointing top-left:
         [(0, 0), (4, 0), (0, 4)],
-        #[2] upwardy triangle:
+        # [2] upwardy triangle:
         [(2, 0), (4, 4), (0, 4)],
-        #[3] left half of square, standing rectangle:
+        # [3] left half of square, standing rectangle:
         [(0, 0), (2, 0), (2, 4), (0, 4)],
-        #[4] square standing on diagonale:
+        # [4] square standing on diagonale:
         [(2, 0), (4, 2), (2, 4), (0, 2)],
-        #[5] kite pointing topleft:
+        # [5] kite pointing topleft:
         [(0, 0), (4, 2), (4, 4), (2, 4)],
-        #[6] Sierpinski triangle, fractal triangles:
+        # [6] Sierpinski triangle, fractal triangles:
         [(2, 0), (4, 4), (2, 4), (3, 2), (1, 2), (2, 4), (0, 4)],
-        #[7] sharp angled lefttop pointing triangle:
+        # [7] sharp angled lefttop pointing triangle:
         [(0, 0), (4, 2), (2, 4)],
-        #[8] small centered square:
+        # [8] small centered square:
         [(1, 1), (3, 1), (3, 3), (1, 3)],
-        #[9] two small triangles:
+        # [9] two small triangles:
         [(2, 0), (4, 0), (0, 4), (0, 2), (2, 2)],
-        #[10] small topleft square:
+        # [10] small topleft square:
         [(0, 0), (2, 0), (2, 2), (0, 2)],
-        #[11] downpointing right-angled triangle on bottom:
+        # [11] downpointing right-angled triangle on bottom:
         [(0, 2), (4, 2), (2, 4)],
-        #[12] uppointing right-angled triangle on bottom:
+        # [12] uppointing right-angled triangle on bottom:
         [(2, 2), (4, 4), (0, 4)],
-        #[13] small rightbottom pointing right-angled triangle on topleft:
+        # [13] small rightbottom pointing right-angled triangle on topleft:
         [(2, 0), (2, 2), (0, 2)],
-        #[14] small lefttop pointing right-angled triangle on topleft:
+        # [14] small lefttop pointing right-angled triangle on topleft:
         [(0, 0), (2, 0), (0, 2)],
-        #[15] empty:
+        # [15] empty:
         []]
-    # get the [0] full square, [4] square standing on diagonale, [8] small centered square, or [15] empty tile:
+    # get the [0] full square, [4] square standing on diagonale,
+    # [8] small centered square, or [15] empty tile:
     MIDDLE_PATCH_SET = [0, 4, 8, 15]
-    
+
     # modify path set
     for idx in xrange(len(PATH_SET)):
         if PATH_SET[idx]:
             p = map(lambda vec: (vec[0] / 4.0, vec[1] / 4.0), PATH_SET[idx])
             PATH_SET[idx] = p + p[:1]
-    
+
     def decode(self, code, twoColor):
         # decode the code
         shift  = 0; middleType  = (code >> shift) & 0x03
@@ -231,25 +237,27 @@ class DonRenderer(IdenticonRendererBase):
         shift += 5; second_green= (code >> shift) & 0x1F
         shift += 5; second_red  = (code >> shift) & 0x1F
         shift += 1; swap_cross  = (code >> shift) & 0x01
-        
+
         middleType = self.MIDDLE_PATCH_SET[middleType]
-        
+
         foreColor = (red << 3, green << 3, blue << 3)
         foreColor = QtGui.QColor(*foreColor)
-        
+
         if twoColor:
-            secondColor = (second_blue << 3, second_green << 3, second_red << 3)
+            secondColor = (
+                second_blue << 3, second_green << 3, second_red << 3)
             secondColor = QtGui.QColor(*secondColor)
         else:
             secondColor = foreColor
-        
+
         return (middleType, middleInvert, 0),\
                (cornerType, cornerInvert, cornerTurn),\
                (sideType, sideInvert, sideTurn),\
                foreColor, secondColor, swap_cross
 
 
-def render_identicon(code, size, twoColor=False, opacity=255, penwidth=0, renderer=None):
+def render_identicon(
+        code, size, twoColor=False, opacity=255, penwidth=0, renderer=None):
     if not renderer:
         renderer = DonRenderer
-    return renderer(code).render(size, twoColor, opacity, penwidth)
\ No newline at end of file
+    return renderer(code).render(size, twoColor, opacity, penwidth)
diff --git a/src/queues.py b/src/queues.py
index e8923db..edc44b9 100644
--- a/src/queues.py
+++ b/src/queues.py
@@ -6,11 +6,13 @@ from multiqueue import MultiQueue
 workerQueue = Queue.Queue()
 UISignalQueue = Queue.Queue()
 addressGeneratorQueue = Queue.Queue()
-# receiveDataThreads dump objects they hear on the network into this queue to be processed.
+# receiveDataThreads dump objects they hear on the network into
+# this queue to be processed.
 objectProcessorQueue = ObjectProcessorQueue()
 invQueue = MultiQueue()
 addrQueue = MultiQueue()
 portCheckerQueue = Queue.Queue()
 receiveDataQueue = Queue.Queue()
-apiAddressGeneratorReturnQueue = Queue.Queue(
-    )  # The address generator thread uses this queue to get information back to the API thread.
+# The address generator thread uses this queue to get information
+# back to the API thread.
+apiAddressGeneratorReturnQueue = Queue.Queue()
diff --git a/src/tr.py b/src/tr.py
index cf7f16a..8a9f7f5 100644
--- a/src/tr.py
+++ b/src/tr.py
@@ -1,39 +1,23 @@
 import os
-
 import shared
 
-# This is used so that the translateText function can be used when we are in daemon mode and not using any QT functions.
-class translateClass:
-    def __init__(self, context, text):
-        self.context = context
-        self.text = text
-    def arg(self,argument):
-        if '%' in self.text:
-            return translateClass(self.context, self.text.replace('%','',1)) # This doesn't actually do anything with the arguments because we don't have a UI in which to display this information anyway.
-        else:
-            return self.text
-
-def _translate(context, text, disambiguation = None, encoding = None, n = None):
-    return translateText(context, text, n)
-
-def translateText(context, text, n = None):
-    try:
-        is_daemon = shared.thisapp.daemon
-    except AttributeError:  # inside the plugin
-        is_daemon = False
-    if not is_daemon:
-        try:
-            from PyQt4 import QtCore, QtGui
-        except Exception as err:
-            print 'PyBitmessage requires PyQt unless you want to run it as a daemon and interact with it using the API. You can download PyQt from http://www.riverbankcomputing.com/software/pyqt/download   or by searching Google for \'PyQt Download\'. If you want to run in daemon mode, see https://bitmessage.org/wiki/Daemon'
-            print 'Error message:', err
-            os._exit(0)
-        if n is None:
-            return QtGui.QApplication.translate(context, text)
-        else:
-            return QtGui.QApplication.translate(context, text, None, QtCore.QCoreApplication.CodecForTr, n)
+try:
+    _daemon = shared.thisapp.daemon
+except AttributeError:  # inside the plugin
+    _daemon = False
+if _daemon:
+    def _translate(context, text, disambiguation=None, n=None):
+        return text
+else:
+    from qtpy import QtWidgets, QtCore
+    if os.environ['QT_API'] == 'pyqt5':
+        _translate = QtWidgets.QApplication.translate
     else:
-        if '%' in text:
-            return translateClass(context, text.replace('%','',1))
-        else:
-            return text
+        def _translate(context, text, disambiguation=None, n=None):
+            return (
+                QtWidgets.QApplication.translate(context, text, disambiguation)
+                if n is None else
+                QtWidgets.QApplication.translate(
+                    context, text, disambiguation,
+                    QtCore.QCoreApplication.CodecForTr, n)
+            )
diff --git a/src/upnp.py b/src/upnp.py
index ad72560..9e6a0b8 100644
--- a/src/upnp.py
+++ b/src/upnp.py
@@ -3,7 +3,7 @@
 import httplib
 from random import randint
 import socket
-from struct import unpack, pack
+from struct import unpack
 import threading
 import time
 from bmconfigparser import BMConfigParser
@@ -14,6 +14,7 @@ import shared
 import state
 import tr
 
+
 def createRequestXML(service, action, arguments=None):
     from xml.dom.minidom import Document
 
@@ -230,7 +231,12 @@ class uPnPThread(threading.Thread, StoppableThread):
                         logger.debug("Found UPnP router at %s", ip)
                         self.routers.append(newRouter)
                         self.createPortMapping(newRouter)
-                        queues.UISignalQueue.put(('updateStatusBar', tr._translate("MainWindow",'UPnP port mapping established on port %1').arg(str(self.extPort))))
+                        queues.UISignalQueue.put((
+                            'updateStatusBar', tr._translate(
+                                "MainWindow",
+                                "UPnP port mapping established on port {0}"
+                            ).format(self.extPort)
+                        ))
                         # retry connections so that the submitted port is refreshed
                         with shared.alreadyAttemptedConnectionsListLock:
                             shared.alreadyAttemptedConnectionsList.clear()
